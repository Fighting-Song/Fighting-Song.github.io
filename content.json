{"meta":{"title":"Fighting-Song","subtitle":"","description":"","author":"Fighting-Song","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"python","slug":"python","date":"2021-02-07T17:33:46.677Z","updated":"2021-02-07T17:37:19.425Z","comments":true,"path":"2021/02/08/python/","link":"","permalink":"http://example.com/2021/02/08/python/","excerpt":"","text":"python一:第一章1.print输出123456789101112print(&#x27;hello,world&#x27;)#输出包含运算符---&gt;4print(3+1)#讲数据输出到文件中,注意使用存在的盘符,并且用file=××的格式fp=open(&#x27;F:/text.text&#x27;,&#x27;a+&#x27;)# &#x27;a+&#x27; --&gt; 如果文件不存在就创建,如果存在就在后面追加内容print(&#x27;hello&#x27;,file=fp)fp.close()#不进行换行输出print(&#x27;hello&#x27;,&#x27;world&#x27;,&#x27;zaima&#x27;) 2.转义字符12345678910111213#转义字符print(&#x27;hello\\nworld&#x27;) # \\n为换行,n--&gt;newline的首字符表示换行print(&#x27;hello\\tworld&#x27;) #水平制表符(4个空格位),每四个占一个,这里hello有五个字符,所以空格为3个print(&#x27;hello\\rworld&#x27;) #输出结果:world ,这里\\r表示回车,后面的world把前面的hello覆盖了print(&#x27;hello\\bworld&#x27;) #输出结果:hellworld \\b 为back回退一格print(&#x27;老师说:\\&#x27;你好\\&#x27;&#x27;) #这里 \\ 为转义字符#原字符,不希望字符中的转义字符起作用,在字符前面加上r或者Rprint(r&#x27;hello\\nworld&#x27;) 3.标识符和保留字1234567891011import keywordprint(keyword.kwlist)#保留字:[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;] 这都是一些关键字不能用来定义文件名字标识符: 变量,函数,类,模块和其他对象起的名字就叫标识符 规则: 字母,数字,下划线 不能以数字开头 不能是保留字(即关键字) 严格区分大小写 4.变量1234567891011name=&#x27;宋旭光&#x27;print(name)print(&#x27;标识&#x27;,id(name))print(&#x27;类型&#x27;,type(name))print(&#x27;值&#x27;,name)输出结果: 宋旭光 标识 2167929238224 类型 &lt;class &#x27;str&#x27;&gt; 值 宋旭光 5.基本类型1.整数int1234567891011#整数类型,可以是二进制,八进制,十进制,十六进制,默认是十进制print(&#x27;十进制&#x27;,118)print(&#x27;二进制&#x27;,0b101010) #二进制以0b开头print(&#x27;八进制&#x27;,0o154) #八进制以0o开头print(&#x27;十六进制&#x27;,0x1EF1) #十六机制以0x开头输出结果: 十进制 118 二进制 42 八进制 108 十六进制 7921 2.字符串str12&#x27;&#x27; 和&quot;&quot; 里面的内容都是在一行输出&quot;&quot;&quot; &quot;&quot;&quot; 和&#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 三引号可以在不同行输出 3.类型转换12345678910name=&#x27;张三&#x27;age=20#print(&#x27;我的名字叫&#x27;+name+&#x27;今年&#x27;+age) 这里因为 + 是连接符,age和name类型不一样不能连接print(&#x27;我的名字叫&#x27;+name+&#x27;今年&#x27;+str(age)) #这里把age的int类型转换为str类型就可以了转换函数: str() int() --&gt;如果是讲float类型转换,会截取小数部分,保留整数部分; 如果将str类型转换为int时,字符串必须是整数,例如&#x27;123&#x27;,不能是小数串:&#x27;12.35&#x27;,如果是非整数串(文字类型),否则会报错 float() ---&gt;非数字串不能转换,即文字不能转换,而数字串可以,bool也可以 6.python注释12345678910#注释单行print(&#x27;hello&#x27;)&#x27;&#x27;&#x27;注释多行,你好啊,这是一个多行注释&#x27;&#x27;&#x27;在文件的开头注释: #coding=utf-8 会被电脑解析 二:运算符1.input输入123456789101112131415161718192021present=input(&#x27;请输入你想要的东西:&#x27;)print(present)#输入两个数进行计算,这里输入都都是字符串类型,所以只能拼接不能计算a=input(&#x27;请输入第一个数:&#x27;)b=input(&#x27;请输入第二个数:&#x27;)print(a+b)#对输入的字符串类型进行类型转化a=input(&#x27;请输入第一个数:&#x27;) a=int(a) #简便方式,直接int()--&gt;a=int(input(&#x27;请输入第一个数:&#x27;))b=input(&#x27;请输入第二个数:&#x27;)b=int(b) #简便方式,直接int()--&gt;b=int(input(&#x27;请输入第二个数:&#x27;))print(a+b)#对输入的字符串类型进行类型转化a=int(input(&#x27;请输入第一个数:&#x27;)) #简便方式,直接int()--&gt;a=int(input(&#x27;请输入第一个数:&#x27;))b=int(input(&#x27;请输入第二个数:&#x27;)) #简便方式,直接int()--&gt;b=int(input(&#x27;请输入第二个数:&#x27;))print(a+b) 2.算术运算12345678910111213print(1+1)print(2-1)print(3*2)print(11/2) #除法运算, 结果为5.5print(11//2) #整除运算 ,结果为5print(11%2) #取余运算,结果为1print(3**3) #幂运算,结果为27,为3*3*3print(-9//4) #-3print(9//-4) #-3 一正一负向下取整print(-9%4) # 3 余数=被除数-除数*商 -9-4*(-3) = -9+12= 3print(9%-4) # -3 3.赋值1234567891011121314151617a=b=c=20 #链式赋值#参数赋值:a=20a+=30 #--&gt;a=a+30=50print(a)a-=10 #--?a=a-10=50-10=40print(a)#解包赋值 左右两边的个数相同a,b,c=10,20,30#交换a,b=10,20print(a,b)#交换后a,b=b,aprint(a,b) 4.比较运算123456789101112131415161718# &gt; &lt; = &gt;= &lt;= != 这些比较结果都是bool类型&#x27;&#x27;&#x27;一个 = 成为赋值运算,== 称为比较运算一个变量由三部分组成, 标识,类型,值== 比较的是值比较对象的标识使用 is&#x27;&#x27;&#x27;a=10b=10print(a==b) #true 说明a和b的value值相等print(a is b) #true 说明a和b的id标识相等list1=[11,22,33]list2=[11,22,33]print(list1==list2) #trueprint(list1 is list2) #falseprint(list1 is not list2) #true --&gt;list1的id与list2的id不相等吗 5.位运算1234567891011# &amp;运算print(4&amp;8) #--&gt;按照二进制运算,即00000100 和00001000 逐位与运算得0# |运算print(4|8)##--&gt;按照二进制运算,即00000100 和00001000 逐位或运算得12print(4&lt;&lt;1)#向左移动一位,相当于乘2 --&gt;4*2=8print(4&lt;&lt;2)#向左移动两位,相当于乘4 --&gt;4*2*2=16print(4&gt;&gt;1)#向右移动一位,相当于除乘2 --&gt;4/2=2print(4&gt;&gt;2)#向右移动两位,相当于除乘4 --&gt;4/2/2=1 6.运算符优先级123456** --&gt;*,/,//,%--&gt; +,- --&gt; &lt;&lt;,&gt;&gt; --&gt;&amp; --&gt;| --&gt; &gt;,&lt;,&gt;=,&lt;=,==,!= --&gt;and --&gt;or --&gt; =| &lt;--算术运算--&gt; | &lt;--位运算符--&gt; | &lt;--比较运算--&gt; | &lt;--bool运算--&gt;|&lt;--赋值运算--&gt; 三:分支结构1.对象的布尔值123456789101112131415161718192021222324#以下对象的bool值为Falseprint(bool(False)) #Falseprint(bool(0)) #Falseprint(bool(0.0)) #Falseprint(bool(None)) #Falseprint(bool(&#x27;&#x27;)) #Falseprint(bool(&quot;&quot;)) #Falseprint(bool([])) #空列表print(bool(list())) #空列表print(bool(())) #空元组print(bool(tuple())) #空元组print(bool(&#123;&#125;)) #空字典print(bool(dict())) #空字典print(bool(set())) #空集合#其他对象的bool值都是True#这里可以直接把对象放入条件表达式中例如:age=int(input(&#x27;请输入年龄:&#x27;))if age: #---&gt;这里如果为ture,直接往下执行 print(age)else: print(&#x27;年龄为:&#x27;,age) 2.单分支结构(if)12345678910&#x27;&#x27;&#x27; 语法: if 条件表达式: 条件执行体&#x27;&#x27;&#x27;money=1000a=int(input(&#x27;请输入要取款的金额:&#x27;))if money&gt;=a: money=money-a print(&#x27;剩余金额:&#x27;,money) 3.双分支结构(if..else)1234567891011121314&#x27;&#x27;&#x27; 语法: if 条件表达式: 条件执行体1 else: 条件执行体2&#x27;&#x27;&#x27;#输入一个数判断是奇数还是偶数num = int(input(&#x27;请输入一个整数&#x27;))if num%2==0: print(num,&#x27;是偶数&#x27;)else: print(num,&#x27;是奇数&#x27;) 4.多分支结构12345678910111213141516171819202122232425262728293031323334353637383940414243&#x27;&#x27;&#x27; 语法: if 条件表达式1: 条件执行体1 elif 条件表达式2: 条件执行体2 elif 条件表达式N: 条件执行体N [else:] --&gt;可以省略 条件执行体N+1&#x27;&#x27;&#x27;#输入一个数判断等级score=int(input(&#x27;请输入一个数:&#x27;))if score&gt;=90 and score&lt;=100: print(&#x27;A&#x27;)elif score&gt;=80 and score&lt;90: print(&#x27;B&#x27;)elif score&gt;=70 and score&lt;80: print(&#x27;C&#x27;)elif score&gt;=60 and score&lt;70: print(&#x27;D&#x27;)elif score&gt;=0 and score&lt;60: print(&#x27;E&#x27;)else: print(&#x27;您输入的成绩不符合&#x27;) 简介写法: #输入一个数判断等级score=int(input(&#x27;请输入一个数:&#x27;))if 90&lt;=score&lt;=100: print(&#x27;A&#x27;)elif 80&lt;=score&lt;90: print(&#x27;B&#x27;)elif 70&lt;=score&lt;80: print(&#x27;C&#x27;)elif 60&lt;=score&lt;70: print(&#x27;D&#x27;)elif 0&lt;=score&lt;60: print(&#x27;E&#x27;)else: print(&#x27;您输入的成绩不符合&#x27;) 5.嵌套if12345678910111213141516171819202122&#x27;&#x27;&#x27; 语法: if 条件表达式1: if 内层条件表达式: 内层条件执行体1 else: 内层条件执行体2 else: 条件执行体&#x27;&#x27;&#x27;#判断是否是会员根据消费金额打折answer=input(&#x27;是否是会员,请输入y/n:&#x27;)count = float(input(&#x27;请输入您得消费金额:&#x27;))if answer==&#x27;y&#x27;: if count&gt;=200: print(&#x27;打八折,您消费:&#x27;,count*0.8) elif count&gt;=100: print(&#x27;打九折,您消费:&#x27;,count*0.9)else: if count&gt;=200: print(&#x27;打九五折,您消费;&#x27;,count*0.95) 6.条件表达式123456789101112#输入两个数,比较大小num_a=int(input(&#x27;请输入第一个数:&#x27;))num_b=int(input(&#x27;请输入第二个数:&#x27;))if num_a&gt;=num_b: print(num_a,&#x27;大于&#x27;,num_b)else: print(num_a,&#x27;小于&#x27;,num_b) #简写print( str(num_a)+&#x27;大于&#x27;+str(num_b) if num_a&gt;num_b else str(num_a)+&#x27;小于&#x27;+str(num_b)) 7.pass12345678#pass什么都不做,只是一个占位符,在搭建代码流程时,没有写代码的地方用pass,可以不报错answer=input(&#x27;是否是会员&gt;y/n&#x27;)#判断if answer==&#x27;y&#x27;: passelse: pass 四:循环1.range函数 用来生成一个整数序列 创建range对象的三种方式 range(stop) range(start,stop) range(start,stop,step) 12345678910111213141516#第一种创建方式,只有一个参数r=range(10)print(r) #range(0, 10)print(list(r)) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],默认从0开始,相差为1.即步长为1#第二种创建方式,两个参数r=range(1,10) #第一个参数是开始,第二个参数是结束,即从1开始,到10结束(不包含10),默认步长为1print(list(r)) #[1, 2, 3, 4, 5, 6, 7, 8, 9]#第三种创建方式,三个参数r=range(1,10,2)print(list(r))#[1, 3, 5, 7, 9],步长为2#判断一个数是否在这个序列中print(10 in r) #Falseprint(20 not in r) #True 2.while循环 选择结构的if和循环结构的while的区别 if是判断一次,条件为true执行一次 while是判断N+1次,条件为True执行N次 12345678910111213&#x27;&#x27;&#x27; 语法: while 条件表达式: 条件执行体(循环体)&#x27;&#x27;&#x27;#求4以内的整数合sum=0a=0while a&lt;5: sum+=a a+=1print(sum) 3.小练习12345678910111213141516171819202122232425262728293031323334353637#1-100之间的偶数和sum=0r=1while r&lt;=100: if r%2==0: sum+=r r+=1print(&#x27;求和:&#x27;,sum)#1-100之间的偶数和sum=0r=1while r&lt;=100: if not bool(r%2): sum+=r r+=1print(&#x27;求和:&#x27;,sum)#1-100之间奇数和sum=0r=1while r&lt;=100: if r%2: #这里偶数满足条件都为False sum+=r r+=1print(&#x27;求和:&#x27;,sum)#1-100之间的偶数和sum=0for i in range(1,101): if i%2==0: sum+=iprint(sum) 4.for-in循环1234567891011121314151617181920212223242526272829303132333435363738394041&#x27;&#x27;&#x27; 语法: for 自定义的变量 in 可迭代对象: 循环体&#x27;&#x27;&#x27;#字符串循环遍历for item in &#x27;Python&#x27;:print(item)#输出结果:&#x27;&#x27;&#x27;Python&#x27;&#x27;&#x27;#range()产生的一个整数序列也是一个可迭代对象for i in range(10): print(i) #如果在循环体中不需要用到自定义的变量,可将自定义变量写为&quot;_&quot;for _ in range(5): print(&#x27;人生苦短&#x27;)&#x27;&#x27;&#x27;输出结果:人生苦短人生苦短人生苦短人生苦短人生苦短&#x27;&#x27;&#x27;#1-100之间的偶数和sum=0for i in range(1,101): if i%2==0: sum+=iprint(sum) 5.水仙花12345678910#求三位数的水仙花数: 153=3*3*3+5*5*5+1*1*1for item in range(100,1000): ge=item%10 shi=item//10%10 bai=item//100 #print(bai,shi,ge) #判断: if ge**3+shi**3+bai**3==item: print(item) 6.break 用于结束循环结构,通常与分支结构if一起使用 123456789#输入三次密码,如果密码正确则通过,三次不正确就结束for item in range(3): &#x27;&#x27;&#x27;下面的都是条件循环体&#x27;&#x27;&#x27; pwd=input(&#x27;请输入密码:&#x27;) if pwd==&#x27;8888&#x27;: print(&#x27;密码正确&#x27;) break else: print(&#x27;密码不正确&#x27;) 和while循环搭配使用 12345678910#输入三次密码,如果密码正确则通过,三次不正确就结束a=0while a&lt;3: pwd=input(&#x27;请输入密码:&#x27;) if pwd==&#x27;8888&#x27;: print(&#x27;密码正确&#x27;) break else: print(&#x27;密码不正确&#x27;) a+=1 7.continue 用于结束当前循环,进入下一次循环,通常与分支结构if一起使用 12345#使用continue,求1-50之间的5的倍数for item in range(1,51): if item%5!=0: continue print(item) 8.嵌套循环12345#输出一个三行四列的矩阵for i in range(3): for j in range(4): print(&#x27;*&#x27;,end=&#x27;\\t&#x27;) print() 12345#输出一个九九乘法表for i in range(1,10): for j in range(1,i+1): print(str(i)+&#x27;*&#x27;+str(j)+&#x27;=&#x27;+str(i*j),end=&#x27;\\t&#x27;) print() 12345678910111213141516#continuefor i in range(5): for j in range(1,11): if j%2==0: continue print(j,end=&#x27;\\t&#x27;) print() &#x27;&#x27;&#x27; 输出结果: 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 &#x27;&#x27;&#x27; 五:列表1.列表的创建12345#创建列表的第一种方式lst=[&#x27;hello&#x27;,&#x27;world&#x27;,95]#创建列表的第二种方式,使用内置函数lst2=list([&#x27;hello&#x27;,&#x27;world&#x27;,95]) 2.获取列表的索引1234list=[&#x27;hello&#x27;,&#x27;world&#x27;,95,&#x27;hello&#x27;]print(list.index(&#x27;hello&#x27;)) #结果为:0 如果列表中有相同元素,会返回第一个元素的索引#print(list.index(&#x27;Python&#x27;)) #如果不存在,会抛出异常:&#x27;Python&#x27; is not in listprint(list.index(&#x27;hello&#x27;,1,4)) #结果为:3 3.获取列表中指定元素123获取单个元素: 正向索引从0到N-1 例如:list[0] 逆向索引从-N到-1 例如:list[-1] 4.列表切片12345678910list=[10,20,30,40,50,60,70,80]list1=list[1:6:1] #[起始位置:结束位置:步长],即[start:stop:step]#结果为:[20, 30, 40, 50, 60]list2=list[:6:2] #默认是从0位置开始list3=list[1::2] #默认是到结尾结束print(list1[::-1]) #结果:逆序输出:[80, 70, 60, 50, 40, 30, 20, 10]#即从最后一个开始,逆序排序,start为7print(list1[7::-1]) 5.遍历123list=[10,20,30,40,50,60,70,80]for item in list: print(item) 6.列表增加元素 append() extend() insert() 切片 12345678910list=[10,20,30]list.append(100)print(list) #结果:[10, 20, 30, 100]list1=[&#x27;nihao&#x27;,&#x27;daa&#x27;]#list.append(list1) #[10, 20, 30, 100, [&#x27;nihao&#x27;, &#x27;daa&#x27;]],把list1作为一个元素添加#list.extend(list1) #[10, 20, 30, 100, &#x27;nihao&#x27;, &#x27;daa&#x27;] ,在list尾部扩展,在末尾一次性添加多个元素#list.insert(1,50) #[10, 50, 20, 30, 100],在固定位置添加一个元素list2=[&#x27;在吗&#x27;,&#x27;false&#x27;]list[1:]=list2 #[10, &#x27;在吗&#x27;, &#x27;false&#x27;],把指定位置后全部切除,添加新的print(list) 7.列表删除元素 remove() pop() 切片 clear() del 1234567891011list=[10,20,30,40,50]#list.remove(30) #[10, 20, 40, 50],移除一个元素,如果有重复的,移除相同的第一个元素#list.pop(1) #[10, 30, 40, 50],根据下标移除元素#list.pop() #[10, 20, 30, 40],如果不指定会删除最后一个元素#切片#new_list=list[1:3] #[20, 30],产生了一个新的对象#list[1:3]=[] #[10, 40, 50],将切除的部分用空替代#list.clear() #[],清楚列表del list #删除列表print(list) 8.列表修改123456list=[10,20,30,40,50]#list[1]=1000 #[10, 1000, 30, 40, 50],修改一个值#修改列表当中多个值list[1:3]=[100,200,300] #[10, 100, 200, 300, 40, 50]print(list) 9.列表排序123456789101112list=[10,43,31,50,11]#list.sort() #[10, 11, 31, 43, 50],默认升序排列,不产生新的列表对象#通过指定关键字参数,是排序为降序#list.sort(reverse=True) #[50, 43, 31, 11, 10],不产生新的列表对象#使用内置函数sorted()排序,产生一个新的列表对象#new_list=sorted(list) #[10, 11, 31, 43, 50]#指定关键字降序new_list=sorted(list,reverse=True) #[50, 43, 31, 11, 10]print(new_list) 10.列表生成式123456#list=[i for i in range(1,10)] #[1, 2, 3, 4, 5, 6, 7, 8, 9]#list=[i*i for i in range(1,10)] #[1, 4, 9, 16, 25, 36, 49, 64, 81]#产生2,4,6,8,10list=[i*2 for i in range(1,6)] #[2, 4, 6, 8, 10]print(list) 六:字典1.字典的创建123456781.使用花括号 scores=&#123;&#x27;张三&#x27;:100,&#x27;李四&#x27;:60&#125; 2.使用内置函数dict() dict(name=&#x27;Jack&#x27;,age=20) 3.空字典d=&#123;&#125; 2.字典元素的获取1234scores=&#123;&#x27;张三&#x27;:100,&#x27;李四&#x27;:60&#125;print(scores[&#x27;张三&#x27;]) #如果没有则会报错print(scores.get(&#x27;张三&#x27;)) #如果没有则会返回Noneprint(scores.get(&#x27;李贺&#x27;,60))#如果查找得value不存在,就会返回 后面的这个默认值 3.字典元素的增删改123456scores=&#123;&#x27;张三&#x27;:100,&#x27;李四&#x27;:60&#125;#del scores[&#x27;张三&#x27;] #删除指定的key-value#scores.clear() #清除scores[&#x27;王五&#x27;]=200 #新增元素scores[&#x27;王五&#x27;]=300 #修改元素print(scores) 4.获取字典视图123456789scores=&#123;&#x27;张三&#x27;:100,&#x27;李四&#x27;:60&#125;keys=scores.keys()print(list(keys)) #[&#x27;张三&#x27;, &#x27;李四&#x27;],将所有的key组成的视图转换成列表values=scores.values()print(list(values)) #[100, 60]items=scores.items()print(list(items))#[(&#x27;张三&#x27;, 100), (&#x27;李四&#x27;, 60)],转换后叫元组,由()构成 5.字典元素遍历12345678scores=&#123;&#x27;张三&#x27;:100,&#x27;李四&#x27;:60&#125;for item in scores: print(item,scores[item],scores.get(item)) &#x27;&#x27;&#x27;张三 100 100李四 60 60&#x27;&#x27;&#x27; 12345678scores=[&#123;&#x27;name&#x27;:&quot;lisi&quot;,&#x27;age&#x27;:50&#125;,&#123;&#x27;name&#x27;:&quot;zhangsan&quot;,&#x27;age&#x27;:60&#125;]for item in scores: print(item.get(&quot;name&quot;),item.get(&quot;age&quot;)) &#x27;&#x27;&#x27; lisi 50zhangsan 60&#x27;&#x27;&#x27; 6.字典生成式1234items=[&#x27;Fruits&#x27;,&#x27;Books&#x27;,&#x27;Others&#x27;]price=[20,30,45]d=&#123; item:price for item,price in zip(items,price) &#125;print(d) #&#123;&#x27;Fruits&#x27;: 20, &#x27;Books&#x27;: 30, &#x27;Others&#x27;: 45&#125; 七:元组 可变序列:可以进行增删改操作,例如: 列表,字典 不可变序列,不可以进行增删改操作,例如: 元组,字符串 1.元组的创建方式 不可变,可重复,有序 1234567891011121.直接小括号t=(&#x27;Python&#x27;,&#x27;hello&#x27;,96)2.使用内置函数tuple()t=tuple((&#x27;Python&#x27;,&#x27;hello&#x27;,32))3.只包含一个元组的元素需要用逗号和小括号t=(10,)4.创建空元组t=()t=tuple() 2.元组的遍历123t=(&#x27;Python&#x27;,&#x27;hello&#x27;,96)for item in t: print(item) 八:集合 集合是无序的 集合不允许有重复元素 1.集合创建123456789101112131415161718#第一种创建方式s=&#123;1,2,1,3,3,3,4&#125; #&#123;1, 2, 3, 4&#125;,集合不允许有重复的数字print(s)#第二种创建方式set()s1=set(range(6))print(s1) #&#123;0, 1, 2, 3, 4, 5&#125;,将列表转为集合s2=set([1,2,3,4,4,5,5])print(s2) #&#123;1, 2, 3, 4, 5&#125;s3=set((1,2,3,3,4,65))print(s3) #&#123;&#123;65, 1, 2, 3, 4&#125; ,将元组转为集合,并且集合是无序的s4=set(&#x27;Python&#x27;)print(s4) #&#123;&#x27;t&#x27;, &#x27;P&#x27;, &#x27;h&#x27;, &#x27;y&#x27;, &#x27;o&#x27;, &#x27;n&#x27;&#125; ,将字符串转为集合s5=set() #定义空集合 2.集合的相关操作123456789101112s=&#123;12,20,30,40&#125;#元素新增操作s.add(50) #一次添加一个s.update(&#123;20,30,60,70&#125;) #添加至少一个,可以添加多个s.update([60,66,22])s.update((26,84,96))#集合元素的删除s.remove(20) #如果没有会抛出异常s.discard(500) #如果删除的元素没有不会抛出异常s.pop() #任意删除一个元素,随机的s.clear() #清空 3.集合之间的关系123456789101112131415s1=&#123;10,20,30&#125;s2=&#123;30,20,10&#125;print(s1==s2) #Trueprint(s1!=s2) #False#判断一个集合是否是另一个集合的子集s1=&#123;10,20,30,40&#125;s2=&#123;10,20&#125;print(s2.issubset(s1)) #True#判断一个集合是否是另一个集合的超子集print(s1.issuperset(s2)) #True#两个集合是否没有交集print(s2.isdisjoint(s1)) #False 4.集合的操作12345678910111213141516s1=&#123;10,20,30,40,50&#125;s2=&#123;10,20,60&#125;print(s1.intersection(s2)) #求交集&#123;10, 20&#125;print(s1 &amp; s2) # intersection()和 &amp; 相同#并集print(s1.union(s2)) #&#123;50, 20, 40, 10, 60, 30&#125;print(s1 | s2)#&#123;50, 20, 40, 10, 60, 30&#125; ,union()和 | 相同#差集print(s1.difference(s2)) #&#123;40, 50, 30&#125;print(s1-s2) #&#123;40, 50, 30&#125;,difference()和 - 相等#对称差集print(s1.symmetric_difference(s2)) #&#123;40, 50, 60, 30&#125;print(s1 ^ s2) #&#123;40, 50, 60, 30&#125; 5.集合生成式1&#123;i*i for i in range(1,10)&#125; 九:字符串1.字符串的创建和驻留机制123a=&#x27;Python&#x27;b=&quot;Python&quot;c=&#x27;&#x27;&#x27;Python&#x27;&#x27;&#x27; #这三个a,b,c的id相同,指向同一个地址 2.字符串的查询操作 index(),查找substr第一次出现的位置,如果查找的子串不存在,会抛出ValueError rindex(),查找substr最后一次出现的位置,如果查找的子串不存在,会抛出ValueError find(),查找substr第一次出现的位置,如果查找的子串不存在,则返回-1 rfind(),查找substr最后一次出现的位置,如果查找的子串不存在,则返回-1 12345s=&#x27;hello,hello&#x27;print(s.index(&#x27;lo&#x27;)) #3print(s.find(&#x27;lo&#x27;))#3print(s.rindex(&#x27;lo&#x27;)) #9print(s.rfind(&#x27;lo&#x27;))#9 3.字符串的大小写转换123456789s=&#x27;hello,python&#x27;a=s.upper() #转换成大写之后,会产生一个新的字符串对象b=s.lower() #转换成小写之后,会产生一个新的字符串对象s=&#x27;hello,Python&#x27;print(s.swapcase()) #HELLO,pYTHON,大写转小写,小写转大写print(s.title()) #Hello,Python,把每个单词的首字母变成大写,其余小写print(s.capitalize()) #Hello,python,把第一个字符换成大写,其余小写 4.字符串对齐操作1234567891011121314151617s=&#x27;hello,Python&#x27;&#x27;&#x27;&#x27;居中对齐&#x27;&#x27;&#x27;print(s.center(20,&#x27;*&#x27;)) #****hello,Python****,第一个参数指定宽度,后面表示填充&#x27;&#x27;&#x27;左对齐&#x27;&#x27;&#x27;print(s.ljust(20,&#x27;*&#x27;)) #hello,Python********,左对齐print(s.ljust(10)) #hello,Python,如果范围小,就返回原字符print(s.ljust(20)) #hello,Python,填充符不写,用空格补充&#x27;&#x27;&#x27;右对齐&#x27;&#x27;&#x27;print(s.rjust(20,&#x27;*&#x27;)) #********hello,Pythonprint(s.rjust(10)) #hello,Pythonprint(s.rjust(20)) # hello,Python&#x27;&#x27;&#x27;右对齐&#x27;&#x27;&#x27;print(s.zfill(20)) #00000000hello,Python,只有一个参数,用0填充print(&#x27;-2531&#x27;.zfill(10)) #-000002531 5.字符串的劈分12345678s=&#x27;hello world python&#x27;print(s.split()) #[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]s1=&#x27;hello|world|python&#x27;print(s1.split(sep=&#x27;|&#x27;)) #[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;],指定&#x27;|&#x27;为分隔符print(s1.split(sep=&#x27;|&#x27;,maxsplit=1)) #[&#x27;hello&#x27;, &#x27;world|python&#x27;],指出最大的分段为1段#rsplit()是从右边劈分 6.字符串的判断方法1234561.isidentifier() #判断指定的字符是否是合法的标识符,字母,数字,下划线才是合法的2.isspace() #判断指定的字符串是否由空白字符组成(回车,换行,水平制表符)3.isalpha() #判断指定的字符是否由字母组成,汉字也算4.isdecimal() #判断指定的字符串是否由十进制的数字组成5.isnumeric() #判断指定的字符串是否全部由数字组成(一二三的汉字也算,罗马数字也算)6.isalunm() #判断指定的字符串是否全部由字母和数字组成 7.替换与合并1234567891011121314s=&#x27;hello,Python&#x27;print(s.replace(&#x27;Python&#x27;,&#x27;Java&#x27;)) #hello,Javas1=&#x27;hello,Python,Python,Python&#x27;print(s1.replace(&#x27;Python&#x27;,&#x27;Java&#x27;,2)) #hello,Java,Java,Python,指定替换的次数#join连接s2=[&#x27;hello&#x27;,&#x27;Python&#x27;,&#x27;Java&#x27;]print(&#x27;|&#x27;.join(s2)) #hello|Python|Javas3=(&#x27;hello&#x27;,&#x27;Python&#x27;,&#x27;Java&#x27;)print(&#x27;&#x27;.join(s3)) #helloPythonJavaprint(&#x27;*&#x27;.join(&#x27;Python&#x27;)) #P*y*t*h*o*n 8.字符串的比较12345678910print(&#x27;apple&#x27;&gt;&#x27;app&#x27;)#Trueprint(&#x27;apple&#x27;&gt;&#x27;bananer&#x27;)#Falseprint(ord(&#x27;a&#x27;),ord(&#x27;b&#x27;)) #97 98,比较原理print(chr(97),chr(98)) #a b&#x27;&#x27;&#x27;==和is的区别==比较的是valueis比较的是id&#x27;&#x27;&#x27; 9.字符串格式化(format)1234567891011121314151617181920name=&#x27;张三&#x27;age=20# %占位print(&#x27;我叫%s,今年%d岁&#x27; % (name,age)) #我叫张三,今年20岁#使用&#123;&#125;print(&#x27;我叫&#123;0&#125;,今年&#123;1&#125;岁&#x27;.format(name,age)) #我叫张三,今年20岁#f-stringprint(f&#x27;我叫&#123;name&#125;,今年&#123;age&#125;岁&#x27;) #我叫张三,今年20岁print(&#x27;%10d&#x27; % 99) # 99,10表示宽度print(&#x27;%.3f&#x27; % 3.1415926) #3.142,保留三位小数#同时表示宽度和精度print(&#x27;%10.3f&#x27; % 3.1415926) # 3.142#使用&#123;&#125;print(&#x27;&#123;0:.3&#125;&#x27;.format(3.1415926)) #3.14,这里3表示共有3位数print(&#x27;&#123;0:.3f&#125;&#x27;.format(3.1415926)) #3.142,保留3位小数print(&#x27;&#123;0:10.3f&#125;&#x27;.format(3.1415926)) # 3.142,同时设置宽度和精度 10.字符串的编码与解码123456789s=&#x27;海上生明月&#x27;#编码print(s.encode(encoding=&#x27;GBK&#x27;))print(s.encode(encoding=&#x27;UTF-8&#x27;))#解码byte=s.encode(encoding=&#x27;UTF-8&#x27;)#byte代表一个二进制数据(字节类型的数据)print(byte.decode(encoding=&#x27;UTF-8&#x27;)) 十一:函数1.函数参数传递1234567891011121314151617181920212223242526def fun(arg1,arg2): print(&#x27;arg1&#x27;,arg1) print(&#x27;arg2&#x27;,arg2) arg1=100 arg2.append(200) print(&#x27;arg1&#x27;,arg1) print(&#x27;arg2&#x27;,arg2)n1=11n2=[10,20,30]fun(n1,n2)print(&#x27;n1&#x27;,n1)print(&#x27;n2&#x27;,n2)&#x27;&#x27;&#x27;arg1 11arg2 [10, 20, 30]arg1 100arg2 [10, 20, 30, 200]n1 11n2 [10, 20, 30, 200]在函数调用过程中,进行参数的传递如果是不可变对象,在函数体的修改不会影响实参的值,即arg1的值修改为100不会影响 arg1=11如果是可变对象,在函数体的修改会影响实参的值,arg2的修改,append(200),会影响n2的值&#x27;&#x27;&#x27; 2.函数的返回值1234函数的返回值: 1.如果函数没有返回值[函数执行完毕后,不需要给调用处提供数据,],return可以省略不写 2.函数没有返回值,如果是1个,直接返回类型 3.函数的返回值,如果是多个,返回的结果为元组 3.函数的默认值12345def fun(a,b=10) print(a,b)#函数的调用fun(100) #--&gt;只传一个参数,b采用默认值fun(20,30) #--&gt;30将默认值10替代 4.函数参数定义12345678910111213141516171819202122232425def fun(*args): #函数定义时,可变的位置参数 print(args)fun(10)fun(10,20)fun(10,20,30)#个数可变的关键字形参,结果是一个字典def fun1(**args): print(args)fun1(a=10)fun1(a=10,b=20)&#x27;&#x27;&#x27;&#123;&#x27;a&#x27;: 10&#125;&#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20&#125;&#x27;&#x27;&#x27;#个数可变的位置参数和关键字参数可以结合,ps:必须个数可变的位置形参,放在个数可变的关键字形参之前def fun3(*arg1,**arg2) passdef fun3(**arg1,*arg2) #这样会报错 passdef fun4(a,b,*,c,d) #从*之后的参数,在函数调用时,只能采用关键字参数传递 5.变量作用域1234def fun() global age #函数内部生命的变量,局部变量使用global声明,这个变量实际上就变成了全局变量 age=20 print(age) 6.递归函数1234567#计算阶乘def fun1(n): if n==1: return 1 else: return n*fun1(n-1)print(fun1(6)) 7.斐波那契数列123456789101112def fun(n): if n==1: return 1 if n==2: return 1 else: return fun(n-1)+fun(n-2)print(fun(6)) #8#输出前6位的数,用列表for i in range(1,7): print(fun(i)) 十二.异常处理机制1.捕获异常1.try-except12345try: 函数执行体except 异常类型: 函数执行体 捕获异常的顺序按照先子类后父类的顺序,为例避免遗漏可能出现的异常,可以在最后增加BaseException 123456789#多个异常处理try: 代码except Exception1: 代码except Exception2: 代码except BaseException: 代码 2.try-except-else 如果try中没有抛出异常,则执行else,如果try抛出异常,则执行except 123456try: 代码except: 代码else: 代码 3.try-except-else-finally finally无论是否发生异常都会被执行,能常用来释放try块中申请的资源 12345678try: 代码except: 代码else: 代码finally: 代码 2.常见的异常类 ZeroDivisionError —&gt;除零 indexError —&gt;序列中没有此索引 KeyEoor —&gt;映射中没有这个键 NameError —&gt;未声明/初始化对象(没有属性) SyntaxError —&gt;Python语法错误 ValueError —&gt;传入无效的参数 3.traceback 打印错误日志 123456import tracebacktry: print(&#x27;----------&#x27;) print(1/0)except: traceback.print_exc() 十三:类1.类的创建 在类外定义为函数,在类内定义为方法 123456789101112131415161718192021class Student: native_place=&#x27;河南&#x27; #直接写在类里面的变量,称为类属性 def __init__(self,name,age): self.name=&#x27;张三&#x27; #self.name称为实例属性,进行了一个赋值操作,将局部变量的name的值赋给实体属性 self.age=20 #实例方法: def info(self): #这里self指的是需要传入一个自身类型的对象 print(&#x27;我的名字是:&#x27;,self.name,&#x27;年龄是:&#x27;,self.age) #静态方法: @staticmethod def tm(): print(&#x27;------&#x27;) #类方法 @classmethod def cm(cls): print(&#x27;------&#x27;) 2.对象的创建12345stu1=Student(&#x27;张三&#x27;,20)stu1.info() #对象名.方法名print(stu1.name)print(stu1.age)Student.info(stu1) #类名.方法名(类的对象),实际上是方法定义的self 3.类属性,类方法调用 类属性: 类中方法外的变量称为类属性,被该类的所有对象所共享 类方法: 使用类名直接访问方法 静态方法: 使用类名直接访问方法 123print(Student.native_place) #访问类属性Student.cm() #调用类方法Student.tm() #调用静态方法 4.动态绑定属性和方法123456789101112131415class Student: def __init__(self,name,age): self.name=&#x27;张三&#x27; self.age=20 def eat(self): print(self.name+&#x27;在吃饭&#x27;)stu1=Student(&#x27;张三&#x27;,20)stu2=Student(&#x27;李四&#x27;,30)stu2.gender=&#x27;女&#x27; #只针对当前的对象print(stu2.gender)def show(): print(&#x27;定义在类外的函数&#x27;)stu1.show=show() #只针对当前的对象stu1.show 5.封装12345678910class Student: def __init__(self,name,age): self.name=&#x27;张三&#x27; self.__age=20 #年龄不希望在类的外部被使用,所以加了两个_ def eat(self): print(self.name+&#x27;在吃饭&#x27;) stu1=Student(&#x27;张三&#x27;,20)#print(dir(stu1)) dir()可以查看对象所有的属性print(stu1._Student__age) #在类的外面可以通过_Student__age进行访问 6.继承 如果一个类没有继承任何类,默认继承object Python支持多继承 定义子类时,必须在其构造函数中调用父类的构造函数 123语法格式: class 子类类名(父类1,父类2): pass 12345678910111213141516171819202122class Person(object): #默认继承object def __init__(self,name,age): self.name=name self.age=age def info(self): print(self.name,self.age)class Student(Person): def __init__(self,name,age,stu_no): super().__init__(name,age) self.stu_no=stu_noclass Teacher(Person): def __init__(self,name,age,year): super().__init__(name,age) self.year=yearstu=Student(&#x27;张三&#x27;,20,&#x27;1234&#x27;)teacher=Teacher(&#x27;王老师&#x27;,30,10)stu.info()teacher.info() 7.重写12345678910111213141516171819202122232425262728class Person(object): #默认继承object def __init__(self,name,age): self.name=name self.age=age def info(self): print(self.name,self.age)class Student(Person): def __init__(self,name,age,stu_no): super().__init__(name,age) self.stu_no=stu_no def info(self): super().info() #保留,调用父方法 print(&#x27;学号是:&#x27;+self.stu_no) #改写增加新的方法输出class Teacher(Person): def __init__(self,name,age,year): super().__init__(name,age) self.year=year def info(self): super().info() #保留,调用父方法 print(&#x27;教学时间:&#x27;,self.year)#改写增加新的方法输出stu=Student(&#x27;张三&#x27;,20,&#x27;1234&#x27;)teacher=Teacher(&#x27;王老师&#x27;,30,10)stu.info()teacher.info() 8.object类123456789class Student: def __init__(self,name,age): self.name=&#x27;张三&#x27; self.age=20 def __str__(self): return &#x27;我的名字是&#123;0&#125;,我的年龄是&#123;1&#125;&#x27;.format(self.name,self.age)stu=Student(&#x27;张三&#x27;,20)print(dir(stu)) # dir()可以查看对象所有的属性print(stu) #默认调用__str__方法 9.特殊方法1234567891011class Student: def __init__(self,name): self.name=name def __add__(self, other): return self.name+other.name def __len__(self): return len(self.name)stu1=Student(&#x27;Jack&#x27;)stu2=Student(&#x27;李四&#x27;)print(stu1+stu2) #将两个对象相加,因为重新编写了__add__()方法print(len(stu1)) #4 ,len()是求长度的 10.拷贝1234变量的赋值操作: 只是形成两个变量,实际上还是指向同一个对象cpu1=CPU()cpu2=cpu1 --&gt;这两个id相同 123456789浅拷贝: 一般为浅拷贝,对象包含的子对象内容不拷贝,拷贝后的子对象id相同深拷贝: deepcopy函数,递归拷贝对象中包含的子对象,源对象和拷贝对象所有的子对象也不相同,拷贝后的子对象id不同#浅拷贝import copycomputer=Computer(cpu1,disk)computer2=copy.copy(computer) 十四:模块1.模块导入123456789语法: import 模块名称 [as 别名] 例子: import math from 模块名称 import 函数/变量/类 例子: from math import pi print(pi) #只导入了math里面的pi 2.主程序运行123456def add(a,b): return a+b#输入 mainif __name__ == &#x27;__main__&#x27;: #加入后,别的类调用时就不会显示打印输出,只有在本文件点击执行才运行输出 print(&#x27;add执行了&#x27;) 3.包注意事项: import导入时 import 包名 import 模块名 from 包名 import from 包名 ipmort 模块名 from 包名.模块名 imoprt 变量/函数等 12语法: import 包名.模块名 [as 别名] 4.常用的内容模块 sys 与python解释器及其环境操作相关的标准库 time 提供与时间相关的各种函数的标准库 os 提供了访问操作系统服务功能的标准库 calendar 提供与日期相关的各种函数的标准库 urllib 用于读取来自网上(服务器)的数据标准库 json 用于使用JSON序列化和反序列化对象 re 用于在字符串中执行正则表达式匹配和替换 math 提供标准算数运算函数的标准库 decimal 用于及逆行精确控制运算精度,有效数位和四舍五入操作的十进制运算 logging 提供了灵活的记录事件,错误,警告和调试信息等日志信息的功能 5.第三方模块安装和使用12345安装: pip install 模块名 使用: import 模块名 十五:文件1.文件读写12345678语法: file=open(filename [,mode,encoding]) file--&gt;被创建的文件对象 open--&gt;创建文件对象的函数 filename--&gt;要创建或打开的文件名称 mode--&gt;打开模式默认认为只读 encoding--&gt;默认文本文件中字符的编写格式为gbk 123file=open(&#x27;a.txt&#x27;,&#x27;r&#x27;)print(file.readlines()) #读出每行file.close() #关闭流 2.文件打开模式 r 以只读模式打开文件,文件的指针会放在文件的开头 w 以只写模式打开文件,如果文件不存在则创建,如果存在,则会覆盖原有的内容,文件的指针会放在文件的开头 a 以追加模式打开文件,如果文件不存在则创建,文件指针在文件开头,如果文件存在,则会在末尾追加内容,文件指针在源文件末尾 b 以魏晋至方式打开文件,不能单独使用,需要与其他模式一起使用,rb,或者wb + 以读写方式打开文件,不能单独使用,需要与其他模式一起使用,a+ 12345scr_file=open(&#x27;logo.png&#x27;,&#x27;rb&#x27;)target_file=open(&#x27;copylogo.png&#x27;,&#x27;wb&#x27;)target_file.write(src_file.read())target_file.close()src_file.close() 3.with12with open(&#x27;filename&#x27;,&#x27;rb&#x27;) as 别名: #with语句可以自动管理上下文资源,不论什么原因跳出with块,都能确保文件正确地关闭,以此来达到释放资源的目的 文件的复制: 123with open(&#x27;logo.png&#x27;,&#x27;rb&#x27;) as src_file: with open(&#x27;copy2logo.png&#x27;,&#x27;wb&#x27;) as target_file target_file.write(src_file.read()) 4.os模块 这个模块与操作系统有关 import os os.getcwd() 放回当前的工作目录 os.listdir(path) 返回指定路径下的文件和目录信息 os.mkdir(path[,mode]) 创建目录 os.makdirs(path1/path2….) 创建多级目录 os.rmdir(path) 删除目录 os.removedirs(path1/path2…) 删除多级目录 os.chdir(path) 将path设置为当前工作目录 5.os.path import os.path os.path.abspath(path) 用于获取文件或目录的绝对路径 os.path.exists(path) 用于判断文件或目录是否存在,如果存在返回true,否则返回False os.path.join(path,name) 将目录与目录或者文件名拼接起来 os.path.splittext() 分离文件名和扩展名 os.path.basename(path) 从一个目录中提取文件名 os.path.dirname(path) 从一个路径中提取文件路径,不包括文件名 os.path.isdir(path) 用于判断是否为路径 6.案例1.列出指定目录下的所有.py文件123456import ospath=os.getcwd()list=os.listdir(path)for filename in list: if filename.endswith(&#x27;.py&#x27;): print(filename) 2.walk() 遍历得出根目录下所有的文件,包括子文件 12345678import ospath=os.getcwd()list_files=os.walk(path)for dirpath,dirname,filename in list_files: for dir in dirname: print(os.path.join(dirpath,dir)) for file in filename: print(os.path.join(dirpath.file)) 十六:学生管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247filename=&#x27;student.txt&#x27;import osdef menum(): print(&#x27;------------------学生管理系统----------------------&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t1.录入学生信息&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t2.查找学生信息&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t3.删除学生信息&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t4.修改学生信息&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t5.排序学生信息&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t6.统计学生总人数&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t7.查看所有学生信息&#x27;) print(&#x27;\\t\\t\\t\\t\\t\\t0.退出&#x27;)def main(): while True: menum() num=int(input(&#x27;请输入相关的操作数字:&#x27;)) if num in [0,1,2,3,4,5,6,7]: if num==0: answer=input(&#x27;确定要推出吗 y/n&#x27;) if answer==&#x27;y&#x27; or answer==&#x27;Y&#x27;: print(&#x27;谢谢使用&#x27;) break else: continue elif num==1: insert() elif num==2: find() elif num==3: delete() elif num==4: modify() elif num==5: sort() elif num==6: total() elif num==7: showStudent()def insert(): studentList=[] while True: id=input(&#x27;请输入学生id:&#x27;) if not id: break name=input(&#x27;请输入名字:&#x27;) if not name: break try: englishScore=int(input(&#x27;请输入英语成绩:&#x27;)) pythonScore=int(input(&#x27;请输入python成绩:&#x27;)) javaScore=int(input(&#x27;请输入java成绩:&#x27;)) except: print(&#x27;输入的成绩不是整数类型,请从新输入&#x27;) continue #将录入的成绩加入文件 student=&#123;&#x27;id&#x27;:id,&#x27;name&#x27;:name,&#x27;englishScore&#x27;:englishScore,&#x27;pythonScore&#x27;:pythonScore,&#x27;javaScore&#x27;:javaScore&#125; studentList.append(student) answer=input(&#x27;是否继续写入y/n&#x27;) if answer==&#x27;y&#x27;: continue else: break save(studentList) print(&#x27;学生信息录入完毕&#x27;)def find(): studentQuery=[] while True: id1=&#x27;&#x27; name1=&#x27;&#x27; if os.path.exists(filename): num=input(&#x27;按照id查找输入1,按照name查找输入2&#x27;) if num==&#x27;1&#x27;: id1=input(&#x27;请输入要查找的id:&#x27;) elif num==&#x27;2&#x27;: name1=input(&#x27;请输入要查找的名字:&#x27;) else: print(&#x27;查询有误&#x27;) find() with open(filename,&#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as file: studentList=file.readlines() for item in studentList: d=dict(eval(item)) if id1!=&#x27;&#x27;: if id1==d[&#x27;id&#x27;]: studentQuery.append(d) elif name1!=&#x27;&#x27;: if name1==d[&#x27;name&#x27;]: studentQuery.append(d) #显示结果 show_student(studentQuery) #清空 studentQuery.clear() answer=input(&#x27;是否继续查询 y/n:&#x27;) if answer==&#x27;y&#x27;: continue else: breakdef show_student(list): if len(list)==0: print(&#x27;没有查到数据&#x27;) return #定义显示的格式 format_title=&#x27;&#123;:^6&#125;\\t&#123;:^12&#125;\\t&#123;:^8&#125;\\t&#123;:^10&#125;\\t&#123;:^10&#125;\\t&#123;:^8&#125;&#x27; print(format_title.format(&#x27;ID&#x27;,&#x27;姓名&#x27;,&#x27;英语成绩&#x27;,&#x27;python成绩&#x27;,&#x27;java成绩&#x27;,&#x27;总成绩&#x27;)) #定义现实的内容 format_data=&#x27;&#123;:^6&#125;\\t&#123;:^12&#125;\\t&#123;:^8&#125;\\t&#123;:^10&#125;\\t&#123;:^10&#125;\\t&#123;:^8&#125;&#x27; for item in list: print(format_data.format(item.get(&#x27;id&#x27;), item.get(&#x27;name&#x27;), item.get(&#x27;englishScore&#x27;), item.get(&#x27;pythonScore&#x27;), item.get(&#x27;javaScore&#x27;), int(item.get(&#x27;englishScore&#x27;))+int(item.get(&#x27;pythonScore&#x27;))+int(item.get(&#x27;javaScore&#x27;)) ))def save(list): try: student_txt=open(filename,&#x27;a&#x27;,encoding=&#x27;UTF-8&#x27;) #有就追加 except: student_txt=open(filename,&#x27;w&#x27;,encoding=&#x27;UTF-8&#x27;) #没有就创建 for item in list: student_txt.write(str(item)+&#x27;\\n&#x27;) student_txt.close()def delete(): while True: student_id=input(&#x27;请输入你要删除的学生id:&#x27;) if student_id!=&#x27;&#x27;: if os.path.exists(filename): with open(filename,&#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as rfile: student_list=rfile.readlines() else: student_list=[] flag=False if student_list: with open(filename,&#x27;w&#x27;,encoding=&#x27;UTF-8&#x27;) as wfile: d=&#123;&#125; for item in student_list: d=dict(eval(item)) #将字符串转为字典 if d[&#x27;id&#x27;]!=student_id: wfile.write(str(d)+&#x27;\\n&#x27;) else: flag=True if flag: print(f&#x27;id为&#123;student_id&#125;的学生已经被删除&#x27;) else: print(f&#x27;没有这个找到学号为&#123;student_id&#125;的学生&#x27;) else: print(&#x27;没有学生信息&#x27;) break showStudent() #删除学生后重新显示 answer=input(&#x27;是否继续删除:y/n:&#x27;) if answer==&#x27;y&#x27;: continue else: breakdef modify(): showStudent() if os.path.exists(filename): with open(filename,&#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as file: studtent_list=file.readlines() else: return sid=input(&#x27;请输入修改学生的id:&#x27;) with open(filename,&#x27;w&#x27;,encoding=&#x27;UTF-8&#x27;) as wfile: for item in studtent_list: d=dict(eval(item)) #将字符串转为字典 if d[&#x27;id&#x27;]==sid: print(&#x27;可以修改学生的信息&#x27;) while True: try: d[&#x27;name&#x27;]=input(&#x27;请输入修改后的名字&#x27;) d[&#x27;englishScore&#x27;]=int(input(&#x27;请输入英语成绩&#x27;)) d[&#x27;pythonScore&#x27;]=int(input(&#x27;请输入python成绩&#x27;)) d[&#x27;javaScore&#x27;]=int(input(&#x27;请输入java成绩&#x27;)) except: print(&#x27;输入的成绩有误&#x27;) else: break wfile.write(str(d)+&#x27;\\n&#x27;) print(&#x27;修改成功&#x27;) else: wfile.write(str(d)+&#x27;\\n&#x27;) answer=input(&#x27;是否继续修改y/n:&#x27;) if answer==&#x27;y&#x27;: modify()def sort(): showStudent() if os.path.exists(filename): with open(filename,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file: studentList=file.readlines() student_new=[] for item in studentList: d=dict(eval(item)) student_new.append(d) else: return order_asc=input(&#x27;升序请输入0,降序请输入1&#x27;) if order_asc==&#x27;0&#x27;: order_asc_bool=False elif order_asc==&#x27;1&#x27;: order_asc_bool=True else: print(&#x27;输入有误,请重新输入&#x27;) sort() mode=input(&#x27;请输入要进行的排序方式(1.按照英语成绩 2.按照python成绩 3.按照java成绩 0.按照总成绩)&#x27;) if mode==&#x27;1&#x27;: student_new.sort(key=lambda x: int(x[&#x27;englishScore&#x27;]),reverse=order_asc_bool) elif mode==&#x27;2&#x27;: student_new.sort(key=lambda x: int(x[&#x27;pythonScore&#x27;]),reverse=order_asc_bool) elif mode==&#x27;3&#x27;: student_new.sort(key=lambda x: int(x[&#x27;javaScore&#x27;]),reverse=order_asc_bool) elif mode==&#x27;0&#x27;: student_new.sort(key=lambda x: int(x[&#x27;englishScore&#x27;])+int(x[&#x27;pythonScore&#x27;])+int(x[&#x27;javaScore&#x27;]),reverse=order_asc_bool) else: print(&#x27;您输入的有误,请重新输入&#x27;) sort() show_student(student_new)def total(): if os.path.exists(filename): with open(filename,&#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as file: studentList= file.readlines() if studentList: print(f&#x27;共录入的学生人数是&#123;studentList.__len__()&#125;&#x27;) else: print(&#x27;没有数据&#x27;) else: print(&#x27;没有保存数据&#x27;)def showStudent(): student_list=[] if os.path.exists(filename): with open(filename,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file: student=file.readlines() for item in student: student_list.append(eval(item)) if student_list: show_student(student_list)if __name__ == &#x27;__main__&#x27;: main() 十七:正则表达式 操作符 说明 . 表示任何单个字符 [ ] 字符集,对单个字符给出取值范围 [abc]表示a,b,c, [a-z]表示a到z单个字符 [^] 非字符集,对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示ab,abc,abcc,abccc等 + 前一个字符1次或无限次扩展 abc+ 表示abc,abcc,abccc等 ? 前一个字符0次或1以扩展 abc? 表示ab,abc | 左右表达式任意一个 abc|def 表示abc ,def {m] 扩展前一个字符m次 ab{2]c 表示 abbc {m,n} 扩展前一个字符m至n次,(含n) ab{1,2}c 表示 abc, abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记,内部只能使用 | 操作符 (abc) 表示abc,(abc|def)表示abc,def \\d 数字,等价于[0-9] \\w 单词字符,等价于[A-Za-z0-9_] 十八:补充re1234567891011#建议在正则表达式中,被比较的字符串前面加上r,不用担心转义字符的问题a=r&quot;\\aads-\\&quot;print(a)#sub替换print(re.sub(&quot;a&quot;,&quot;A&quot;,&quot;abcdsaasd&quot;)) #找到a用A替换,在第三个字符串中查找&quot;A&quot;m=re.search(&quot;asd&quot;,&quot;Aasd&quot;) #前面的字符串是规则,后面的字符串是被校验的对象print(re.findall(&quot;[A-Z]&quot;,&quot;ASDsDSFA&quot;)) #[&#x27;A&#x27;, &#x27;S&#x27;, &#x27;D&#x27;, &#x27;D&#x27;, &#x27;S&#x27;, &#x27;F&#x27;, &#x27;A&#x27;],查询单个print(re.findall(&quot;[A-Z]+&quot;,&quot;ASDsDSFA&quot;)) #[&#x27;ASD&#x27;, &#x27;DSFA&#x27;],匹配多个","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"快捷键使用","slug":"使用技巧以及快捷键","date":"2020-10-15T13:40:48.450Z","updated":"2020-10-15T07:25:22.778Z","comments":true,"path":"2020/10/15/使用技巧以及快捷键/","link":"","permalink":"http://example.com/2020/10/15/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Ctrl+1 一阶标题 [TOC] ​ Ctrl+B 字体加粗 Ctrl+2 二阶标题 Ctrl+I 字体倾斜 Ctrl+3 三阶标题 Ctrl+U 下划线 Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部 Ctrl+5 五阶标题 Ctrl+End 返回Typora底部 Ctrl+6 六阶标题 Ctrl+T 创建表格 Ctrl+L 选中某句话 Ctrl+K 创建超链接 Ctrl+D 选中某个单词 Ctrl+F 搜索 Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换 Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片 Ctrl+Shift+M 公式块 Ctrl+Shift+Q 引用 注：一些实体符号需要在实体符号之前加”\\”才能够显示 ``` Ctrl 0Ctrl 4:普通文本,一级四级标题 一:你好Ctrl B : 加粗 Ctrl U: 下划线 shift Alt 5 :删除线 Shift Ctrl Tab键上面那个 daima Ctrl k : 超链接;还支持文章内锚点 Ctrl T : 表格,支持拖拽移动,网页端表格赋值转换 Shift Ctrl Q:引用 Shift Ctrl I: 图片 代码块 : ``` 脚注:^spring 二:大家好有序: 1.空格 大于加回车 无序: 123* 无序列表1+ 无序列表2-无序列表3 *或者+或者- 加上空格 多行无序列表 123* 多行无序列表TAB * 多行无序列表TAB TAB *多行无序列表 :emoji 1表情 你好吗 你好 (tab)士大夫士大夫是 士大夫 士大夫士大夫sds [ ] ==高亮== 这是一个代码区块```java/C 百度 图片: !+ 三个短横线 ====","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Vue复习补充","slug":"Vue复习补充","date":"2020-10-15T13:40:48.447Z","updated":"2020-10-15T07:23:58.502Z","comments":true,"path":"2020/10/15/Vue复习补充/","link":"","permalink":"http://example.com/2020/10/15/Vue%E5%A4%8D%E4%B9%A0%E8%A1%A5%E5%85%85/","excerpt":"","text":"一:前端表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入vuejs框架 --&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .hFontColor&#123; color: brown &#125; .hAlign&#123; text-align: center &#125; td&#123; text-align: center &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 模拟表结构： student id：编号 name：姓名 gender：性别 age：年龄 --&gt; &lt;!-- 基础建设： 搭建用来填写信息的文本框 搭建表格结构 搭建添加信息按钮，删除信息的按钮 搭建一些基础的样式 --&gt; &lt;!-- vuejs建设： data： 模型 对象集合，编号，姓名，性别，年龄 methods： 添加方法，删除方法 扩展：查询信息列表方法 --&gt; &lt;h3 :class=&quot;hstyle&quot;&gt;学生信息管理系统&lt;/h3&gt; &lt;hr width=&quot;100%&quot;&gt; &lt;br/&gt; &lt;!-- 搭建添加操作相关信息 --&gt; 编号：&lt;input type=&quot;text&quot; v-model=&quot;id&quot;/&gt;&amp;nbsp;&amp;nbsp;&lt;!-- A0001 --&gt; 姓名：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;&amp;nbsp;&amp;nbsp; 性别：&lt;input type=&quot;text&quot; v-model=&quot;gender&quot;/&gt;&amp;nbsp;&amp;nbsp; 年龄：&lt;input type=&quot;text&quot; v-model=&quot;age&quot;/&gt;&amp;nbsp;&amp;nbsp; &lt;input type=&quot;button&quot; value=&quot;保存学员&quot; @click=&quot;save&quot;/&gt; &lt;br/&gt; &lt;br/&gt; &lt;!-- 搭建表格元素 --&gt; &lt;table border=&quot;1&quot; width=&quot;100%&quot; align=&quot;center&quot; cellpadding=&quot;6px&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt;&lt;!-- 1,2,3,4,5.... --&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;!-- 为删除超链接提供入口 --&gt; &lt;/tr&gt; &lt;!-- 内容部分 读取模型sList中的数据 使用v-for的形式对sList做遍历--&gt; &lt;!-- 每一个s，就是每一个遍历出来的学生对象，将来在取得学生信息的时候，通过&#123;&#123;s.属性&#125;&#125;来取值 i变量是遍历出来元素的下标，从0开始做标记，在序号中，应该是以下标+1的方式开始标记（序号从1开始计数） --&gt; &lt;tr v-for=&quot;(s,i) in sList&quot;&gt; &lt;td&gt;&#123;&#123;i+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;s.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;s.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;s.gender&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;s.age&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;!-- 使用href=&quot;javascript:void(0)&quot;将超链接的href行为禁用掉，该超链接只能以绑定事件的形式来触发行为 与之前学习的click的prevent的用处是一样的 --&gt; &lt;!-- 根据编号执行删除操作 注意： 在方法中传递实参，不需要使用插值表达式 使用方式：del(s.id) 而不是：del(&#123;&#123;s.id&#125;&#125;) --&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;del(s.id)&quot;&gt;删除学员&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; sList : [ &#123;id:&quot;A0001&quot;,name:&quot;zs&quot;,gender:&quot;男&quot;,age:&quot;23&quot;&#125;, &#123;id:&quot;A0002&quot;,name:&quot;ls&quot;,gender:&quot;男&quot;,age:&quot;24&quot;&#125;, &#123;id:&quot;A0003&quot;,name:&quot;ww&quot;,gender:&quot;男&quot;,age:&quot;25&quot;&#125; ], id : &quot;&quot;, name : &quot;&quot;, gender : &quot;&quot;, age : &quot;&quot;, hstyle:&#123;hFontColor:true,hAlign:true&#125; &#125;, //methods:表示vuejs中对于绑定事件函数的定义，可以同时定义多个函数，多个函数之间使用逗号来进行分隔 methods:&#123; save()&#123; /* 通过在页面中对文本框进行信息的完善（对视图V进行数据的填充） 根据使用对于视图中值的绑定方式是v-model的方式，会实现双向数据绑定 通过对视图的数据的填充，同时也是对模型中数据的填充 在我们触发的save方法当中，取得模型中的值，就相当于是取得了在页面文本框填充的数据 将这些数据收集起来，形成一个对象，将该对象添加到我们的sList对象数据中就可以了 */ var s = &#123;id:this.id,name:this.name,gender:this.gender,age:this.age&#125;; this.sList.push(s); &#125;, del(id)&#123; //id:需要删除记录的id，根据id来进行删除 /* 遍历sList中所有的对象 从每一个对象中取得id信息，将每一个id与参数id进行比较 如果id值相等，证明我们找到了需要删除的记录 将该记录从sList中移除掉 */ for(var i=0;i&lt;this.sList.length;i++)&#123; //如果id值相等，证明我们找到了需要删除的记录 if(this.sList[i].id==id)&#123; //将该记录从sList中移除掉 this.sList.splice(i,1); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二:过滤器123456789过滤器是一个通过输入数据，能够及时对数据进行处理并返回一个数据结果的简单的函数。在实际项目开发中根据实际的需求，可以自己编写所需要的过滤器。过滤器经常用在数据所需的格式化时使用：例如字符串的格式化以及日期时间的格式化等等过滤器最大的作用就是体现其复用性，如果我们在前端处理的某些文本信息每一次都需要经过重复的特殊处理，那么我们一定是要编写一个过滤器来使用 1.全局过滤器的使用1234567全局过滤器指的是所有vm对象都能共享使用的过滤器。过滤器能够使用在两个地方：（mustache）插值表达式&#x2F;指令（bind属性）过滤器的语法：使用管道符 &quot;|&quot; 过滤器在插值表达式中的使用案例：将所有的字母变成大写案例：定义格式化时间的全局过滤器 过滤器在v-for中的使用 案例：将所有的商品进行打折（打8折，5折...） 以上的案例，我们都是使用在了插值表达式当中，除了使用在插值表 达式中之外，我们的过滤器还可以说使用在 bind 属性指令当中，该 形式没有插值表达式使用的广泛。可以连续使用多个过滤器 将小写字母变大写案例:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;!-- 使用过滤器语法: &#123;&#123;内容 | 过滤器&#125;&#125;--&gt; &lt;P&gt;&#123;&#123;str1 | ucase&#125;&#125;&lt;/P&gt; &lt;/div&gt; &lt;script&gt; //自定义全局过滤器 /* 语法:Vue.filter 参数1:为该过滤器命名 参数2:函数,指定过滤器的行为 函数参数:我们需要操作的数据 */ Vue.filter(&quot;ucase&quot;,function(value)&#123; //通过value的形参取得了需要操作的数据 //将值处理为大写字母 value = value.toUpperCase(); return value; &#125;) var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;str1&quot; : &quot;aaa&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变日期格式案例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;P&gt;&#123;&#123;currentTime | dateTimeManager&#125;&#125;&lt;/P&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&quot;dateTimeManager&quot;,function(dateTime)&#123; //取得日期时间的具体数值 //将年月日时分秒分别取出,格式化为2019-01-01 10-10-10 //2019-01-01 10-10-10 或者 2019-01-01 10:10:10 都是19位,char(19)的效率高 var y = dateTime.getFullYear(); var m = (dateTime.getMonth()+1+&quot;&quot;).toString().padStart(2,&quot;0&quot;); var d = dateTime.getDate().toString().padStart(2,&quot;0&quot;); var h = dateTime.getHours().toString().padStart(2,&quot;0&quot;); var mm = dateTime.getMinutes().toString().padStart(2,&quot;0&quot;); var s = dateTime.getSeconds().toString().padStart(2,&quot;0&quot;); //在ES5中,我们必须使用+(拼接符)的形式对字符串进行拼接 //return y+&quot;-&quot;+m+&quot;-&quot;+d; //在ES6中,仅仅使用反引号&quot;`&quot;来解决复杂的字符串操作 return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;-$&#123;mm&#125;-$&#123;s&#125;`; &#125;) var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;currentTime&quot; : new Date() &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打折:123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;f in fruitList&quot; :key=&quot;f.id&quot;&gt; &#123;&#123;f.name&#125;&#125;-----------&#123;&#123;f.price | disCount8&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&quot;disCount8&quot;,function(value)&#123; return parseInt(value)*0.8; &#125;) var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;fruitList&quot; : [ &#123;&quot;id&quot;:&quot;A0001&quot;,&quot;name&quot;:&quot;苹果&quot;,&quot;price&quot;:10&#125;, &#123;&quot;id&quot;:&quot;A0001&quot;,&quot;name&quot;:&quot;桃子&quot;,&quot;price&quot;:16&#125;, &#123;&quot;id&quot;:&quot;A0001&quot;,&quot;name&quot;:&quot;西瓜&quot;,&quot;price&quot;:20&#125; ] &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 连续使用多个过滤器:12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 连续使用多个管道符来连接多个过滤器 &#123;&#123;str1 | 过滤器1 | 过滤器2 | 过滤器3...&#125;&#125; --&gt; &lt;p&gt;&#123;&#123;str1 | filter1 | filter2&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&quot;filter1&quot;,function(value)&#123; return value.toUpperCase(); &#125;) Vue.filter(&quot;filter2&quot;,function(value)&#123; return value+&quot;123&quot;; &#125;) var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;str1&quot;:&quot;aaa&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.私有过滤器的使用1234567891011121314151617181920私有过滤器指的是在指定的vm对象中来定义过滤器，该过滤器只在 当前的vm对象中会发挥作用，其他的vm对象不能使用的。语法：在vm对象中指定过滤器相关的属性和属性值vmfilters:&#123;filter1filter2...&#125;如果全局过滤器和私有过滤器的命名是一样的，那么默认使用的是私有过滤器。系统在使用过滤器的时候，根据名称去找相应的过滤器，先找私有过滤器，如果没有私有的，则继续通过该名称寻找全局过滤器。这种方式也被称之为就近原则（优先使用的是范围窄的） 。过滤器的使用：可以同时使用多个过滤器，这多个过滤器在一起使用的时候，是具有信息传递性的。先处理排在前面的过滤器，得到结果传递到下一个过滤器中继续进行后续处理。 三:指令1.全局指令12345678910指令与属性相似，是对指定元素样式或行为的赋予。我们可以在实际项目开发中自定义一些我们所需的指令来有效的管理元素。在页面中自定义的全局指令，可以为每一个vm对象中的元素提供服务，只要vm中的标签引用了全局指令那么一定会即时生效，一般情 况下我们普遍做的都是自定义全局指令来管理元素。值得一提的是自定义指令需要经常搭配vuejs中的钩子函数来进行操 作。在我们学习完指令之后，将在下一个章节（对象的生命周期）对钩子函数进行详细的学习。自定义全局指令的语法：Vue.directive()案例：自定义一个全局指令让文本框自动获取焦点我们也可以通过参数为指令进行赋值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用自定义全局指定来操纵该元素的样式,让文本框中输入的信息改变颜色 --&gt; 请输入信息:&lt;input type=&quot;text&quot; v-dt1&gt; &lt;/div&gt; &lt;script&gt; //自定义全局指令 /* directive提供两个参数 参数1:关于指令的名称,在定义的时候前面不需要加&quot;v-&quot;前缀,但是使用的过程中一定要加上&quot;v-&quot;前缀 例如我们现在为自定义取的名字叫做dt1(不加v-),那么我们在将来的元素中使用的时候要用v-dt1(加上v-) 参数2:json对象,在这个对象身上,有一些指令相关的函数,这些函数可以在特定的阶段,执行相关的操作 */ Vue.directive(&quot;dt1&quot;,&#123; /* 以下定义了3个函数,这三个函数是与vuejs对象生命周期密切相关的函数 在每个函数中,第一个参数el(表示element),表示的是指令操作的元素 注意:每一个el对象,同时也是一个原生js对象(dom对象) 在未来的开发中: 使用bind函数来操作元素的样式(css) 使用inserted函数来操作元素的行为(js) */ //bind函数,每当指令函数绑定到该元素上的时候,会立即执行这个bind函数,该函数只执行一次 bind: function(el)&#123; //将指定元素的文本信息改变颜色 //执行结果:文本框中的信息变红 el.style.color=&quot;red&quot;; //页面加载完毕后,让指定的文本框自动获取焦点 /* 执行结果: 文本框并没有自动取得焦点 在元素刚绑定了指令的时候,还没有插入到dom中去,这时候调用focus方法一定是没有作用的 一个元素,只有插入dom之后,才能够触发dom相关的方法(例如使用focus方法获取焦点) */ //el.focus(); &#125;, //inserted函数:表示元素插入到dom中的时候,会执行该函数,该函数只会执行一次 inserted: function(el)&#123; //执行结果:文本框成功地自动获取到焦点 el.focus(); &#125;, //update函数,当vuejs中的函数更新的时候,会触发该函数,元素是可以随时更新的,所以该函数可以触发多次 update: function(el)&#123; //对于当前指令相关的测试,该函数暂时用不到 &#125; &#125;) var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;str1&quot;:&quot;aaa&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动态赋值:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用自定义全局指定来操纵该元素的样式,让文本框中输入的信息改变颜色 --&gt; 请输入信息:&lt;input type=&quot;text&quot; v-dt1=&gt;&quot;&#x27;green&#x27;&quot; &lt;/div&gt; &lt;script&gt; Vue.directive(&quot;dt1&quot;,&#123; //bind函数,每当指令函数绑定到该元素上的时候,会立即执行这个bind函数,该函数只执行一次 bind: function(el,binding)&#123; //执行结果:文本框中的信息会随着传递的参数值的变化而变化 el.style.color=binding.value; &#125; &#125;) var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;str1&quot;:&quot;aaa&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.私有指令123456私有指令是指定义在指定的vm对象中，只针对当前vm对象描述的 元素生效的指令。其他的vm对象中的元素，是不能够使用该指令的。 语法：vmdirectives:&#123; 指令1..指令2...&#125; 四:vue生命周期12345678910111213141516171819生命周期是指Vuejs对象从创建到销毁的全过程生命周期1：创建阶段1.newVue()： 执行代码 varvm&#x3D;newVue(&#123;&#125;),表示创建一个 Vue 对象 （实例） 。 2.Init（Events&amp;Lifecycle） :执行完以上代码后步入到对象初始化的前期 阶段，表示通过以上代码我们创建了Vuejs对象，此时，在新建的对 象身上，具备了一些生命周期相关的函数（生命周期的钩子函数）和 默认的事件，但是其他的相关的组件还没有被创建（data、methods、 filter等等都没有被创建出来）。执行Init（Events&amp;Lifecycle）之后，钩子函数都被创建出来，马上 调用生命周期函数beforeCreate，在该函数执行的时候，我们最常使 用的组件data和methods等，都还没有被创建出来。3.Init(injections&amp;reactivity):该阶段是对象初始化的后期阶段。执行 Init(injections&amp;reactivity)的方式是调用生命周期函数created。在该函 数中，data和methods都已经被初始化好了。 也就是说，如果要使用methods中的方法，或者是操作data中的 数据，最早可以在created方法中来进行操作。4.Init对象初始化阶段执行完毕后，通过对元素以及模板进行判断， 系统开始编辑模板，将Vue代码中的指令进行执行，然后在内存中生 成一个编辑好的模板字符串，最终将该模板字符串渲染为内存中的 DOM。但是此时集锦只是在内存中渲染好了模板，并没有将模板挂载到页面 中去。该阶段执行完毕后，执行beforeMount方法。5.Createvm：该阶段是将内存中编译好的模板，替换到浏览器的页面中。该阶段执行完毕后，执行mounted方法。只要执行完了mounted 方法，就表示整个Vue对象已经初始化完毕了，此时正式脱离创建阶 段进入到运行阶段。如果要通过某些插件操作页面上的DOM 节点， 最早是要在mounted中进行生命周期2：对象运行阶段6.VirtualDOM:该阶段会根据data中的最新数据，重新渲染出一份最 新的DOM树，当最新的内存DOM树被更新了之后，会把最新的DOM 树重新渲染到页面中去，这时候就完成了使用模型Model去渲染视图 View的过程。 该阶段的执行会使用到两个函数beforeUpdate和updated,这两个函数 会根据data数据的变化，可重复的执行多次。当beforeUpdate方法执行的时候，页面中的显示还是以前的数据，但 是data中保存的是更新后的新数据，页面此时还没有和最新的数据保持同步。 updated函数执行的时候，页面和data数据已经保持同步了，都是最 新的数据了。 生命周期3：对象销毁阶段7.Teardown（拆卸），该阶段为对象销毁的阶段，当对象实例运行完 毕后，如果达到了对象销毁的条件，执行beforDestroy函数，该函数 的执行正式标志着对象从运行阶段进入到了销毁的阶段。当beforDestroy函数执行的时候，对象身上所有的组件data、 methods、 filter、directive等组件都还处于可用状态（因为对象只是步入到了销 毁的阶段，还没有销毁） ，该函数执行完毕后，对象正式销毁。 8.Destroyed:该阶段为对象销毁后的阶段。该阶段会执行destroyed函 数，当该函数执行的时候，对象已经被销毁了，里面的data、methods 等相应的组件也不能使用了。 以上生命周期中使用的所有的函数，就是Vuejs生命周期中最重要的 钩子函数。 五:响应ajax使用vue-resource插件响应:1.get请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;mytitle&lt;/title&gt; &lt;!-- 导入vue-resource类库之后，就可以使用this.$http.xxx来实现ajax功能了 注意：对于idea，直接复制粘贴过来的文件有可能报404错误（资源定位不到的） 这时我们可以先手动创建这个文件，在复制粘贴里面的内容到该文件中就可以了 --&gt; &lt;script src=&quot;vue/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue/vue-resource-1.3.4.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;getStudent&quot;&gt;点击取得学生信息&lt;/button&gt; &lt;br/&gt; &lt;br/&gt; 编号：&lt;span&gt;&#123;&#123;id&#125;&#125;&lt;/span&gt;&lt;br/&gt; 姓名：&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br/&gt; 年龄：&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;id&quot; : &quot;&quot;, &quot;name&quot; : &quot;&quot;, &quot;age&quot; : &quot;&quot; &#125;, methods : &#123; getStudent()&#123; //发出ajax请求，取得学生信息，在页面中局部刷新学生信息 //this.$http.get(&quot;请求路径&quot;,请求参数，then(回调函数)) //对于参数的传递，get请求和post请求的参数传递的语法是不同的，这一点有别于其他的前端语言 //对于get请求，必须是在路径的后面以url?key1=value1&amp;key2=value2&amp;key3=value3这种传统的形式来传递参数 this.$http.get(&quot;myServlet01.do?name=zs123&quot;).then(function (data) &#123; //通过data.body的形式来拿到服务器返回成功的数据 //alert(data.body.id); //为页面填写值 /*this.id = data.body.id; this.name = data.body.name; this.age = data.body.age;*/ data = data.body; this.id = data.id; this.name = data.name; this.age = data.age; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.post请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;mytitle&lt;/title&gt; &lt;!-- 导入vue-resource类库之后，就可以使用this.$http.xxx来实现ajax功能了 注意：对于idea，直接复制粘贴过来的文件有可能报404错误（资源定位不到的） 这时我们可以先手动创建这个文件，在复制粘贴里面的内容到该文件中就可以了 --&gt; &lt;script src=&quot;vue/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue/vue-resource-1.3.4.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;getStudent&quot;&gt;点击取得学生信息&lt;/button&gt; &lt;br/&gt; &lt;br/&gt; 编号：&lt;span&gt;&#123;&#123;id&#125;&#125;&lt;/span&gt;&lt;br/&gt; 姓名：&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br/&gt; 年龄：&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;id&quot; : &quot;&quot;, &quot;name&quot; : &quot;&quot;, &quot;age&quot; : &quot;&quot; &#125;, methods : &#123; getStudent()&#123; //发出ajax请求，取得学生信息，在页面中局部刷新学生信息 //发出post请求 //post请求参数传递的方式，是以请求体的方式来传递的，所以不能将参数挂在url后面 /* 关于post请求传递参数的问题： 手动发起的post请求，默认没有表单格式，所以有些服务器就处理不了 我们需要通过post方法的第三个参数，&#123;emulateJSON:true&#125;设置，提交的内容类型就设置为了普通表单的格式传递参数 */ this.$http.post(&quot;myServlet02.do&quot;,&#123;&quot;name&quot;:&quot;ls123&quot;&#125;&#123;emulateJSON:true&#125;).then(function (data) &#123; //与get请求一样，我们接受到后台响应的信息，需要先使用data.body进行处理，才能够拿到我们需要的值 data = data.body; this.id = data.id; this.name = data.name; this.age = data.age; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六:响应axios使用axios插件响应: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;mytitle&lt;/title&gt; &lt;!-- 导入axios插件来实现ajax请求 --&gt; &lt;script src=&quot;vue/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;getStudent&quot;&gt;点击取得学生信息&lt;/button&gt; &lt;br/&gt; &lt;br/&gt; 编号：&lt;span&gt;&#123;&#123;id&#125;&#125;&lt;/span&gt;&lt;br/&gt; 姓名：&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br/&gt; 年龄：&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;id&quot; : &quot;&quot;, &quot;name&quot; : &quot;&quot;, &quot;age&quot; : &quot;&quot; &#125;, methods : &#123; getStudent()&#123;/* 在请求执行成功后，执行回调函数中的内容，回调函数处于其他函数的内部，this不会与任何的对象绑定（以this.data的形式引入数据就引不到了） 将指向vue对象的this赋值给外部方法定义的属性，然后在内部方法中使用该属性即可*/ /*var _this = this; axios(&#123; method : &quot;get&quot;, //请求方式 url : &quot;myServlet03.do&quot; //请求路径 &#125;).then(function (result) &#123; /!* 注意： 之前使用vue-resource插件 对于值的处理 返回值.body的操作 这次使用axios插件，同样需要对值进行处理 返回值.data的形式*!/ //alert(result.data.id); data = result.data; _this.id = data.id; _this.name = data.name; _this.age = data.age;&#125;)*/ axios(&#123; method : &quot;get&quot;, //请求方式 url : &quot;myServlet03.do?name=aaa&quot; //请求路径 //使用 箭头表达式=&gt; 在代替原有的function来做回调函数 &#125;).then(result=&gt; &#123; /* 注意： 之前使用vue-resource插件 对于值的处理 返回值.body的操作 这次使用axios插件，同样需要对值进行处理 返回值.data的形式 */ //alert(result.data.id); data = result.data; this.id = data.id; this.name = data.name; this.age = data.age; &#125;) //以param属性的形式来传递参数 axios(&#123; method : &quot;post&quot;, //请求方式 url : &quot;myServlet03.do&quot;, //请求路径 params : &#123;&quot;name&quot;:&quot;bbb&quot;&#125; //传递参数 //使用 箭头表达式=&gt; 在代替原有的function来做回调函数 &#125;).then(result=&gt; &#123;/* 注意： 之前使用vue-resource插件 对于值的处理 返回值.body的操作 这次使用axios插件，同样需要对值进行处理 返回值.data的形式*/ //alert(result.data.id); data = result.data; this.id = data.id; this.name = data.name; this.age = data.age; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 另外一种方式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;mytitle&lt;/title&gt; &lt;!-- 导入axios插件来实现ajax请求 --&gt; &lt;script src=&quot;vue/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;getStudent&quot;&gt;点击取得学生信息&lt;/button&gt; &lt;br/&gt; &lt;br/&gt; 编号：&lt;span&gt;&#123;&#123;id&#125;&#125;&lt;/span&gt;&lt;br/&gt; 姓名：&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br/&gt; 年龄：&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;id&quot; : &quot;&quot;, &quot;name&quot; : &quot;&quot;, &quot;age&quot; : &quot;&quot; &#125;, methods : &#123; getStudent()&#123; /*axios.get( &quot;myServlet04.do&quot;, //请求路径 &#123; params : &#123; &quot;name&quot; : &quot;aaabbb&quot; &#125; &#125; //请求参数 ).then(result=&gt;&#123; var data = result.data; this.id = data.id; this.name = data.name; this.age = data.age; &#125;)*/ axios.post( &quot;myServlet04.do&quot;, //请求路径 /*&#123; params : &#123; &quot;name&quot; : &quot;aaabbb&quot; &#125; &#125;*//* 该方式发送数据是一个 Request Payload的数据格式，一般的数据格式都是Form Data格式 所以我们之前写的以json形式的参数就发送不出去 只能通过传统字符串的方式为后台发送参数*/ &quot;name=aaabbbccc&quot; ).then(result=&gt;&#123; var data = result.data; this.id = data.id; this.name = data.name; this.age = data.age; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结 axios的形式是一个基于Promise的HTTP请求客户端，用来发 出请求。该形式也是 vue2.0官方推荐的形式，官方在推出了该形式 后，同时就不再对之前的vue-resource的形式进行更新和维护了。所 以更推荐的是使用axios的形式来处理ajax请求。 七:跨域请求 跨域请求的常用处理方式： （1）代理方式 代理用于将请求发送给后台服务器，通过服务器来发送请求，然 后将请求的结果传递给前端。通过nginx代理来实现操作。 优点：跨域服务稳定 缺点：在使用到跨域处理的时候，必须要事先搭建nginx服务的代理环境，比较麻烦 （2）CORS方式 CORS是w3c标准的方式，通过在web服务器端的设置 响应头 Access-Control-Alow-Origin 来指定哪些域可以访问本域的 数据。 优点：使用简单，支持基于HTTP协议的所有请求方式 缺点：跨域服务响应稍慢 （3）jsonp方式 通过动态插入一个script标签。浏览器对script的资源引用没有同 源限制，同时资源加载到页面后回立即执行。 优点：使用简单，跨域服务响应快，获取的数据是我们最常见的json 格式的数据。 缺点：只能发送get请求，无法发送post请求 由于在开发中发出跨域请求的目的通常是为了取得指定的资源数 据，所以一般都是发出get请求，由于jsonp的形式使用简单，而且 关于接收的响应数据，是程序员使用最多的 json 格式的数据，所以 该形式在 企业中应用的比较广泛。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;mytitle&lt;/title&gt; &lt;!-- 导入axios插件来实现ajax请求 --&gt; &lt;script src=&quot;vue/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;!-- 之前老师在讲解ajax的时候，最后总结时说道推荐使用axios的方式 但是，如果想要处理跨域请求，那么我们就必须要使用vue-resource的方式 --&gt; &lt;%--&lt;script src=&quot;vue/axios.min.js&quot;&gt;&lt;/script&gt;--%&gt; &lt;script src=&quot;vue/vue-resource-1.3.4.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;getStudent&quot;&gt;点击取得学生信息&lt;/button&gt; &lt;br/&gt; &lt;br/&gt; 编号：&lt;span&gt;&#123;&#123;id&#125;&#125;&lt;/span&gt;&lt;br/&gt; 姓名：&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br/&gt; 年龄：&lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;id&quot; : &quot;&quot;, &quot;name&quot; : &quot;&quot;, &quot;age&quot; : &quot;&quot; &#125;, methods : &#123; getStudent()&#123; /* 案例： 当前项目所在服务器为 协议：http 域名：localhost 端口号：8080 将请求发送到以下配置的服务器，来从跨域的服务器中接收数据 协议：http 域名：localhost 端口号：8088*/ //使用jsonp的方式发出跨域请求 this.$http.jsonp(&quot;http://localhost:8088/ky01/getKyStudentData.do&quot;).then(result=&gt;&#123; result = result.body; this.id = result.id; this.name = result.name; this.age = result.age; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八:vue动画 v-enter v-leave-to v-enter-active v-leave-active 动画的滑入滑出和淡入淡出:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;!-- 自定义两组Vuejs的样式，来控制transition内部的元素实现动画的效果 --&gt; &lt;style&gt; /* v-enter 这是一个时间点，是进入之前，元素的起始状态，此时还没有开始进入 v-leave-to 这时一个时间点 是动画离开之后，离开的终止状态，此时，元素动画已经结束了 */ .v-enter,.v-leave-to&#123; /*设置起始状态和结束状态团苏的透明度为0（表示隐藏元素）*/ opacity: 0; /*该形式为普通的淡入淡出的动画效果，使用起来最简单，应用的最广泛*/ /*transform: opacity*/ transform: translateY(150px);/*y横轴滑入*/ &#125; /* .v-enter-active 这是一个时间段，表示元素入场的过程 .v-leave-active 这是一个时间段，表示元素离场的过程 */ .v-enter-active,.v-leave-active&#123; /*设置在指定的事件内完成动画的全部入场和离场的效果*/ transition: all 1.8s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;br/&gt; &lt;br/&gt; &lt;!-- 对于以下p标签中的信息，我们需要使用动画进行控制 需要使用transition元素，将需要被动画控制的元素包裹起来，对于当前信息的展现，我们需要包裹的就是p标签 transition元素，Vue官方为我们提供的--&gt; &lt;transition&gt; &lt;p v-if=&quot;flag&quot;&gt;abcdef&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;flag&quot; : false &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 弹入弹出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;!-- 自定义两组Vuejs的样式，来控制transition内部的元素实现动画的效果 --&gt; &lt;style&gt; .v-enter-active&#123; /* 设置弹进时长 */ animation: bounce-in 3.5s; &#125; .v-leave-active&#123; /* 设置弹出的时长 正常的弹入弹出，都需要将reverse属性值加上 */ animation: bounce-in 3.5s reverse; &#125; /* 使用vue搭配css动画效果的实现 @keyframes：是CSS3定义的动画规则 bounce-in：表示弹入弹出的效果 */ @keyframes bounce-in&#123; 0%&#123; transform: scale(0); &#125; 50%&#123; transform: scale(1.5); &#125; 100%&#123; transform: scale(1); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;br/&gt; &lt;br/&gt;&lt;!--对于以下p标签中的信息，我们需要使用动画进行控制需要使用transition元素，将需要被动画控制的元素包裹起来，对于当前信息的展现，我们需要包裹的就是p标签 transition元素，Vue官方为我们提供的 --&gt; &lt;transition&gt; &lt;p v-if=&quot;flag&quot;&gt; abcdefasdfasdfassdfasd111111111111111111111111111111111111111111111&lt;br/&gt; abcdefasdfasdfassdfasd111111111111111111111111111111111111111111111&lt;br/&gt; abcdefasdfasdfassdfasd111111111111111111111111111111111111111111111 &lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;flag&quot; : false &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 加入第三方类库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/animate.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; @click=&quot;flag=!flag&quot;/&gt; &lt;br/&gt; &lt;br/&gt;&lt;!-- animate.css为我们提供了 enter-active-class和leave-active-class 用来操作元素进场和离场的效果以弹出弹出的形式处理进场和离场 animated bounceIn animated bounceOut--&gt;&lt;!--&lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot;&gt; &lt;p v-if=&quot;flag&quot;&gt;弹出的信息msg&lt;/p&gt;&lt;/transition&gt;--&gt;&lt;!-- 我们可以将class=&quot;animated&quot;写在元素中 这样在enter-active-class和leave-active-class中就不用重复写animated了 使用:duration=&quot;毫秒值&quot; 来统一设置入场和离场动画时长--&gt;&lt;!-- &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :duration=&quot;200&quot;&gt; &lt;p v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;弹出的信息msg123&lt;/p&gt; &lt;/transition&gt; --&gt; &lt;!-- 使用 :duration=&quot;&#123;enter:200,leave:400&#125;&quot; 来分别设置入场和离场的时长 --&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :duration=&quot;&#123;enter:200,leave:400&#125;&quot;&gt; &lt;p v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;弹出的信息msg123123&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;flag&quot; : false &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 加入小车动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .ball&#123; width: 15px; height: 15px; border-radius:50%; background-color: #FF0000 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot; style=&quot;height:170px&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;加入购物车&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!--以下@定义的属性，一会使用动画的钩子函数进行相应处理--&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;img src=&quot;./image/gwc.png&quot;/&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &quot;flag&quot; : false &#125;, methods:&#123;//注意：动画钩子函数也是具有参数的，一般都会有一个参数叫做el，这个el就是钩子函数的第一个参数//el表示的是要执行动画的那个DOM元素，是一个原生JS的DOM元素//大家也可以认为，el是通过document.getElementById(&#x27;&#x27;)的方式获取到的原生DOM对象 beforeEnter(el)&#123; //beforeEnter表示动画入场之前，此时，动画尚未开始，可以在beforeEnter中，设置元素开始动画之前的起始样式//el.style.transform设置小球开始动画之前的起始位置//translate(0,0)表示的是在坐标为0，0的位置 el.style.transform = &quot;translate(0,0)&quot; &#125;, enter(el,done)&#123; //这行代码，没有实际的作用，但是如果不写，就不会出现动画的效果 //可以认为，el.offsetWidth会强制启动动画 el.offsetWidth //enter表示动画开始之后的样式的设置，这里，可以设置小球完成动画之后的结束状态 el.style.transform = &quot;translate(150px,350px)&quot; el.style.transition = &#x27;all 1s ease&#x27; //这里的done，起始就是afterEnter这个函数，也就是说，done就是afterEnter函数的引用 done() &#125;,afterEnter(el)&#123; //在动画完成之后，会调用afterEnter this.flag = !this.flag &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 添加动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li&#123; border : 1px dashed #999; margin: 5px; line-height: 50px; padding-left: 8px; font-size: 2s2px; width: 80% &#125; li:hover&#123; background-color: hotpink; transition:all 0.8s ease; &#125; .v-enter, .v-leave-to&#123; opacity:0; transform: translateY(60px) &#125; .v-enter-active, .v-leave-active&#123; transition: all 0.6s ease; &#125;/* 下面的.v-move和.v-leave-active需要配合使用，能够实现列表后续的元素，渐渐的飘上来的这种效果 */ .v-move&#123; transition: all 0.6s ease; &#125; .v-leave-active&#123; position: absolute &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 定义文本框及按钮 --&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;/&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;/&gt; &lt;/div&gt; &lt;!--定义动画区域--&gt; &lt;!--ul--&gt;&lt;!-- 在我们实现列表过渡的时候，如果需要过渡的元素，是通过v-for循环渲染出来的， 则不能使用transition进行包裹，必须要使用transition-group来进行包裹 如果要为v-for循环创建的元素设置动画，必须为每一个元素设置 :key属性（必须是当前记录的id） 给transition添加appear属性 ，在页面刚展现出来的时候，实现入场时候的效果 通过为transition-group元素，设置tag属性，指定transition-group渲染为指定的元素 如果不指定tag属性，默认渲染为span元素--&gt; &lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item,i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!--ul--&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; id : &#x27;&#x27;, name : &#x27;&#x27;, list : [ &#123;id:1,name:&#x27;zs&#x27;&#125;, &#123;id:2,name:&#x27;ls&#x27;&#125;, &#123;id:3,name:&#x27;ww&#x27;&#125;, &#123;id:4,name:&#x27;zl&#x27;&#125;, &#123;id:5,name:&#x27;sq&#x27;&#125; ] &#125;, methods:&#123; add()&#123; //为列表添加对象 this.list.push(&#123;id:this.id,name:this.name&#125;) //将文本框中的数据清空掉 this.id = &#x27;&#x27;; this.name = &#x27;&#x27;; &#125;, del(i)&#123; //根据下标删除所在行 this.list.splice(i,1); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Vuejs","slug":"Vuejs","date":"2020-10-15T13:40:48.444Z","updated":"2020-10-15T07:25:16.065Z","comments":true,"path":"2020/10/15/Vuejs/","link":"","permalink":"http://example.com/2020/10/15/Vuejs/","excerpt":"","text":"一:Vue初体验12// let(变量)/const(常量)// 编程范式: 声明式编程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt; &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;&#x2F;h2&gt; &lt;!--&lt;button v-on:click&#x3D;&quot;counter++&quot;&gt;+&lt;&#x2F;button&gt;--&gt; &lt;!--&lt;button v-on:click&#x3D;&quot;counter--;&quot;&gt;-&lt;&#x2F;button&gt;--&gt; &lt;button v-on:click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt; &lt;button v-on:click&#x3D;&quot;sub&quot;&gt;-&lt;&#x2F;button&gt; &lt;!--下面是语法糖写法--&gt; &lt;!--&lt;button @click&#x3D;&quot;sub&quot;&gt;-&lt;&#x2F;button&gt;--&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; &#x2F;&#x2F; 语法糖: 简写 &#x2F;&#x2F; proxy const obj &#x3D; &#123; counter: 0, message: &#39;abc&#39; &#125; new Vue() const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: obj, methods: &#123; add: function () &#123; console.log(&#39;add被执行&#39;); this.counter++ &#125;, sub: function () &#123; console.log(&#39;sub被执行&#39;); this.counter-- &#125; &#125;, beforeCreate: function () &#123; &#125;, created: function () &#123; console.log(&#39;created&#39;); &#125;, mounted: function () &#123; console.log(&#39;mounted&#39;); &#125; &#125;) &#x2F;&#x2F; 1.拿button元素 &#x2F;&#x2F; 2.添加监听事件&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 1.创建options123456789101112131.el类型: string | HTMLElement作用:决定后Vue实例会管理哪一个DOM2.data类型:Object | Function(组件当中data必须是一个函数)作用: Vue实例对应的数据对象3.methods类型: &#123;[key:string]:function&#125;作用:定义属于Vue的一些方法,可以在其他地方调用,也可以在指令中使用4.生命周期函数 2.Vue.prototype 在main.js中,设置全局变量 123456789这种情况下，你可以通过在原型上定义它们使其在每个 Vue 的实例中可用Vue.prototype.$appName = &#x27;My App&#x27;这样 $appName 就在所有的 Vue 实例中可用了，甚至在实例被创建之前就可以。如果我们运行new Vue(&#123; beforeCreate: function () &#123; console.log(this.$appName) &#125;&#125;) 二:插值语法:1.==Mustache==:胡须/胡子123456789101112131415161718192021222324就是双大括号&#123;&#123;&#125;&#125;&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;, 李银河!&lt;/h2&gt; &lt;!--mustache语法中,不仅仅可以直接写变量,也可以写简单的表达式--&gt; &lt;h2&gt;&#123;&#123;firstName + lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;counter * 2&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, firstName: &#x27;kobe&#x27;, lastName: &#x27;bryant&#x27;, counter: 100 &#125;, &#125;)&lt;/script&gt; 2.v-once1234message改变后v-once修饰的数据显示不会改变 &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; 3.v-html123456789101112131415将vue中返回的标签显示&lt;div id=&quot;app&quot;&gt; &lt;h2 v-html=&quot;url&quot;&gt;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, url: &#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;&#x27; &#125; &#125;)&lt;/script&gt; 4.v-text12 &lt;h2 v-text=&quot;message&quot;&gt;, 李银河!&lt;/h2&gt;显示文本,不过不够灵活,不能拼接,会覆盖掉李银河 5.v-pre12原封不动地显示内容 &lt;h2 v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;//&#123;&#123;message&#125;&#125; 6.v-cloak123456789101112cloak:斗篷----&gt;如果数据加载延迟,这个属性可以不让message显示到页面,对用户不友好&lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; v-cloak&gt;//解析后后自动删除v-cloak &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt; 三:v-bind动态绑定1.v-bind 绑定基本属性1234567891011121314151617181920212223242526272829对dom对象的某些属性进行动态绑定作用: 动态绑定缩写: :&lt;div id=&quot;app&quot;&gt; &lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt; &lt;!--&lt;img src=&quot;&#123;&#123;imgURL&#125;&#125;&quot; alt=&quot;&quot;&gt;--&gt; &lt;!-- 正确的做法: 使用v-bind指令 --&gt; &lt;img v-bind:src=&quot;imgURL&quot; alt=&quot;&quot;&gt; &lt;a v-bind:href=&quot;aHref&quot;&gt;百度一下&lt;/a&gt; &lt;!--&lt;h2&gt;&#123;&#123;&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=&quot;imgURL&quot; alt=&quot;&quot;&gt; &lt;a :href=&quot;aHref&quot;&gt;百度一下&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, imgURL: &#x27;https://img11.360buyimg.com/mobilecms/s350x250_jfs/t1/20559/1/1424/73138/5c125595E3cbaa3c8/74fc2f84e53a9c23.jpg!q90!cc_350x250.webp&#x27;, aHref: &#x27;http://www.baidu.com&#x27; &#125; &#125;)&lt;/script&gt; 2.v-bind绑定class1&lt;h2 :class=&quot;&#123;key:value&#125;&quot;&gt;&lt;/h2&gt; 即 &lt;h2 :class=&quot;&#123;类名:boolean&#125;&quot;&gt;&lt;/h2&gt; 1234567891011121314用法一：直接通过&#123;&#125;绑定一个类&lt;h2 :class=&quot;&#123;&#x27;active&#x27;: isActive&#125;&quot;&gt;Hello World&lt;/h2&gt;用法二：也可以通过判断，传入多个值&lt;h2 :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;用法三：和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类&lt;h2 class=&quot;title&quot; :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt; 例子: 123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;!--&lt;h2 class=&quot;active&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;h2 :class=&quot;active&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;h2 v-bind:class=&quot;&#123;key1: value1, key2: value2&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;h2 v-bind:class=&quot;&#123;类名1: true, 类名2: boolean&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;h2 class=&quot;title&quot; v-bind:class=&quot;&#123;active: isActive, line: isLine&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 class=&quot;title&quot; v-bind:class=&quot;getClasses()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button v-on:click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isActive: true, isLine: true &#125;, methods: &#123; btnClick: function () &#123; this.isActive = !this.isActive &#125;, getClasses: function () &#123; return &#123;active: this.isActive, line: this.isLine&#125; &#125; &#125; &#125;)&lt;/script&gt; 3.v-bind动态绑定style12345678910绑定方式一：对象语法:style=&quot;&#123;color: currentColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;style后面跟的是一个对象类型对象的key是CSS属性名称对象的value是具体赋的值，值可以来自于data中的属性绑定方式二：数组语法&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;style后面跟的是一个数组类型多个值以，分割即可 12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;!--&lt;h2 :style=&quot;&#123;key(属性名): value(属性值)&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&#x27;50px&#x27;必须加上单引号, 否则是当做一个变量去解析--&gt; &lt;!--&lt;h2 :style=&quot;&#123;fontSize: &#x27;50px&#x27;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--finalSize当成一个变量使用--&gt; &lt;!--&lt;h2 :style=&quot;&#123;fontSize: finalSize&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt; &lt;h2 :style=&quot;&#123;fontSize: finalSize + &#x27;px&#x27;, backgroundColor: finalColor&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 :style=&quot;getStyles()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, finalSize: 100, finalColor: &#x27;red&#x27;, &#125;, methods: &#123; getStyles: function () &#123; return &#123;fontSize: this.finalSize + &#x27;px&#x27;, backgroundColor: this.finalColor&#125; &#125; &#125; &#125;)&lt;/script&gt; 四:==computed==计算属性12345678910111213141516171819202122232425262728293031323334我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示比如我们有firstName和lastName两个变量，我们需要显示完整的名称。但是如果多个地方都需要显示完整的名称，我们就需要写多个&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt; //计算属性 &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;//不用加()&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Lebron&#x27;, lastName: &#x27;James&#x27; &#125;, // computed: 计算属性(),一般起名字是名词属性 computed: &#123; fullName: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;, methods: &#123; getFullName() &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; &#125;)&lt;/script&gt; 1.计算属性的复杂操作:1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;总价格: &#123;&#123;totalPrice&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; books: [ &#123;id: 110, name: &#x27;Unix编程艺术&#x27;, price: 119&#125;, &#123;id: 111, name: &#x27;代码大全&#x27;, price: 105&#125;, &#123;id: 112, name: &#x27;深入理解计算机原理&#x27;, price: 98&#125;, &#123;id: 113, name: &#x27;现代操作系统&#x27;, price: 87&#125;, ] &#125;, computed: &#123; totalPrice: function () &#123; let result = 0 for (let i=0; i &lt; this.books.length; i++) &#123; result += this.books[i].price &#125; return result // for (let i in this.books) &#123; // this.books[i] // &#125; // // for (let book of this.books) &#123; // // &#125; &#125; &#125; &#125;)&lt;/script&gt; 2.计算属性的setter和getter方法123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Kobe&#x27;, lastName: &#x27;Bryant&#x27; &#125;, computed: &#123; // fullName: function () &#123; // return this.firstName + &#x27; &#x27; + this.lastName // &#125; // name: &#x27;coderwhy&#x27; // 计算属性一般是没有set方法, 只读属性,一般省略 fullName: &#123; set: function(newValue) &#123; // console.log(&#x27;-----&#x27;, newValue); const names = newValue.split(&#x27; &#x27;); this.firstName = names[0]; this.lastName = names[1]; &#125;, get: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;, //因为一般只用get方法,所以可以将fullName以如下方法写,即为属性,所以在调用fullName时不用加() // fullName: function () &#123; // return this.firstName + &#x27; &#x27; + this.lastName // &#125; &#125; &#125;)&lt;/script&gt; 3.对比computed和methods1计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。,所以一般使用computed 五:ES6补充123456// ES5中的var是没有块级作用域的(if/for)// ES6中的let是由块级作用的(if/for)// ES5之前因为if和for都没有块级作用域的概念, 所以在很多时候, 我们都必须借助于function的作用域来解决应用外面变量的问题.// ES6中,加入了let, let它是有if和for的块级作用域. 1234567第一种:错误的作用域----&gt;最后i一直为5const btns = document.getElementsByTagName(&#x27;button&#x27;) for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;第&#x27; + i + &#x27;个按钮被点击&#x27;); &#125;) &#125; 1234567891011第二种函数闭包; // 3.没有块级作用域引起的问题: for的块级 // 为什么闭包可以解决问题: 函数是一个作用域. // var btns = document.getElementsByTagName(&#x27;button&#x27;); // for (var i=0; i&lt;btns.length; i++) &#123; (function (num) &#123; // 0 btns[i].addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;第&#x27; + num + &#x27;个按钮被点击&#x27;); &#125;) &#125;)(i) &#125; 1234567第三种常用let:const btns = document.getElementsByTagName(&#x27;button&#x27;) for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;第&#x27; + i + &#x27;个按钮被点击&#x27;); &#125;) &#125; 1:const1234567891011121314151617181920212223&lt;script&gt; // 1.注意一: 一旦给const修饰的标识符被赋值之后, 不能修改 // const name = &#x27;why&#x27;; // name = &#x27;abc&#x27;; // 2.注意二: 在使用const定义标识符,必须进行赋值 // const name; // 3.注意三: 常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性. const obj = &#123; name: &#x27;why&#x27;, age: 18, height: 1.88 &#125; // obj = &#123;&#125; console.log(obj); obj.name = &#x27;kobe&#x27;; obj.age = 40; obj.height = 1.87; console.log(obj);&lt;/script&gt; 2.对象字面量增强写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script&gt; // const obj = new Object() // const obj = &#123; // name: &#x27;why&#x27;, // age: 18, // run: function () &#123; // console.log(&#x27;在奔跑&#x27;); // &#125;, // eat: function () &#123; // console.log(&#x27;在次东西&#x27;); // &#125; // &#125; // 1.属性的增强写法 const name = &#x27;why&#x27;; const age = 18; const height = 1.88 // ES5的写法 // const obj = &#123; // name: name, // age: age, // height: height // &#125; //ES6增强写法: const obj = &#123; name, age, height, &#125; console.log(obj); // 2.函数的增强写法 // ES5的写法 // const obj = &#123; // run: function () &#123; // // &#125;, // eat: function () &#123; // // &#125; // &#125; //ES6增强写法 const obj = &#123; run() &#123; &#125;, eat() &#123; &#125; &#125;&lt;/script&gt; 六:v-on监听事件1.基本使用123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;!--&lt;h2 v-bind:title&gt;&lt;/h2&gt;--&gt; &lt;!--&lt;h2 :title&gt;&lt;/h2&gt;--&gt; &lt;!--&lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt;--&gt; &lt;!--&lt;button v-on:click=&quot;counter--&quot;&gt;-&lt;/button&gt;--&gt; &lt;!--&lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt;--&gt; &lt;!--&lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt;--&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0 &#125;, methods: &#123; increment() &#123; this.counter++ &#125;, decrement() &#123; this.counter-- &#125; &#125; &#125;)&lt;/script&gt; 2.v-on的参数问题1.当通过methods中定义方法，以供@click调用时，需要注意参数问题： 2.情况一：如果该方法不需要额外参数，那么方法后的()可以==不添加==。 3.但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 4.情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=&quot;app&quot;&gt; &lt;!--1.事件调用的方法没有参数--&gt; &lt;button @click=&quot;btn1Click()&quot;&gt;按钮1&lt;/button&gt; &lt;button @click=&quot;btn1Click&quot;&gt;按钮1&lt;/button&gt; &lt;!--2.在事件定义时, 写方法时省略了小括号, 但是方法本身是需要一个参数的, 这个时候, Vue会默认将浏览器生产的event事件对象作为参数传入到方法--&gt; &lt;!--&lt;button @click=&quot;btn2Click(123)&quot;&gt;按钮2&lt;/button&gt;--&gt; &lt;!--&lt;button @click=&quot;btn2Click()&quot;&gt;按钮2&lt;/button&gt;--&gt; //undefined &lt;button @click=&quot;btn2Click&quot;&gt;按钮2&lt;/button&gt; &lt;!--3.方法定义时, 我们需要event对象, 同时又需要其他参数--&gt; &lt;!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event--&gt; &lt;button @click=&quot;btn3Click(abc, $event)&quot;&gt;按钮3&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, abc: 123 &#125;, methods: &#123; btn1Click() &#123; console.log(&quot;btn1Click&quot;); &#125;, btn2Click(event) &#123; console.log(&#x27;--------&#x27;, event); &#125;, btn3Click(abc, event) &#123; console.log(&#x27;++++++++&#x27;, abc, event); &#125; &#125; &#125;) // 如果函数需要参数,但是没有传入, 那么函数的形参为undefined // function abc(name) &#123; // console.log(name); // &#125; // // abc()&lt;/script&gt; 3.v-on的修饰符12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=&quot;app&quot;&gt; &lt;!--1. .stop修饰符的使用,如果不使用,点击按钮时,div也会触发--&gt; &lt;div @click=&quot;divClick&quot;&gt; aaaaaaa &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;!--2. .prevent修饰符的使用,阻止默认事件,比如默认提交--&gt; &lt;br&gt; &lt;form action=&quot;baidu&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&quot;submitClick&quot;&gt; &lt;/form&gt; &lt;!--3. .监听某个键盘的键帽,其中enter是监听回车键--&gt; &lt;input type=&quot;text&quot; @keyup.enter=&quot;keyUp&quot;&gt; &lt;!--4. .once修饰符的使用,使按钮只被点击一次--&gt; &lt;button @click.once=&quot;btn2Click&quot;&gt;按钮2&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, methods: &#123; btnClick() &#123; console.log(&quot;btnClick&quot;); &#125;, divClick() &#123; console.log(&quot;divClick&quot;); &#125;, submitClick() &#123; console.log(&#x27;submitClick&#x27;); &#125;, keyUp() &#123; console.log(&#x27;keyUp&#x27;); &#125;, btn2Click() &#123; console.log(&#x27;btn2Click&#x27;); &#125; &#125; &#125;)&lt;/script&gt; 七:条件判断1.v-if满足条件true才会显示,一般为bollean类型 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;isShow&quot;&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isShow: true &#125; &#125;)&lt;/script&gt; 2.v-if 和 v-else12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;isShow&quot;&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; &lt;h1 v-else&gt;isShow为false时, 显示我&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isShow: true &#125; &#125;)&lt;/script&gt; 3.v-if 和 v-else-if 和 v-else12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/h2&gt; &lt;h2 v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/h2&gt; &lt;h2 v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/h2&gt; &lt;h2 v-else&gt;不及格&lt;/h2&gt; &lt;h1&gt;&#123;&#123;result&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; score: 99 &#125;, //建议比较复杂的逻辑判断这样写 computed: &#123; result() &#123; let showMessage = &#x27;&#x27;; if (this.score &gt;= 90) &#123; showMessage = &#x27;优秀&#x27; &#125; else if (this.score &gt;= 80) &#123; showMessage = &#x27;良好&#x27; &#125; // ... return showMessage &#125; &#125; &#125;)&lt;/script&gt; 4.用户登录切换小问题： 如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。 但是按道理讲，我们应该切换到另外一个input元素中了。 在另一个input元素中，我们并没有输入内容。 为什么会出现这个问题呢？ 问题解答： 这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。 在上面的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用了。 解决方案： 如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key 并且我们需要保证key的不同 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;isUser&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt;&lt;!--for--&gt;当点击&quot;用户账号时可以显示文本框输入&quot;--&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户账号&quot; key=&quot;username&quot;&gt; &lt;!--其中key是一个标识,可以阻止文本框内容的复用,当切换时文本框内的文本会消失变成空白--&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&quot;email&quot;&gt; &lt;/span&gt; &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换类型&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isUser: true &#125; &#125;)&lt;/script&gt; 5.v-showv-show的用法和v-if非常相似，也用于决定一个元素是否渲染： v-if和 v-show 对比 v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？ v-if当条件为false时，压根不会有对应的元素在DOM中。 v-show当条件为false时，仅仅是将元素的display属性设置为none而已。 开发中如何选择呢？ 当需要在显示与隐藏之间切片很频繁时，使用v-show 当只有一次切换时，通过使用v-if 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;!--v-if: 当条件为false时, 包含v-if指令的元素, 根本就不会存在dom中--&gt; &lt;h2 v-if=&quot;isShow&quot; id=&quot;aaa&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--v-show: 当条件为false时, v-show只是给我们的元素添加一个行内样式: display: none--&gt; &lt;h2 v-show=&quot;isShow&quot; id=&quot;bbb&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isShow: true &#125; &#125;)&lt;/script&gt; 八:循环遍历1.v-for遍历数组1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;!--1.在遍历的过程中,没有使用索引值(下标值)--&gt; &lt;ul&gt; &lt;li v-for=&quot;item in names&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--2.在遍历的过程中, 获取索引值--&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in names&quot;&gt; &#123;&#123;index+1&#125;&#125;.&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; names: [&#x27;why&#x27;, &#x27;kobe&#x27;, &#x27;james&#x27;, &#x27;curry&#x27;] &#125; &#125;)&lt;/script&gt; 2.v-for遍历对象1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;!--1.在遍历对象的过程中, 如果只是获取一个值, 那么获取到的是value--&gt; &lt;ul&gt; &lt;li v-for=&quot;item in info&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--2.获取key和value 格式: (value, key) --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in info&quot;&gt;&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--3.获取key和value和index 格式: (value, key, index) --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key, index) in info&quot;&gt;&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; info: &#123; name: &#x27;why&#x27;, age: 18, height: 1.88 &#125; &#125; &#125;)&lt;/script&gt; 3.v-for添加key1.官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。 2.key的作用主要是为了高效的更新虚拟DOM 3.我们希望可以在B和C之间加一个F,添加key会提高效率 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in letters&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; letters: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;] &#125; &#125;)&lt;/script&gt; 4.数组的方法响应式1.因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。 2.Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。 push() pop() shift() unshift() splice() sort() reverse() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in letters&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;, methods: &#123; btnClick() &#123; // 1.push方法 // this.letters.push(&#x27;aaa&#x27;) // this.letters.push(&#x27;aaaa&#x27;, &#x27;bbbb&#x27;, &#x27;cccc&#x27;) // 2.pop(): 删除数组中的最后一个元素 // this.letters.pop(); // 3.shift(): 删除数组中的第一个元素 // this.letters.shift(); // 4.unshift(): 在数组最前面添加元素 // this.letters.unshift() // this.letters.unshift(&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;) // 5.splice作用: 删除元素/插入元素/替换元素 // 删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素) // 替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素 // 插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素 // splice(start):start表示从第几个元素开始 // splice(start): this.letters.splice(1, 3, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;x&#x27;) // this.letters.splice(1, 0, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;) // 5.sort() 用来排序 // this.letters.sort() // 6.reverse() 反转,即显示顺序反过来 // this.letters.reverse() // 注意: 通过索引值修改数组中的元素,这种不是响应式的,即改变数据不能在html页面显示改变 // this.letters[0] = &#x27;bbbbbb&#x27;;---&gt;这种是无效的,vue不支持,用下标方式不能改数据 // this.letters.splice(0, 1, &#x27;bbbbbb&#x27;) // set(要修改的对象, 索引值, 修改后的值) // Vue.set(this.letters, 0, &#x27;bbbbbb&#x27;) &#125; &#125; &#125;) 5.作业展示点中哪个就会变成红色,即改变样式: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in movies&quot; :class=&quot;&#123;active: currentIndex === index&#125;&quot; @click=&quot;liClick(index)&quot;&gt; &#123;&#123;index&#125;&#125;.&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;!--&lt;li :class=&quot;&#123;active: 0===currentIndex&#125;&quot;&gt;&lt;/li&gt;--&gt; &lt;!--&lt;li :class=&quot;&#123;active: 1===currentIndex&#125;&quot;&gt;&lt;/li&gt;--&gt; &lt;!--&lt;li :class=&quot;&#123;active: 2===currentIndex&#125;&quot;&gt;&lt;/li&gt;--&gt; &lt;!--&lt;li :class=&quot;&#123;active: 3===currentIndex&#125;&quot;&gt;&lt;/li&gt;--&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; movies: [&#x27;海王&#x27;, &#x27;海贼王&#x27;, &#x27;加勒比海盗&#x27;, &#x27;海尔兄弟&#x27;], currentIndex: 0 /*记录下标,以后比较常用*/ &#125;, methods: &#123; liClick(index) &#123; this.currentIndex = index &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.书籍购物车**知识点补充:**toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字： var num = 5.56789;var n=num.toFixed(2); n 输出结果:5.57 index.html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;books.length&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;出版日期&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item, index) in books&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.date&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.price | showPrice&#125;&#125;&lt;/td&gt;&lt;!--过滤器--&gt; &lt;td&gt; &lt;button @click=&quot;decrement(index)&quot; v-bind:disabled=&quot;item.count &lt;= 1&quot;&gt;-&lt;/button&gt; &#123;&#123;item.count&#125;&#125; &lt;button @click=&quot;increment(index)&quot;&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt;&lt;button @click=&quot;removeHandle(index)&quot;&gt;移除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h2&gt;总价格: &#123;&#123;totalPrice | showPrice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;h2 v-else&gt;购物车为空&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; books: [ &#123; id: 1, name: &#x27;《算法导论》&#x27;, date: &#x27;2006-9&#x27;, price: 85.00, count: 1 &#125;, &#123; id: 2, name: &#x27;《UNIX编程艺术》&#x27;, date: &#x27;2006-2&#x27;, price: 59.00, count: 1 &#125;, &#123; id: 3, name: &#x27;《编程珠玑》&#x27;, date: &#x27;2008-10&#x27;, price: 39.00, count: 1 &#125;, &#123; id: 4, name: &#x27;《代码大全》&#x27;, date: &#x27;2006-3&#x27;, price: 128.00, count: 1 &#125;, ] &#125;, methods: &#123; // getFinalPrice(price) &#123; // return &#x27;¥&#x27; + price.toFixed(2) // &#125; increment(index) &#123; this.books[index].count++ &#125;, decrement(index) &#123; this.books[index].count-- &#125;, removeHandle(index) &#123; this.books.splice(index, 1) &#125; &#125;, computed: &#123; totalPrice() &#123; // 1.普通的for循环 // let totalPrice = 0 // for (let i = 0; i &lt; this.books.length; i++) &#123; // totalPrice += this.books[i].price * this.books[i].count // &#125; // return totalPrice // 2.for (let i in this.books) // let totalPrice = 0 // for (let i in this.books) &#123; // const book = this.books[i] // totalPrice += book.price * book.count // &#125; // // return totalPrice // 3.for (let i of this.books) // let totalPrice = 0 // for (let item of this.books) &#123; // totalPrice += item.price * item.count // &#125; // return totalPrice return this.books.reduce(function (preValue, book) &#123; return preValue + book.price * book.count &#125;, 0) &#125;, filters: &#123; showPrice(price) &#123; return &#x27;¥&#x27; + price.toFixed(2) &#125; &#125;&#125;) style.css: 1234567891011121314151617table &#123; border: 1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0;&#125;th, td &#123; padding: 8px 16px; border: 1px solid #e9e9e9; text-align: left;&#125;th &#123; background-color: #f7f7f7; color: #5c6b77; font-weight: 600;&#125; 7.filter12345678910filter中的回调函数有一个要求,必须返回一个boolean值true: 当返回true时,函数内部会自动将这次回调的n加入到新的数组当中false: 当返回false时,函数内部会过滤掉这次的n//filter函数的调用//10,20,30,40,50 let newNums = nums.filter(function (n)&#123; return n&lt;100 &#125;) console.log(newNums); 8.map123456//map函数的调用//20,40,80,100let new2Nums = newNums.map(function (n)&#123; return n*2&#125;) console.log(new2Nums); 9.reduce12345678910//reduce作用对数组中所有的内容进行汇总let total = new2Nums.reduce(function(preValue,n)&#123; return preValue + n&#125;,0)console.log(total);//第一次: preValue 0 n 20//第二次: preValue 20 n 40//第三次: preValue 80 n 80//第四次: preValue 140 n 100 例子: 123456789计算数组的和const nums = [10,20,11,222,444,52] let total = nums.filter(function (n)&#123; return n&lt;100 &#125;).map(function (n)&#123; return n*2 &#125;).reduce(function (preValue,n)&#123; return preValue +n &#125;,0) 更加简化的箭头函数: 1let total = nums.filter(n =&gt; n&lt;100).map(n =&gt; n*2).reduce((pre,n) =&gt; pre+n) 计算上个购物车例子的总价钱: 123return this.books.reduce(function (preValue,book)&#123; return preValue + book.price *book.count&#125;,0) 九:v-model双向 .Vue中使用v-model指令来实现表单元素和数据的双向绑定。 案例分析: 当我们在输入框输入内容时 因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。 当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM 会发生响应的改变。 v-model原理 v-model其实是一个语法糖，它的背后本质上是包含两个操作： v-bind绑定一个value属性 v-on指令给当前元素绑定input事件 也就是说下面的代码：等同于下面的代码: &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; 等同于 &lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot; v-on:input=&quot;message = $event.target.value&quot;&gt; 123456789101112131415161718## 1.v-model基本使用&#96;&#96;&#96;js&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt; &#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; message: &#39;你好啊&#39; &#125; &#125;)&lt;&#x2F;script&gt; 2.v-model和radio 这样双向绑定后可以把得到的数据通过浏览器发送过去,从而保存在数据库 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;label for=&quot;male&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男 &lt;/label&gt; &lt;label for=&quot;female&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女 &lt;/label&gt; &lt;h2&gt;您选择的性别是: &#123;&#123;sex&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, sex: &#x27;女&#x27; &#125; &#125;)&lt;/script&gt; 3.v-model和checkbox12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!--1.checkbox单选框--&gt; &lt;!--&lt;label for=&quot;agree&quot;&gt;--&gt; &lt;!--&lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; v-model=&quot;isAgree&quot;&gt;同意协议--&gt; &lt;!--&lt;/label&gt;--&gt; &lt;!--&lt;h2&gt;您选择的是: &#123;&#123;isAgree&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;button :disabled=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt;--&gt;这个是---&gt;当点击同意的checkbox后才能点击按钮 &lt;!--2.checkbox多选框--&gt; &lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球 &lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球 &lt;input type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot;&gt;足球 &lt;input type=&quot;checkbox&quot; value=&quot;乒乓球&quot; v-model=&quot;hobbies&quot;&gt;乒乓球 &lt;input type=&quot;checkbox&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot;&gt;羽毛球 &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt; &lt;label v-for=&quot;item in originHobbies&quot; :for=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot; :value=&quot;item&quot; :id=&quot;item&quot; v-model=&quot;hobbies&quot;&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isAgree: false, // 单选框--&gt;boolean hobbies: [], // 多选框---&gt;数组 originHobbies: [&#x27;篮球&#x27;, &#x27;足球&#x27;, &#x27;乒乓球&#x27;, &#x27;羽毛球&#x27;, &#x27;台球&#x27;, &#x27;高尔夫球&#x27;] &#125; &#125;)&lt;/script&gt; 4.v-model和select12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;!--1.选择一个--&gt; &lt;select name=&quot;abc&quot; v-model=&quot;fruit&quot;&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;您选择的水果是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt; &lt;!--2.选择多个--&gt; &lt;select name=&quot;abc&quot; v-model=&quot;fruits&quot; multiple&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;您选择的水果是: &#123;&#123;fruits&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, fruit: &#x27;香蕉&#x27;, fruits: [] &#125; &#125;)&lt;/script&gt; 5.值绑定 但是真实开发中，这些input的值可能是从网络获取或定义在data中的。 所以我们可以通过v-bind:value动态的给value绑定值。 12345678910111213141516&lt;label v-for=&quot;item in originHobbies&quot; :for=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot; :value=&quot;item&quot; :id=&quot;item&quot; v-model=&quot;hobbies&quot;&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isAgree: false, // 单选框 hobbies: [], // 多选框, originHobbies: [&#x27;篮球&#x27;, &#x27;足球&#x27;, &#x27;乒乓球&#x27;, &#x27;羽毛球&#x27;, &#x27;台球&#x27;, &#x27;高尔夫球&#x27;] &#125; &#125;)&lt;/script&gt; 6.修饰符 lazy修饰符： 默认情况下，v-model默认是在input事件中同步输入框的数据的 也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变 lazy修饰符可以让数据在失去焦点或者回车时才会更新： number修饰符： 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。 number修饰符可以让在输入框中输入的内容自动转成数字类型 trim修饰符： 如果输入的内容首尾有很多空格，通常我们希望将其去除 trim修饰符可以过滤内容左右两边的空格 123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;!--1.修饰符: lazy--&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--2.修饰符: number--&gt; &lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt; &lt;h2&gt;&#123;&#123;age&#125;&#125;-&#123;&#123;typeof age&#125;&#125;&lt;/h2&gt; &lt;!--3.修饰符: trim--&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;name&quot;&gt; &lt;h2&gt;您输入的名字:&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, age: 0, name: &#x27;&#x27; &#125; &#125;) var age = 0 age = &#x27;1111&#x27; age = &#x27;222&#x27;&lt;/script&gt; 十:组件化开发 步骤: 创建组件构造器 注册组件 使用组件。 1.组件化基本使用 Vue.extend() 调用Vue.extend()创建的是一个组件构造器 通常在创建组件构造器时，传入template代表我们自定义组件的模板。 该模板就是在使用到组件的地方，要显示的HTML代码 Vue.component() 调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称 p所以需要传递两个参数：1、注册组件的标签名 2、组件构造器 组件必须挂载在某个Vue实例下，否则它不会生效 使用了三次 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;!--3.使用组件--&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;div&gt; &lt;div&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建组件构造器对象 //Tab上面的``可以支持换行 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt; &lt;/div&gt;` &#125;) // 2.注册组件 Vue.component(&#x27;my-cpn&#x27;, cpnC)//两个参数(对外的别名,创建的对象) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;)&lt;/script&gt; 2.全局组件和局部组件123456789101112131415全局组件: 注册组件(全局组件, 意味着可以在多个Vue的实例下面使用) Vue.component(&#x27;cpn&#x27;, cpnC)局部组件:const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; // cpn使用组件时的标签名 cpn: cpnC &#125; &#125;) 3.父组件和子组件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;cpn2&gt;&lt;/cpn2&gt; &lt;!--&lt;cpn1&gt;&lt;/cpn1&gt;--&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建第一个组件构造器(子组件) const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.创建第二个组件构造器(父组件) const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt; `, components: &#123; cpn1: cpnC1 &#125; &#125;) // root组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn2: cpnC2 &#125; &#125;)&lt;/script&gt; 4.组件的语法糖 在上面注册组件的方式，可能会有些繁琐 Vue为了简化这个过程，提供了注册的语法糖。 主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。 123456789101112131415161718192021222324252627282930313233343536373839div id=&quot;app&quot;&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;cpn2&gt;&lt;/cpn2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.全局组件注册的语法糖 // 1.创建组件构造器 // const cpn1 = Vue.extend() // 2.注册组件 Vue.component(&#x27;cpn1&#x27;, &#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.注册局部组件的语法糖 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; &#x27;cpn2&#x27;: &#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容, 呵呵呵&lt;/p&gt; &lt;/div&gt; ` &#125; &#125; &#125;)&lt;/script&gt; 5.组件模板分离12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--1.script标签, 注意:类型必须是text/x-template--&gt;&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;&lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容,哈哈哈&lt;/p&gt;&lt;/div&gt;&lt;/script&gt;&lt;!--2.template标签--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容,呵呵呵&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.注册一个全局组件 Vue.component(&#x27;cpn&#x27;, &#123; template: &#x27;#cpn&#x27; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;)&lt;/script&gt; 6.组件中的数据存放问题 组件对象也有一个data属性(也可以有methods等属性，下面我们有用到) 只是这个data属性必须是一个函数 而且这个函数返回一个对象，对象内部保存着数据 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--1.script标签, 注意:类型必须是text/x-template--&gt;&lt;!--&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;--&gt;&lt;!--&lt;div&gt;--&gt; &lt;!--&lt;h2&gt;我是标题&lt;/h2&gt;--&gt; &lt;!--&lt;p&gt;我是内容,哈哈哈&lt;/p&gt;--&gt;&lt;!--&lt;/div&gt;--&gt;&lt;!--&lt;/script&gt;--&gt;&lt;!--2.template标签--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;p&gt;我是内容,呵呵呵&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.注册一个全局组件 Vue.component(&#x27;cpn&#x27;, &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; title: &#x27;abc&#x27; &#125; &#125; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, // title: &#x27;我是标题&#x27; &#125; &#125;)&lt;/script&gt; 7.data为什么是函数 为什么data在组件中必须是一个函数呢? 首先，如果不是一个函数，Vue直接就会报错。 其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!--组件实例对象--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.注册组件 //这样一个改变会引起别的一起改变 //const obj = &#123; // counter: 0 //&#125; //这样改变不会引起别的改变 Vue.component(&#x27;cpn&#x27;, &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; counter: 0 &#125; &#125;, // data() &#123; // return obj //&#125;, methods: &#123; increment() &#123; this.counter++ &#125;, decrement() &#123; this.counter-- &#125; &#125; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;)&lt;/script&gt; 8.父组件向子组件传递数据 在组件中，使用选项props来声明需要从父级接收到的数据。 props的值有两种方式 方式一：字符串数组，数组中的字符串就是传递时的名称。 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;app&quot;&gt; &lt;!--&lt;cpn v-bind:cmovies=&quot;movies&quot;&gt;&lt;/cpn&gt;--&gt; &lt;!--&lt;cpn cmovies=&quot;movies&quot; cmessage=&quot;message&quot;&gt;&lt;/cpn&gt;--&gt; &lt;cpn :cmessage=&quot;message&quot; :cmovies=&quot;movies&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in cmovies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 父传子: props const cpn = &#123; template: &#x27;#cpn&#x27;, // props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;], props: &#123; // 1.类型限制 // cmovies: Array, // cmessage: String, // 2.提供一些默认值, 以及必传值 cmessage: &#123; type: String, default: &#x27;aaaaaaaa&#x27;, required: true &#125;, // 类型是对象或者数组时, 默认值必须是一个函数 cmovies: &#123; type: Array, default() &#123; return [] &#125; &#125; &#125;, data() &#123; return &#123;&#125; &#125;, methods: &#123; &#125; &#125; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, movies: [&#x27;海王&#x27;, &#x27;海贼王&#x27;, &#x27;海尔兄弟&#x27;] &#125;, components: &#123; cpn &#125; &#125;)&lt;/script&gt; 9.父传子(props中的驼峰标识) 尽量不要用驼峰标识 用驼峰标识的时候需要在绑定的时候加上 “-小写” 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=&quot;app&quot;&gt; &lt;cpn :c-info=&quot;info&quot; :child-my-message=&quot;message&quot; v-bind:class&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;cInfo&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;childMyMessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const cpn = &#123; template: &#x27;#cpn&#x27;, props: &#123; cInfo: &#123; type: Object, default() &#123; return &#123;&#125; &#125; &#125;, childMyMessage: &#123; type: String, default: &#x27;&#x27; &#125; &#125; &#125; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; info: &#123; name: &#x27;why&#x27;, age: 18, height: 1.88 &#125;, message: &#x27;aaaaaa&#x27; &#125;, components: &#123; cpn &#125; &#125;)&lt;/script&gt; 10.子传父(自定义事件) 自定义事件的流程 在子组件中，通过$emit()来触发事件。 在父组件中，通过v-on来监听子组件事件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!--父组件模板--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn @item-click=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--子组件模板--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;button v-for=&quot;item in categories&quot; @click=&quot;btnClick(item)&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.子组件 const cpn = &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; categories: [ &#123;id: &#x27;aaa&#x27;, name: &#x27;热门推荐&#x27;&#125;, &#123;id: &#x27;bbb&#x27;, name: &#x27;手机数码&#x27;&#125;, &#123;id: &#x27;ccc&#x27;, name: &#x27;家用家电&#x27;&#125;, &#123;id: &#x27;ddd&#x27;, name: &#x27;电脑办公&#x27;&#125;, ] &#125; &#125;, methods: &#123; btnClick(item) &#123; // 发射事件: 自定义事件 this.$emit(&#x27;item-click&#x27;, item)//(自定义的事件名字,传出的值) &#125; &#125; &#125; // 2.父组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn &#125;, methods: &#123; cpnClick(item) &#123; console.log(&#x27;cpnClick&#x27;, item); &#125; &#125; &#125;)&lt;/script&gt; 11.父访问子-children-refs 有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。 父组件访问子组件：使用$children或$refs reference(引用),pthis.$children是一个数组类型，它包含所有子组件对象。 子组件访问父组件：使用$parent(常用) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;y-cpn&gt;&lt;/y-cpn&gt; &lt;cpn ref=&quot;aaa&quot;&gt;&lt;/cpn&gt; &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt;我是子组件&lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, methods: &#123; btnClick() &#123; // 1.$children // console.log(this.$children); // for (let c of this.$children) &#123; // console.log(c.name); // c.showMessage(); // &#125; // console.log(this.$children[3].name); // 2.$refs =&gt; 对象类型, 默认是一个空的对象 ref=&#x27;bbb&#x27; console.log(this.$refs.aaa.name); &#125; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; name: &#x27;我是子组件的name&#x27; &#125; &#125;, methods: &#123; showMessage() &#123; console.log(&#x27;showMessage&#x27;); &#125; &#125; &#125;, &#125; &#125;)&lt;/script&gt; 12.子访父-parent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是cpn组件&lt;/h2&gt; &lt;ccpn&gt;&lt;/ccpn&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;ccpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是子组件&lt;/h2&gt; &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; name: &#x27;我是cpn组件的name&#x27; &#125; &#125;, components: &#123; ccpn: &#123; template: &#x27;#ccpn&#x27;, methods: &#123; btnClick() &#123; // 1.访问父组件$parent // console.log(this.$parent); // console.log(this.$parent.name); // 2.访问根组件$root console.log(this.$root); console.log(this.$root.message); &#125; &#125; &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 十一:组件化高级1.slot插槽基本使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--1.插槽的基本使用 &lt;slot&gt;&lt;/slot&gt;2.插槽的默认值 &lt;slot&gt;button&lt;/slot&gt;3.如果有多个值, 同时放入到组件进行替换时, 一起作为替换元素--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;i&gt;呵呵呵&lt;/i&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;i&gt;呵呵呵&lt;/i&gt; &lt;div&gt;我是div元素&lt;/div&gt; &lt;p&gt;我是p元素&lt;/p&gt; &lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是组件&lt;/h2&gt; &lt;p&gt;我是组件, 哈哈哈&lt;/p&gt; &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt; &lt;!--&lt;button&gt;按钮&lt;/button&gt;--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27; &#125; &#125; &#125;)&lt;/script&gt; 2.具名插槽 即替换具体的一个插槽标签内容,区分替换的哪个插槽 非常简单，只要给slot元素一个name属性即可 12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;span slot=&quot;center&quot;&gt;标题&lt;/span&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;button slot=&quot;left&quot;&gt;返回&lt;/button&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt; &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt; &lt;slot name=&quot;right&quot;&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27; &#125; &#125; &#125;)&lt;/script&gt; 3.编译作用域 官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;cpn v-show=&quot;isShow&quot;&gt;&lt;/cpn&gt; &lt;cpn v-for=&quot;item in names&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是子组件&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈&lt;/p&gt; &lt;button v-show=&quot;isShow&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isShow: true &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; isShow: false &#125; &#125; &#125;, &#125; &#125;)&lt;/script&gt; 4.作用域插槽案例 需求: 父组件获得子组建的数据,但是不以子组件的模板展示,而是以父组件新的模板展示子组件的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;!--目的是获取子组件中的pLanguages--&gt; &lt;template slot-scope=&quot;slot&quot;&gt; &lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt; - &#123;&#123;item&#125;&#125;&lt;/span&gt;--&gt; &lt;span&gt;&#123;&#123;slot.data.join(&#x27; - &#x27;)&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;!--目的是获取子组件中的pLanguages--&gt; &lt;template slot-scope=&quot;slot&quot;&gt; &lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; * &lt;/span&gt;--&gt; &lt;span&gt;&#123;&#123;slot.data.join(&#x27; * &#x27;)&#125;&#125;&lt;/span&gt; &lt;!--join是使数据以这样的方式连接--&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;!--&lt;cpn&gt;&lt;/cpn&gt;--&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot :data=&quot;pLanguages&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in pLanguages&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; pLanguages: [&#x27;JavaScript&#x27;, &#x27;C++&#x27;, &#x27;Java&#x27;, &#x27;C#&#x27;, &#x27;Python&#x27;, &#x27;Go&#x27;, &#x27;Swift&#x27;] &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 5.导入和导出 某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名 这个时候就可以使用export default export default在同一个模块中，不允许同时存在多个。 import使用 首先，我们需要在HTML代码中引入两个js文件，并且类型需要设置为module 如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦： 通过*可以导入模块中所有的export变量 但是通常情况下我们需要给*起一个别名，方便后续的使用 导出: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var name = &#x27;小明&#x27;var age = 18var flag = truefunction sum(num1, num2) &#123; return num1 + num2&#125;if (flag) &#123; console.log(sum(20, 30));&#125;// 1.导出方式一:export &#123; flag, sum&#125;// 2.导出方式二:export var num1 = 1000;export var height = 1.88// 3.导出函数/类export function mul(num1, num2) &#123; return num1 * num2&#125;export class Person &#123; run() &#123; console.log(&#x27;在奔跑&#x27;); &#125;&#125;// 5.export default// const address = &#x27;北京市&#x27;// export &#123;// address// &#125;// export const address = &#x27;北京市&#x27;// const address = &#x27;北京市&#x27;//// export default addressexport default function (argument) &#123; console.log(argument);&#125; 导入: 1234567891011121314151617181920212223242526272829303132333435// 1.导入的&#123;&#125;中定义的变量import &#123;flag, sum&#125; from &quot;./aaa.js&quot;;if (flag) &#123; console.log(&#x27;小明是天才, 哈哈哈&#x27;); console.log(sum(20, 30));&#125;// 2.直接导入export定义的变量import &#123;num1, height&#125; from &quot;./aaa.js&quot;;console.log(num1);console.log(height);// 3.导入 export的function/classimport &#123;mul, Person&#125; from &quot;./aaa.js&quot;;console.log(mul(30, 50));const p = new Person();p.run()// 4.导入 export default中的内容import addr from &quot;./aaa.js&quot;;addr(&#x27;你好啊&#x27;);// 5.统一全部导入// import &#123;flag, num, num1, height, Person, mul, sum&#125; from &quot;./aaa.js&quot;;import * as aaa from &#x27;./aaa.js&#x27;console.log(aaa.flag);console.log(aaa.height); 十二:箭头函数1.箭头函数的基本使用1234567891011121314151617181920212223&lt;script&gt; // 箭头函数: 也是一种定义函数的方式 // 1.定义函数的方式: function const aaa = function () &#123; &#125; // 2.对象字面量中定义函数 const obj = &#123; bbb() &#123; &#125; &#125; // 3.ES6中的箭头函数 // const ccc = (参数列表) =&gt; &#123; // // &#125; const ccc = () =&gt; &#123; &#125;&lt;/script&gt; 2.箭头函数参数和返回值123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; // 1.参数问题: // 1.1.放入两个参数 const sum = (num1, num2) =&gt; &#123; return num1 + num2 &#125; // 1.2.放入一个参数 const power = num =&gt; &#123; return num * num &#125; // 2.函数中 // 2.1.函数代码块中有多行代码时 const test = () =&gt; &#123; // 1.打印Hello World console.log(&#x27;Hello World&#x27;); // 2.打印Hello Vuejs console.log(&#x27;Hello Vuejs&#x27;); &#125; // 2.2.函数代码块中只有一行代码 // const mul = (num1, num2) =&gt; &#123; // return num1 + num2 // &#125; const mul = (num1, num2) =&gt; num1 * num2 console.log(mul(20, 30)); // const demo = () =&gt; &#123; // console.log(&#x27;Hello Demo&#x27;); // &#125; const demo = () =&gt; console.log(&#x27;Hello Demo&#x27;) console.log(demo());//undifined&lt;/script&gt; 3.箭头函数中的this1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; // 什么时候使用箭头 // setTimeout(function () &#123; // console.log(this); // &#125;, 1000) // // setTimeout(() =&gt; &#123; // console.log(this); // &#125;, 1000) // 问题: 箭头函数中的this是如何查找的了? // 答案: 向外层作用域中, 一层层查找this, 直到有this的定义. // const obj = &#123; // aaa() &#123; // setTimeout(function () &#123; // console.log(this); // window // &#125;) // // setTimeout(() =&gt; &#123; // console.log(this); // obj对象 // &#125;) // &#125; // &#125; // // obj.aaa() const obj = &#123; aaa() &#123; setTimeout(function () &#123; setTimeout(function () &#123; console.log(this); // window &#125;) setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;) setTimeout(() =&gt; &#123; setTimeout(function () &#123; console.log(this); // window &#125;) setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125;) &#125; &#125; obj.aaa()&lt;/script&gt; 十三:router路由1.vue-router概念 vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用 我们可以访问其官方网站对其进行学习: https://router.vuejs.org/zh/ 路由用于设定访问路径, 将路径和组件映射起来. 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换 2.vue-router步骤 第一步: 创建路由组件 第二步: 配置路由映射: 组件和路径映射关系 第三步: 使用路由: 通过和 components文件夹: about.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是关于&lt;&#x2F;h2&gt; &lt;p&gt;我是关于内容, 呵呵呵&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &quot;About&quot; &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt; Home.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是首页&lt;&#x2F;h2&gt; &lt;p&gt;我是首页内容, 哈哈哈&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &quot;Home&quot; &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt; index.js 123456789101112131415161718192021222324252627282930313233343536// 配置路由相关的信息import VueRouter from &#x27;vue-router&#x27;import Vue from &#x27;vue&#x27;import Home from &#x27;../components/Home&#x27;import About from &#x27;../components/About&#x27;// 1.通过Vue.use(插件), 安装插件Vue.use(VueRouter)// 2.创建VueRouter对象const routes = [ &#123; //默认路径 path: &#x27;&#x27;, // redirect重定向 redirect: &#x27;/home&#x27; &#125;, &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, component: About &#125;]const router = new VueRouter(&#123; // 配置路由和组件之间的应用关系 routes, mode: &#x27;history&#x27;,//默认是hash模式,这里变成history模式 linkActiveClass: &#x27;active&#x27;//统一active-class样式&#125;)// 3.将router对象传入到Vue实例export default router 显示App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h2&gt;我是APP组件&lt;&#x2F;h2&gt; &lt;!--&lt;router-link to&#x3D;&quot;&#x2F;home&quot; tag&#x3D;&quot;button&quot; replace active-class&#x3D;&quot;active&quot;&gt;首页&lt;&#x2F;router-link&gt;--&gt; &lt;!--&lt;router-link to&#x3D;&quot;&#x2F;about&quot; tag&#x3D;&quot;button&quot; replace active-class&#x3D;&quot;active&quot;&gt;关于&lt;&#x2F;router-link&gt;--&gt; &lt;!--&lt;router-link to&#x3D;&quot;&#x2F;home&quot; tag&#x3D;&quot;button&quot; replace&gt;首页&lt;&#x2F;router-link&gt;--&gt; &lt;!--&lt;router-link to&#x3D;&quot;&#x2F;about&quot; tag&#x3D;&quot;button&quot; replace&gt;关于&lt;&#x2F;router-link&gt;--&gt; &lt;button @click&#x3D;&quot;homeClick&quot;&gt;首页&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;aboutClick&quot;&gt;关于&lt;&#x2F;button&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, methods: &#123; homeClick() &#123; &#x2F;&#x2F; 通过代码的方式修改路由 vue-router &#x2F;&#x2F; push &#x3D;&gt; pushState &#x2F;&#x2F; this.$router.push(&#39;&#x2F;home&#39;) this.$router.replace(&#39;&#x2F;home&#39;) console.log(&#39;homeClick&#39;); &#125;, aboutClick() &#123; &#x2F;&#x2F; this.$router.push(&#39;&#x2F;about&#39;) this.$router.replace(&#39;&#x2F;about&#39;) console.log(&#39;aboutClick&#39;); &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt; &#x2F;*.router-link-active &#123;*&#x2F; &#x2F;*color: #f00;*&#x2F; &#x2F;*&#125;*&#x2F; .active &#123; color: #f00; &#125;&lt;&#x2F;style&gt; 3.默认路由 我们在routes中又配置了一个映射 path配置的是根路径: / redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了. 12345&#123; path: &#39;&#x2F;&#39;, &#x2F;&#x2F; redirect重定向 redirect: &#39;&#x2F;home&#39; &#125;, 4.history模式1234567const router &#x3D; new VueRouter(&#123; &#x2F;&#x2F; 配置路由和组件之间的应用关系 routes, mode: &#39;history&#39;, linkActiveClass: &#39;active&#39;&#125;) 5.router-link补充 中, 我们只是使用了一个属性: to, 用于指定跳转的路径. &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt; 123456789+ &lt;router-link&gt;还有一些**其他属性**: + tag: tag可以指定&lt;router-link&gt;之后渲染成什么组件, 比如上面的代码会被渲染成一个&lt;li&gt;元素, 而不是&lt;a&gt; + replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中 + &#96;&#96;&#96; &lt;!--&lt;router-link to&#x3D;&quot;&#x2F;home&quot; tag&#x3D;&quot;button&quot; replace&gt;首页&lt;&#x2F;router-link&gt;--&gt; + active-class: 当&lt;router-link&gt;对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称 + ``` &lt;!--&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;--&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## 6.动态路由+ 在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径： + &#x2F;user&#x2F;aaaa或&#x2F;user&#x2F;bbbb + 除了有前面的&#x2F;user之外，后面还跟上了用户的ID + 这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。![image-20200711165655300](C:\\Users\\12070\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200711165655300.png)![image-20200711165708132](C:\\Users\\12070\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200711165708132.png)![image-20200711165718488](C:\\Users\\12070\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200711165718488.png)## 7.懒加载+ 当打包构建应用时，Javascript 包会变得非常大，影响页面加载。+ 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了+ 路由懒加载做了什么? + 路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块. + 只有在这个路由被访问到的时候, 才加载对应的组件+ **懒加载的方式**: + const Home &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;Home.vue&#39;)## 8.路由嵌套&#96;&#96;&#96;vue&#123; path: &#39;&#x2F;home&#39;, component: Home, meta: &#123; title: &#39;首页&#39; &#125;, children: [ &#x2F;&#x2F; &#123; &#x2F;&#x2F; path: &#39;&#39;, &#x2F;&#x2F; redirect: &#39;news&#39; &#x2F;&#x2F; &#125;, &#123; path: &#39;news&#39;, component: HomeNews &#125;, &#123; path: &#39;message&#39;, component: HomeMessage &#125; ] &#125; 9.参数传递 传递参数主要有两种类型: params和query params的类型: 配置路由格式: /router/:id 传递的方式: 在path后面跟上对应的值 传递后形成的路径: /router/123, /router/abc query的类型: 配置路由格式: /router, 也就是普通配置 传递的方式: 对象中使用query的key作为传递方式 传递后形成的路径: /router?id=123, /router?id=abc 获取参数: 123&lt;h2&gt;&#123;&#123;$route.query.name&#125;&#125;&lt;&#x2F;h2&gt;&lt;h2&gt;&#123;&#123;$route.query.age&#125;&#125;&lt;&#x2F;h2&gt;&lt;h2&gt;&#123;&#123;$route.query.height&#125;&#125;&lt;&#x2F;h2&gt; 10.导航守卫 什么是导航守卫? vue-router提供的导航守卫主要用来监听监听路由的进入和离开的. vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发 我们可以利用beforeEach来完成标题的修改 1234567891011121314// 前置守卫(guard)router.beforeEach((to, from, next) =&gt; &#123; // 从from跳转到to document.title = to.matched[0].meta.title // console.log(to); // console.log(&#x27;++++&#x27;); next()&#125;)// 后置钩子(hook)router.afterEach((to, from) =&gt; &#123; // console.log(&#x27;----&#x27;);&#125;) 11.keep-alive keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 它们有两个非常重要的属性: include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存： 1234&lt;!-- 路由匹配到的组件将显示在这里 --&gt; &lt;keep-alive &gt; &lt;router-view/&gt; &lt;/keep-alive&gt; 123456789// 这两个函数, 只有该组件被保持了状态使用了keep-alive时, 才是有效的//页面activated活跃时,页面不活跃deactivated时 activated() &#123; this.$router.push(this.path); console.log(&#x27;activated&#x27;); &#125;, deactivated() &#123; console.log(&#x27;deactivated&#x27;); &#125;, 十四:promise Promise到底是做什么的呢？ Promise是异步编程的一种解决方案 1.promise的基本使用123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // 1.使用setTimeout // setTimeout(() =&gt; &#123; // console.log(&#x27;Hello World&#x27;); // &#125;, 1000) // 什么情况下会用到Promise? // 一般情况下是有异步操作时,使用Promise对这个异步操作进行封装 // new -&gt; 构造函数(1.保存了一些状态信息 2.执行传入的函数) // 在执行传入的回调函数时, 会传入两个参数, resolve, reject.本身又是函数 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 成功的时候调用resolve // resolve(&#x27;Hello World&#x27;) // 失败的时候调用reject reject(&#x27;error message&#x27;) &#125;, 1000) &#125;).then((data) =&gt; &#123; // 1.100行的处理代码 console.log(data); console.log(data); console.log(data); console.log(data); console.log(data); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.promise另外处理形式12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;Hello Vuejs&#x27;) reject(&#x27;error message&#x27;) &#125;, 1000) &#125;).then(data =&gt; &#123; console.log(data); &#125;, err =&gt; &#123; console.log(err); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.promise链式调用简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // 请求一: let isResult1 = false let isResult2 = false $ajax(&#123; url: &#x27;&#x27;, success: function () &#123; console.log(&#x27;结果1&#x27;); isResult1 = true handleResult() &#125; &#125;) // 请求二: $ajax(&#123; url: &#x27;&#x27;, success: function () &#123; console.log(&#x27;结果2&#x27;); isResult2 = true handleResult() &#125; &#125;) function handleResult() &#123; if (isResult1 &amp;&amp; isResult2) &#123; // &#125; &#125; // wrapped into // 网络请求: aaa -&gt; 自己处理(10行) // 处理: aaa111 -&gt; 自己处理(10行) // 处理: aaa111222 -&gt; 自己处理 // new Promise((resolve, reject) =&gt; &#123; // setTimeout(() =&gt; &#123; // resolve(&#x27;aaa&#x27;) // &#125;, 1000) // &#125;).then(res =&gt; &#123; // // 1.自己处理10行代码 // console.log(res, &#x27;第一层的10行处理代码&#x27;); // // // 2.对结果进行第一次处理 // return new Promise((resolve, reject) =&gt; &#123; // // resolve(res + &#x27;111&#x27;) // reject(&#x27;err&#x27;) // &#125;) // &#125;).then(res =&gt; &#123; // console.log(res, &#x27;第二层的10行处理代码&#x27;); // // return new Promise(resolve =&gt; &#123; // resolve(res + &#x27;222&#x27;) // &#125;) // &#125;).then(res =&gt; &#123; // console.log(res, &#x27;第三层的10行处理代码&#x27;); // &#125;).catch(err =&gt; &#123; // console.log(err); // &#125;) // new Promise(resolve =&gt; resolve(结果))简写 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return Promise.resolve(res + &#x27;111&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return Promise.resolve(res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第三层的10行处理代码&#x27;); &#125;) // 省略掉Promise.resolve new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return res + &#x27;111&#x27; &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return res + &#x27;222&#x27; &#125;).then(res =&gt; &#123; console.log(res, &#x27;第三层的10行处理代码&#x27;); &#125;) new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 // return Promise.reject(&#x27;error message&#x27;) throw &#x27;error message&#x27; &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return Promise.resolve(res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第三层的10行处理代码&#x27;); &#125;).catch(err =&gt; &#123; console.log(err); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SSM知识点集合","slug":"SSM知识点集合","date":"2020-10-15T13:40:48.441Z","updated":"2020-10-15T07:25:09.974Z","comments":true,"path":"2020/10/15/SSM知识点集合/","link":"","permalink":"http://example.com/2020/10/15/SSM%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E5%90%88/","excerpt":"","text":"1.spring整合mybatis1234567891011121314151617181920步骤：1.新建maven项目2.加入maven的依赖 1）spring依赖 2）mybatis依赖 3）mysql驱动 4）spring的事务的依赖 5）mybatis和spring集成的依赖： mybatis官方体用的，用来在spring项目中创建mybatis 的SqlSesissonFactory，dao对象的3.创建实体类4.创建dao接口和mapper文件5.创建mybatis主配置文件6.创建Service接口和实现类，属性是dao。7.创建spring的配置文件：声明mybatis的对象交给spring创建 1）数据源DataSource 2）SqlSessionFactory 3) Dao对象 4）声明自定义的service8.创建测试类，获取Service对象，通过service调用dao完成数据库的访问 applicationContext.xml: spring和mybatis整合在一起使用，事务是自动提交的。 无需执行SqlSession.commit(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容 spring知道jdbc.properties文件的位置 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!--声明数据源DataSource, 作用是连接数据库的--&gt; &lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt; &lt;!-- 使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;&lt;!--setUrl()--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.passwd&#125;&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.max&#125;&quot; /&gt; &lt;/bean&gt; &lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的 SqlSessionFactory sqlSessionFactory = new .. --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--set注入，把数据库连接池付给了dataSource属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt; &lt;!--mybatis主配置文件的位置 configLocation属性是Resource类型，读取配置文件 它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt; &lt;/bean&gt; &lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class） MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--指定SqlSessionFactory对象的id--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;!--指定包名， 包名是dao接口所在的包名。 MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行 一次getMapper()方法，得到每个接口的dao对象。 创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.bjpowernode.dao&quot;/&gt; &lt;/bean&gt; &lt;!--声明service--&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.bjpowernode.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot; /&gt; &lt;/bean&gt; &lt;!--这里需要在StudentServiceImpl的studentDao设置set方法,方便赋值--&gt;&lt;/beans&gt; 使用: 1234String config=&quot;applicationContext.xml&quot;; ApplicationContext ctx = new ClassPathXmlApplicationContext(config); //获取spring容器中的dao对象 StudentService service = (StudentService) ctx.getBean(&quot;studentService&quot;); 1.spring事务:12345678910111213141516171819202122使用@Transactional的步骤： 1.需要声明事务管理器对象 &lt;bean id=&quot;xx&quot; class=&quot;DataSourceTransactionManager&quot;&gt; 2.开启事务注解驱动， 告诉spring框架，我要使用注解的方式管理事务。 spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。 spring给业务方法加入事务： 在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知 @Around(&quot;你要增加的事务功能的业务方法名称&quot;) Object myAround()&#123; 开启事务，spring给你开启 try&#123; buy(1001,10); spring的事务管理器.commit(); &#125;catch(Exception e)&#123; spring的事务管理器.rollback(); &#125; &#125; 3.在你的方法的上面加入@Trancational ==注意==: transaction-manager:事务管理器的id 第二部开启事务注解驱动中,下面代码选择的类是: http://www.springframework.org/schema/tx 1&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; &#x2F;&gt; 使用: 12345678910111213141516171819202122/** * * rollbackFor:表示发生指定的异常一定回滚. * 处理逻辑是： * 1) spring框架会首先检查方法抛出的异常是不是在rollbackFor的属性值中 * 如果异常在rollbackFor列表中，不管是什么类型的异常，一定回滚。 * 2) 如果你的抛出的异常不在rollbackFor列表中，spring会判断异常是不是RuntimeException, * 如果是一定回滚。 * */ /* @Transactional( propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false, rollbackFor = &#123; NullPointerException.class, NotEnoughException.class &#125; )*/ //使用的是事务控制的默认值， 默认的传播行为是REQUIRED，默认的隔离级别DEFAULT //默认抛出运行时异常，回滚事务。 @Transactional 2.AspectJ事务注意:tx:advice这里也需要用末尾是tx的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容 spring知道jdbc.properties文件的位置 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!--声明数据源DataSource, 作用是连接数据库的--&gt; &lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt; &lt;!-- 使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;&lt;!--setUrl()--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.passwd&#125;&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.max&#125;&quot; /&gt; &lt;/bean&gt; &lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的 SqlSessionFactory sqlSessionFactory = new .. --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--set注入，把数据库连接池付给了dataSource属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt; &lt;!--mybatis主配置文件的位置 configLocation属性是Resource类型，读取配置文件 它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt; &lt;/bean&gt; &lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class） MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--指定SqlSessionFactory对象的id--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;!--指定包名， 包名是dao接口所在的包名。 MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行 一次getMapper()方法，得到每个接口的dao对象。 创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.bjpowernode.dao&quot;/&gt; &lt;/bean&gt; &lt;!--声明service--&gt; &lt;bean id=&quot;buyService&quot; class=&quot;com.bjpowernode.service.impl.BuyGoodsServiceImpl&quot;&gt; &lt;property name=&quot;goodsDao&quot; ref=&quot;goodsDao&quot; /&gt; &lt;property name=&quot;saleDao&quot; ref=&quot;saleDao&quot; /&gt; &lt;/bean&gt; &lt;!--声明式事务处理：和源代码完全分离的--&gt; &lt;!--1.声明事务管理器对象--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot; /&gt; &lt;/bean&gt; &lt;!--2.声明业务方法它的事务属性（隔离级别，传播行为，超时时间） id:自定义名称，表示 &lt;tx:advice&gt; 和 &lt;/tx:advice&gt;之间的配置内容的 transaction-manager:事务管理器对象的id --&gt; &lt;tx:advice id=&quot;myAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--tx:attributes：配置事务属性--&gt; &lt;tx:attributes&gt; &lt;!--tx:method：给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性 name:方法名称，1）完整的方法名称，不带有包和类。 2）方法可以使用通配符,* 表示任意字符 propagation：传播行为，枚举值 isolation：隔离级别 rollback-for：你指定的异常类名，全限定类名。 发生异常一定回滚 --&gt; &lt;tx:method name=&quot;buy&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; rollback-for=&quot;java.lang.NullPointerException,com.bjpowernode.excep.NotEnoughException&quot;/&gt; &lt;!--使用通配符，指定很多的方法--&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRES_NEW&quot; /&gt; &lt;!--指定修改方法--&gt; &lt;tx:method name=&quot;modify*&quot; /&gt; &lt;!--删除方法--&gt; &lt;tx:method name=&quot;remove*&quot; /&gt; &lt;!--查询方法，query，search，find--&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--配置切入点表达式：指定哪些包中类，要使用事务 id:切入点表达式的名称，唯一值 expression：切入点表达式，指定哪些类要使用事务，aspectj会创建代理对象 com.bjpowernode.service com.crm.service com.service --&gt; &lt;aop:pointcut id=&quot;servicePt&quot; expression=&quot;execution(* *..service..*.*(..))&quot;/&gt; &lt;!--配置增强器：关联adivce和pointcut advice-ref:通知，上面tx:advice哪里的配置 pointcut-ref：切入点表达式的id --&gt; &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;servicePt&quot; /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 3.监听器web.xml: 123456789101112131415161718192021&lt;!--注册监听器ContextLoaderListener 监听器被创建对象后，会读取/WEB-INF/spring.xml 为什么要读取文件：因为在监听器中要创建ApplicationContext对象，需要加载配置文件。 /WEB-INF/applicationContext.xml就是监听器默认读取的spring配置文件路径 可以修改默认的文件位置，使用context-param重新指定文件的位置 配置监听器：目的是创建容器对象，创建了容器对象， 就能把spring.xml配置文件中的所有对象都创建好。 用户发起请求就可以直接使用对象了。 --&gt; &lt;context-param&gt; &lt;!-- contextConfigLocation:表示配置文件的路径 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--自定义配置文件的路径--&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 二:SpringMVCM: model(数据) V: view C:DispatcherServlet:(前端控制器) ​ Controller(后端控制器 back controller) 1.web.xml配置中央调度器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!--注册springmvc框架的核心对象DispatcherServlet(中央调度器)--&gt; &lt;!-- 在服务器启动的时候，会找/WEB-INF/myweb-servlet.xml ，/WEB-INF/springmvc-servlet.xml 找的文件命名是： 目录是WEB-INF， 文件名称是： &lt;servlet-name&gt;-servlet.xml 为什么要找这个文件？ 在DispatcherServlet这个Servlet的init()方法中，会创建springmvc的容器对象WebApplicationContext, 在创建容器对象时，会加载读取springmvc需要的配置文件，默认查找位置就是/WEB-INF/&lt;servlet-name&gt;-servlet.xml springmvc需要的配置文件，可以单独指定的，需要配置参数contextConfigLocation. --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--前端控制器（front controller）--&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--指定springmvc配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 在服务器启动的时候，创建Servlet对象 load-on-startup:表示Tomcat启动后出创建对象的顺序,它的值是整数,数值越小 表示创建的时间越早,是一个大于等于0的整数 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- &lt;url-pattern&gt; ： 表示把请求交给指定的Servlet对象。只有把请求交给DispatcherServlet， 这样的请求才能使用springmvc框架处理。 使用DispatcherServlet接收用户的请求。 在框架中url-pattern: 1.扩展名： *.xxxx , xxxx 就是自定义的扩展名。 例如 *.do , *.action,*.mvc等等，不能使用*.jsp 2.使用斜杠&quot;/&quot; --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2.spring.xml 组件扫描器 视图解析器 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--springmvc的配置文件： 声明的web相关的对象，例如处理器对象，视图对象等--&gt; &lt;!--声明组件扫描器--&gt; &lt;context:component-scan base-package=&quot;com.bjpowernode.controller&quot; /&gt; &lt;!--声明视图解析器：springmvc中的一个对象，处理视图的。能指定视图的路径和扩展名 InternalResourceViewResolver:内部资源视图解析器，处理jsp，jstl等视图文件 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--指定前缀：视图文件目录--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt; &lt;!--指定后缀：视图文件的扩展名--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617** * Author: 动力节点 * 2019/5/14 * * @Controller: 创建处理器对象。默认是单例对象 * 处理器对象能接收用户的请求。指定方法处理请求 * * 位置：在类定义的上面 * * @Controller等同于 * &lt;bean id=&quot;myController&quot; class=&quot;com.bjpowernode.controller.MyController&quot;/&gt; * * @RequestMapping: * value: 请求地址的公共部分， 这个公共部分也叫做模块名称 * 位置： 放到类的上面 */ @RequestMapping(value = &quot;/test&quot;) 3.springMVC请求的流程 1.发起some。do 2.tomcat（根据web.xml的—url–pattern知道 *.do的请求给DispatcherServlet） 3.DispatcherServlet （根据springmvc。xml配置知道 some.do—dosome（）） 4.DispatcherServlet把some.do转发给MyController.dosome()方法 5.框架执行dosome（）把得到ModeAndView进行处理，转发到show.jsp 4.中央调度器执行流程![img](file:///C:\\Users\\12070\\Documents\\Tencent Files\\1207071819\\Image\\C2C\\2R0JMSY30AHCP4%UM]`QR.png) 5.RequestMapping指定方法==注意==：value的参数必须带”/“ 比如”/some.do” 123//指定some.do只能使用get请求 // @RequestMapping(value = &#123;&quot;/some.do&quot;,&quot;/first.do&quot;&#125;,method = RequestMethod.GET) 123//指定other.do使用post方式 //HTTP Status 405 - Request method &#x27;GET&#x27; not supported @RequestMapping(value = &#123;&quot;/other.do&quot;,&quot;/second.do&quot;&#125;,method = RequestMethod.POST) 12//third.do不指定请求方式， 请求方式就没有限制 @RequestMapping(value = &quot;/third.do&quot;) 6.接收请求参数1.请求头里面的参数HttpServletRequest HttpServletResponse HttpSession 1234567891011121314public ModelAndView doThird(HttpServletRequest request, HttpServletResponse response, HttpSession session)&#123; String name = request.getParameter(&quot;name&quot;); System.out.println(&quot;处理third.do的请求，执行doThird&quot; + name); ModelAndView mv = new ModelAndView(); //request.setCharacterEncoding(&quot;utf-8&quot;); //response.setCharacterEncoding(&quot;utf-8&quot;); //调用Service处理请求。 mv.addObject(&quot;msg&quot;,&quot;dothird Hello SpringMVC注解开发 name:&quot; + name); mv.setViewName(&quot;show&quot;); return mv; &#125; 2.用户提交的数据400状态码是客户端错误,表示提价请求参数过程中发生了问题 1.逐个接收12345678910111213141516171819202122232425262728293031/** * 逐个接收请求的参数： * 要求是： 处理器方法的形参名和请求中参数名一样。按名称一一赋值 * * 框架的处理方式： * 1.使用request接收请求中的所有参数 * String strName = request.getParameter(&quot;name&quot;); * * String strAge = request.getParameter(&quot;age&quot;); * * 2.适配器对象调用doSome()时，按名称传递参数 * doSome(strName, Integer.parseInt(strAge) ) * * 框架提供了请求参数String到基本类型的转换， String - int , String- float * * 400状态码是客户端错误,表示提价请求参数过程中发生了问题 * 当参数类型是int， 请求参数值是“”, 发生NumberFormatException， TypeMismatchException * 框架不能把“”转为一个有效的int。 页面报出 400 * */ @RequestMapping(value = &quot;/some.do&quot;) public ModelAndView doSome(Integer age,String name)&#123; System.out.println(&quot;处理some.do的请求，执行name:&quot; + name + &quot;|age:&quot;+age); ModelAndView mv = new ModelAndView(); //调用Service处理请求。 mv.addObject(&quot;myname&quot;,name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;show&quot;); return mv; &#125; 2.参数名和形参名不一样1234567891011121314151617181920212223242526/** * 接收请求中参数名和处理器方法的形参名不一样的问题： * 在处理器方法的形参前面加入@RequestParam * @RequestParam的属性 * 1. value:请求中参数名 * 2. required : 默认是true * true:请求中有这个参数 * false:请求中可以没有此参数 * * * 当请求中没有参数时， * 报错：HTTP Status 400 - Required Integer parameter &#x27;rage&#x27; is not present */@RequestMapping(value = &quot;/other.do&quot;)public ModelAndView doOther(@RequestParam(value = &quot;rage&quot;,required = false) Integer age, @RequestParam(value = &quot;rname&quot;,required = false) String name)&#123; System.out.println(&quot;处理other.do的请求，执行name:&quot; + name + &quot;|age:&quot;+age); ModelAndView mv = new ModelAndView(); //调用Service处理请求。 mv.addObject(&quot;myname&quot;,name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;show&quot;); return mv;&#125; 3.对象接收12345678910111213141516171819202122232425262728293031323334353637/** * 使用java对象接收请求的参数。 java对象的属性存储请求参数值 * 要求：java对象的属性名和请求中参数名一样。 * * * 调用doWithObjectParam(); * * 适配器对象，调用处理器方法 * * Student student = new Student(); * student.setName(); * student.setAge(); * * Order order = new Order(); * order.setXXX(); * * School school = new School(); * school.setXXX(); * * 适配器对象.doWithObjectParam(student,order,school); * * 适配器对象.doWithObjectParam(student,&quot;zs&quot;,20); * * 不能使用@RequestParam * */ @RequestMapping(&quot;/paramobject.do&quot;) public ModelAndView doWithObjectParam(Student student)&#123; System.out.println(&quot;处理器方法接收请求参数：&quot;+student); ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, student.getName()); mv.addObject(&quot;myage&quot;, student.getAge()); mv.addObject(&quot;mystudent&quot;, student); mv.setViewName(&quot;show&quot;); return mv; &#125; 7.过滤器CharacterEncodingFilter1234567891011121314151617181920212223242526&lt;!--注册字符集的过滤器，解决post请求乱码的问题--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!--设置项目的编码方式--&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--true强制请求对象request，使用encoding的编码--&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--true强制应答对象response，使用encoding的编码--&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt;&lt;!--/* 表示所有的请求必须先经过这个过滤器处理--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 8.void返回json1.加入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 2.引入jQurey库1&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.1-min.js&quot;&gt;&lt;/script&gt; 3.使用1234567891011121314151617181920212223242526/** * 处理器方法返回void: void没有数据，也没有视图。可以响应ajax的请求。 * 通过HttpServletResponse输出json数据，响应ajax的请求 */@RequestMapping(&quot;/myajax.do&quot;)public void doAjax(String name,Integer age,HttpServletResponse rep) throws IOException &#123; System.out.println(&quot;ajax接收请求的参数&quot;+name+&quot;|&quot;+age); //调用Service处理请求，把结果转为json输出。 Student student = new Student(); student.setName(name); student.setAge(age); //使用jackson，把Student--Json ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(student); //通过HttpServletResponse输出json //rep.getWriter().println(json); PrintWriter pout = rep.getWriter(); pout.println(json); pout.flush();//清空输出的缓存，让数据马上输出。 pout.close();&#125; 9.框架响应json返回对象Object响应json: 步骤==注意==: 注解驱动中mvc:annotation-driven使用的类是http://www.springframework.org/schema/mvc 1234567891011121314151617ch04-return:处理器方法的返回值处理ajax1.加入支持ajax的jQuery库文件2.加入jackson工具库， 目的是完成java对象到json的转换。步骤：1.新建maven web2.加入maven的依赖（坐标）3.在springmvc配置文件加入 &lt;mvc:annotation-driven&gt;注解驱动 json = om.writeValueAsString();4.在处理器方法上面加入@ResponseBody注解 response.setContentType(&quot;application/json;charest=utf-8&quot;); PrintWriter pw = response.getWriter(); pw.println(json); 返回对象使用:123456789101112131415161718192021222324252627282930313233/** * 总结:springmvc中方法返回是对象，使用json输出，需要哪些步骤 * 1.加入maven关于jackson的坐标。 * 2.在springmvc的配置文件 &lt;mvc:annotation-driven /&gt; * 3.在处理器方法的上面加入 @ResponseBody * * @ResponseBody * 作用:把处理器方法返回对象转为json后,通过HttpServletResponse输出给浏览器 * 位置:方法的定义上面,和其他注解没有顺序的关系 */ /** * 例1：处理器方法返回Student-- Json * 框架的处理流程： * 1.框架根据返回值的数据类型Student,遍历HttpMessageConverter接口的实现类对象， * 找能够处理Student类型的实现类对象， Student - MappingJackson2HttpMessageConverter * * 2.框架会调用实现类对象的， write()方法，把Student转为json（JSONObject） * MappingJackson2HttpMessageConverter的wirte(), * MappingJackson2HttpMessageConverter默认的数据处理格式“application/json;charset=UTF-8” * * * 3.框架使用@ResponseBody，把2的结果数据通过HttpServletResponse输出到浏览器 */ @RequestMapping(&quot;/returnObject-student.do&quot;) @ResponseBody public Student ajaxToJson(String name,Integer age)&#123; //调用Service处理业务逻辑 Student student = new Student(); student.setName(&quot;同学：&quot; + name); student.setAge(age); return student; &#125; 返回list使用12345678910111213141516171819202122232425262728293031/** * 处理器方法返回List集合： JSONArray * 框架的处理流程： * 1.框架根据返回值的数据类型Student,遍历HttpMessageConverter接口的实现类对象， * 找能够处理Student类型的实现类对象， Student - MappingJackson2HttpMessageConverter * * 2.框架会调用实现类对象的， write()方法，把Student转为json（JSONArray） * MappingJackson2HttpMessageConverter的wirte(), * MappingJackson2HttpMessageConverter默认的数据处理格式“application/json;charset=UTF-8” * * * 3.框架使用@ResponseBody，把2的结果数据通过HttpServletResponse输出到浏览器 */ @RequestMapping(&quot;/returnObject-list.do&quot;) @ResponseBody public List&lt;Student&gt; ajaxToJsonArray(String name, Integer age)&#123; //调用Service处理业务逻辑 Student student = new Student(); student.setName(&quot;同学张三&quot;); student.setAge(20); Student student1 = new Student(); student1.setName(&quot;同学李四&quot;); student1.setAge(22); List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(student1);//李四 list.add(student);//张三 return list; &#125; 返回string12345678910111213141516171819202122232425262728/** * 处理器方法返回String -- String表示数据 * * 怎么判断String返回值是视图还是数据 * 如果处理器方法上面有@ResponseBody注解， 返回String就是数据， 其他就是视图。 * * 有中文的数据有乱码，因为输出的数据默认是：text/plain;charset=ISO-8859-1 * 解决乱码的问题， 使用@RequestMapping的produces属性 * produces：输出的内容类型和编码 * * 框架的处理流程： * 1.框架根据返回值的数据类型String,遍历HttpMessageConverter接口的实现类对象， * 找能够处理String类型的实现类对象， String - StringHttpMessageConverter * * 2.框架会调用实现类对象的， write()方法，把Student转为json（JSONArray） * StringHttpMessageConverter的wirte(), * StringHttpMessageConverter默认的数据处理格式“text/plain;charset=ISO-8859-1” * * * 3.框架使用@ResponseBody，把2的结果数据通过HttpServletResponse输出到浏览器 */ @RequestMapping(value=&quot;/returnString-data.do&quot;,produces = &quot;text/plain;charset=utf-8&quot;) @ResponseBody public String ajaxToString(String name,Integer age)&#123; return &quot;Hello HttpMessageConverter 返回String作为数据&quot;; &#125;&#125; 10.静态资源访问1.第一种12341. 加入注解驱动&lt;mvc:annotation-driven/&gt;2.加入&lt;mvc:default-servlet-handler/&gt; 2.第二种12345678910111213141516&lt;!--第二种方式处理静态资源： 框架自己处理静态资源的请求，框架会创建处理器对象。 mvc:resources , 加入后框架创建ResourceHttpRequestHandler对象。 处理静态资源的访问 mapping: 请求静态资源的uri地址。 location:静态资源在web应用中的目录位置，最后不用WEB-INF --&gt; &lt;mvc:resources mapping=&quot;/html/**&quot; location=&quot;/html/&quot; /&gt; &lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot; /&gt; &lt;!-- &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;--&gt; &lt;!-- resources 和 @RequestMapping有冲突，加入注解驱动解决冲突问题 --&gt; &lt;mvc:annotation-driven /&gt; 11.相对地址和绝对地址 在jsp, html种使用的地址,都是在前端页面中的地址,都是相对地址 地址分类 ​ 1.绝对地址: 带有协议名称的是绝对地址,例如: http://www.baidu.com ​ 2.相对地址: 没有协议开头,例如 user/some.do 相对地址不能独立使用,必须有一个参考地址,通过参考地址,相对地址本身才能指定资源 ​ 3.参考地址: ​ 在你的页面中,访问地址不加”/“ ​ 例如 user/some.do , 当你点击链接时,访问的地址是当前页面的地址加上链接的地址 ​ http://localhost:8080/myWeb/ + user/some.do ​ 解决方案: ​ 1.加入${pageContext.request.contextPath} ​ 2.加入一个base标签,是html语言中的标签,表示当前页面中访问地址的基地址 ​ 你的页面中所有没有”/“开头的地址,都是以base标签中的地址为参考地址 ​ 使用base中的地址+ user/some.do 组成访问地址 ​ 最常用的方案: 123456789&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;发起请求的jsp&lt;/title&gt;&lt;/head&gt; ​ ​ 在你的页面中,访问地址加上了”/“ ​ 参考地址是你的服务器地址,也就是 http://localhost:8080,当需要访问地址时,需要在jsp路径中加入项目的路径,这种比较麻烦,不可取,所以可以采用el表达式${pageContext.request.contextPath} 例如: 三:ssm整合开发步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445ch10-ssm: SSM整合开发SSM:SpringMVC + Spring + MyBatisSSM:一个项目中需要有多个框架， 是使用框架解决不同方面的问题。SpringMVC解决什么问题？ 接收用户的请求， 调用Service ,显示处理结果的。 是视图层的框架Spring解决问题？使用IoC管理对象， Service ，Dao,工具类等MyBatis作用? 访问数据库。SpringMVC是容器：管理web相关的对象，主要是Controller, 视图等对象。 数据来自Service。Spring容器：管理Service ，Dao,工具类等对象。用户的请求处理是： 用户发起请求---&gt; SpringMVC的Controller ---&gt; Service ---&gt; Dao ----&gt; DB数据库SpringMVC容器和Spring容器的关系： SpringMVC看做是Spring的子容器，从继承的角度看SpringMVC子容器能够访问父容器中的对象， 也就是Controller能访问Service。反过来Service不能访问Controller.SpringMVC容器对象是WebApplicationContextSpring容器对象是WebApplicationContextSpringMVC容器对象有一个属性 parent ，parent的值是Spring容器对象SpringMVC -- parent --- SpringSSM步骤：1.使用之前的springdb库， 表student2.新建maven web3.加入maven的坐标，依赖4.修改web.xml 1)注册springmvc的DispatcherServlet(中央调度器)， 读取springmvc配置文件创建springnvc容器对象，创建文件中的处理器对象 2)注册spring的监听器:ContextLOaderListener，读取spring的配置文件，创建容器对象service，dao等对象 3)注册字符集过滤器，解决post请求乱码。5.把程序中的包建立好，实体类包名， dao， service， controller包名6.编写多个配置文件 1）springmvc的配置文件 2）spring的配置文件 3）mybatis的主配置文件 4）数据库的属性配置文件7.编写代码 实体类定义， Dao接口和sql映射文件， Service接口和实现类， Controller类8.定义视图部分， 各种jsp 1.转发和重定向转发: 123456处理器方法返回ModelAndView,实现转发forward 语法:setViewName(&quot;forward:视图文件完整路径&quot;) 特点:不和视图解析器一同使用,就当没有视图解析器 mv.setViewName(&quot;show&quot;); mv.setViewName(&quot;forward:/WEB-INF/view/show.jsp&quot;);这两种都是转发,第二种是显式转发,当要转发的jsp不在视图解析器目录下时,使用显式转发 重定向: 123456789101112131415161718192021222324252627282930313233343536/** * 处理器方法返回ModelAndView,执行重定向到视图 * 语法: mv.setViewName(&quot;redirect:视图完整路径&quot;) * redirect:不和视图解析器一同工作，就当项目中没有视图解析器 * * * 重定向总结： * 1.重定向不能访问受保护的 /WEB-INF下面的资源 * 2.重定向会把Model中的简单类型的数据转为String, 并把String的数据作为 * get请求的参数附件到 目标地址的后面。 * * 对象类型的数据不能转为String，不能作为参数传递的。 * 3.请求参数是通过param对象获取， 语法 $&#123;param.参数名&#125; */ @RequestMapping(&quot;/other.do&quot;) public ModelAndView doOther(String name, Integer age)&#123; System.out.println(&quot;执行redirect other.do&quot;); ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); //创建Student,放入到Model Student student = new Student(); student.setName(&quot;zhouli&quot;); student.setAge(30); mv.addObject(&quot;mystudent&quot;, student); mv.setViewName(&quot;redirect:/list.jsp&quot;); //不能访问WEB-INF下面的资源的 //mv.setViewName(&quot;redirect:/WEB-INF/view/show.jsp&quot;); /** * http://localhost:8080/ch06/list.jsp?myname=zhangsan&amp;myage=22 */ return mv; &#125; 重定向到其他处理器: 12345678910111213141516171819202122 /** * 重定向到其他的处理器方法 * 语法：mv.setViewName(&quot;redirect:xxx.do&quot;) */ @RequestMapping(&quot;/redirect.do&quot;) public ModelAndView doRedirect(String name,Integer age)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); //指定重定向到其他的处理器 mv.setViewName(&quot;redirect:process2.do&quot;); // http://localhost:8080/ch06/process.do?myname=zs&amp;myage=20 return mv;&#125; //处理重定向过来的请求 @RequestMapping(&quot;/process2.do&quot;) public String doProcess2(String myname,Integer myage)&#123; System.out.println(&quot;======doProcess=========&quot; + myname + &quot; | &quot;+ myage); //转发到show.jsp return &quot;show&quot;; &#125; 2.异常处理注解驱动要加入mvc的类 1234567891011121314151617181920212223ch07-exception-handler:异常处理框架异常处理模式： 处理器中把异常抛出给框架，框架捕获异常，把捕获的异常交给异常处理器对象。 异常处理器是框架中的特定的一些类，可以处理异常。 异常处理器必须实现HandlerExceptionResolver接口： 异常处理器有框架自己实现的，也可以开发人员自定义实现。异常处理步骤:1.新建maven web项目2.加入依赖3.新建一个自定义的异常类 MyUserException,再定义它的子类NameException,AgeException4.在controller抛出NameException,AgeException5.创建一个普通类,作用全局异常处理类 1) 在类的上面加入一个@ControllerAdvice 2) 在类中定义方法,方法的上面加入@ExceptionHandler6.创建异常处理类的视图页面7.创建springmvc的配置文件 1)组件扫描器,扫描@Controller注解 2) 组件扫描器,扫描@ControllerAdvice所在的包 3)声明注解驱动 3.拦截器1234567891011121314151.拦截器时spirngmvc中的一种,需要实现HandlerInterceptor接口2.拦截器和过滤器类似,功能方向侧重点不同,过滤器是哟用来过滤请求参数,设置地府编码集等工作 拦截器是拦截用户的请求,做请求的判断处理3.拦截器是全局的,可以对多个COntroller做拦截 一个项目中可以有0个或多个拦截器,他们在一起拦截用户的请求 拦截器常用在:用户登录处理,权限检查,记录日志 拦截器使用步骤: 1.定义类实现HandlerInterceptor接口(实现接口中的三个方法) 2.在spirngmvc配置文件中,生命拦截器,让框架指代拦截器的存在 (声明拦截器,并指定拦截器的请求uri地址)拦截器的执行时间 1.在请求处理之前,也就是controller类中的方法执行之前先被拦截 2.在控制器方法执行之后也会执行拦截器 3.在请求处理完成功后也会执行拦截器 springmvc配置文件 1234567891011121314151617181920&lt;!-- 声明拦截器:拦截器可以有0个或者多个 在框架中保存多个拦截器是ArrayList按照声明的先后顺序放入到ArrayList--&gt;&lt;!--声明自定义的拦截器--&gt; &lt;mvc:interceptors&gt; &lt;!--声明第一个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--拦截的请求uri地址--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--指定拦截器对象，class:拦截器类的全权限名称--&gt; &lt;bean class=&quot;com.bjpowernode.interceptor.MyInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;!--声明第二个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.bjpowernode.interceptor.CheckLoginInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; Myinterceptor三个方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.bjpowernode.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.RequestDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Date;/** * Author: 动力节点 * 2019/5/17 * * 实现HandlerInterceptor接口的类是拦截器 */public class MyInterceptor implements HandlerInterceptor &#123; private long btime = 0; /** * preHandle:预处理方法，用户的请求首先到达此方法 * 可以请求做处理，验证登录，用户的权限处理，记录日志等 * * 返回值boolean * true: 拦截器和处理器方法都执行了， 也就是请求可以通过拦截器 * ####执行拦截器MyInterceptor的preHandle#### * ===执行处理器MyController的doSome=== * ####执行拦截器MyInterceptor的postHandle#### * ####执行拦截器MyInterceptor的afterCompletion#### * * false:拦截器截断了请求， 不会被处理器处理。 * ####执行拦截器MyInterceptor的preHandle#### * * @param request 请求 * @param response 应答 * @param handler 被拦截的处理器对象（MyController） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; btime = System.currentTimeMillis(); System.out.println(&quot;####11111执行拦截器MyInterceptor的preHandle####&quot;); //request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(request, response); //RequestDispatcher rd = request.getRequestDispatcher(&quot;/result.jsp&quot;); //rd.forward(request, response); return false; &#125; /** * postHandle:后处理方法，在处理器方法执行后执行的。 * 作用是能够获取到处理器方法的执行结果ModelAndView， * 可以修改执行结果的数据和视图。对请求做二次的处理。 * @param request 请求 * @param response 应答 * @param handler 被拦截器的处理器对象 * @param mv 处理器方法的执行结果，方法的返回值 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView mv) throws Exception &#123; System.out.println(&quot;####11111执行拦截器MyInterceptor的postHandle####&quot;); //可以做二次的请求处理 if(mv !=null)&#123; //修改数据 mv.addObject(&quot;mydate&quot;, new Date()); //修改视图 mv.setViewName(&quot;other&quot;); &#125; &#125; /** * afterCompletion:最后执行的方法，在视图View处理完成后执行的，视图处理完成意味请求完成。 * 相当于程序最后执行的一个方法，可以在方法中执行资源回收，内存释放等最后要执行的工作。 * afterCompletion只有在当前的拦截器preHandle()返回true时才有机会执行。 * * @param request 请求 * @param response 应答 * @param handler 被拦截器的处理器对象 * @param ex 程序中发生的异常 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;####11111执行拦截器MyInterceptor的afterCompletion####&quot;); long etime = System.currentTimeMillis(); //System.out.println(&quot;请求的处理时长：&quot;+(etime - btime)); &#125;&#125;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Servlet","slug":"Servlet","date":"2020-10-15T13:40:48.438Z","updated":"2020-10-15T07:25:06.194Z","comments":true,"path":"2020/10/15/Servlet/","link":"","permalink":"http://example.com/2020/10/15/Servlet/","excerpt":"","text":"一:Servlet接口实现类开发步骤1234567891011121314151617181920212223242526第一步：创建一个Java类继承与HttpServlet父类，使之成为一个Servlet接口实现类第二步：重写HttpServlet父类两个方法。doGet或则doPost get 浏览器------》oneServlet.doGet() post 浏览器------》oneServlet.doPost()第三步：将Servlet接口实现类信息【注册】到Tomcat服务器 【网站】---&gt;【web】---》【WEB-INF】---&gt;web.xml &lt;!--将Servlet接口实现类类路径地址交给Tomcat--&gt; &lt;servlet&gt; &lt;servlet-name&gt;mm&lt;/servlet-name&gt; &lt;!--声明一个变量存储servlet接口实现类类路径--&gt; &lt;servlet-class&gt;com.bjpowernode.controller.OneServlet&lt;/servlet-class&gt; &lt;!--声明servlet接口实现类类路径--&gt; &lt;/servlet&gt; &lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mm&lt;/servlet-name&gt; &lt;url-pattern&gt;/one&lt;/url-pattern&gt; &lt;!--设置简短请求别名,别名在书写时必须以&quot;/&quot;为开头--&gt; &lt;/servlet-mapping&gt;如果现在浏览器向Tomcat索要OneServlet时地址:http://localhost:8080/myWeb/one 二:Servlet对象生命周期1234567891011121314151.网站中所有的Servlet接口实现类的实例对象，只能由Http服务器负责额创建。 开发人员不能手动创建Servlet接口实现类的实例对象 2.在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时 自动创建这个Servlet接口实现类的实例对象 在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象 &lt;servlet&gt; &lt;servlet-name&gt;mm&lt;/servlet-name&gt; &lt;!--声明一个变量存储servlet接口实现类类路径--&gt; &lt;servlet-class&gt;com.bjpowernode.controller.OneServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;30&lt;load-on-startup&gt;&lt;!--填写一个大于0的整数即可--&gt; &lt;/servlet&gt;3.在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象4.在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁 三:HttpServletResponse12345678910111213141516171.介绍: 1)HttpServletResponse接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar 2)HttpServletResponse接口实现类由Http服务器负责提供 3)HttpServletResponse接口负责将doGet/doPost方法执行结果写入到【响应体】交给浏览器 4)开发人员习惯于将HttpServletResponse接口修饰的对象称为【响应对象】2.主要功能: 1) 将执行结果以二进制形式写入到【响应体】 2) 设置响应头中[content-type]属性值，从而控制浏览器使用 对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】 3) 设置响应头中【location】属性，将一个请求地址赋值给location. 从而控制浏览器向指定服务器发送请求 123response.setContentType(&quot;text/html;charset=utf-8&quot;);PrintWriter pw = response.getWriter();pw.print(); 四:HttpServletRequest123456789101112131.介绍: 1)HttpServletRequest接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar 2)HttpServletRequest接口实现类由Http服务器负责提供 3)HttpServletRequest接口负责在doGet/doPost方法运行时读取Http请求协议包中信息 4)开发人员习惯于将HttpServletRequest接口修饰的对象称为【请求对象】 2.作用: 1)可以读取Http请求协议包中【请求行】信息 2)可以读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息 3)可以代替浏览器向Http服务器申请资源文件调用 12//1.调用请求对象对请求体使用utf-8字符集进行重新编辑 request.setCharacterEncoding(&quot;utf-8&quot;); 五:欢迎资源文件123456789101112131415161718192021222324252627281.前提： 用户可以记住网站名，但是不会记住网站资源文件名2.默认欢迎资源文件: 用户发送了一个针对某个网站的【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件 正常请求： http://localhost:8080/myWeb/index.html 默认请求： http://localhost:8080/myWeb/ 3.Tomcat对于默认欢迎资源文件定位规则 1）规则位置：Tomcat安装位置/conf/web.xml 2）规则命令： &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;4.设置当前网站的默认欢迎资源文件规则 1)规则位置: 网站/web/WEB-INF/web.xml 2)规则命令: &lt;welcome-file-list&gt; &lt;welcome-file&gt;user/delete&lt;/welcome-file&gt; //servlet的资源别名,动态资源文件要把前面的/抹掉 &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;//静态资源文件 &lt;/welcome-file-list&gt; 3)网站设置自定义默认文件定位规则，此时Tomcat自带定位规则将失效 六:状态码1234561:介绍:1)由三位数字组成的一个符号。2)Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上3)如果Http服务器针对本次请求，返回了对应的资源文件。通过Http状态码通知浏览器应该如何处理这个结果 如果Http服务器针对本次请求，无法返回对应的资源文件通过Http状态码向浏览器解释不能提供服务的原因 1234567891011121314151617181920212223242526272829303132333435362:分类1）组成 100---599；分为5个大类2）1XX : 最有特征 100; 通知浏览器本次返回的资源文件 并不是一个独立的资源文件，需要浏览器在接收 响应包之后，继续向Http服务器所要依赖的其他资源文件3) 2XX： 最有特征200，通知浏览器本次返回的资源文件是一个 完整独立资源文件，浏览器在接收到之后不需要所要 其他关联文件4）3xx: 最有特征302，通知浏览器本次返回的不是一个资源文件内容 而是一个资源文件地址，需要浏览器根据这个地址自动发起 请求来索要这个资源文件 response.sendRedirect(&quot;资源文件地址&quot;)写入到响应头中location 而这个行为导致Tomcat将302状态码写入到状态行5）4XX: 404: 通知浏览器，由于在服务端没有定位到被访问的资源文件因此无法提供帮助 405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet） 但是这个Servlet对于浏览器采用的请求方式不能处理6）5xx: 500:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet） 这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理 请求期间，由于Java异常导致处理失败 500错误示例: Map map = new HashMap(); //int num = (int)map.get(&quot;key1&quot;);//NullPointerException异常 Interger num = (Interger)map.get(&quot;key1&quot;);//正常 //int a = null;//null值不能赋值给int Interger b = null;//所有高级引用类型都可以赋值给null 七:重定向123456789101112131415161718192021222324252627281.工作原理: 用户第一次通过【手动方式】通知浏览器访问OneServlet。 OneServlet工作完毕后，将TwoServlet地址写入到响应头 location属性中，导致Tomcat将302状态码写入到状态行。 在浏览器接收到响应包之后，会读取到302状态。此时浏览器 自动根据响应头中location属性地址发起第二次请求，访问 TwoServlet去完成请求中剩余任务2.实现命令: response.sendRedirect(&quot;请求地址&quot;) 将地址写入到响应包中响应头中location属性3.特征: 1)请求地址： 既可以把当前网站内部的资源文件地址发送给浏览器 （/网站名/资源文件名） 也可以把其他网站资源文件地址发送给浏览器(http://ip地址:端口号/网站名/资源文件名) 2)请求次数 浏览器至少发送两次请求，但是只有第一次请求是用户手动发送。 后续请求都是浏览器自动发送的。 3) 请求方式： 重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此 通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】 4).缺点: 重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间 消耗在往返次数上，增加用户等待服务时间 八:转发123456789101112131415161718192021222324252627282930313233341.原理： 用户第一次通过手动方式要求浏览器访问OneServlet。 OneServlet工作完毕后，通过当前的请求对象代替浏览器 向Tomcat发送请求，申请调用TwoServlet。 Tomcat在接收到这个请求之后，自动调用TwoServlet来完成剩余任务2.实现命令： 请求对象代替浏览器向Tomcat发送请求 //1.通过当前请求对象生成资源文件申请报告对象 RequestDispatcher report = request.getRequestDispatcher(&quot;/资源文件名&quot;);一定要以&quot;/&quot;为开头 //2.将报告对象发送给Tomcat report.forward(当前请求对象，当前响应对象)可以合并为: request.getRequestDispatcher(&quot;/资源文件名&quot;).forward(request，response);3.优点： 1）无论本次请求涉及到多少个Servlet,用户只需要手动通过浏览器发送一次请求 2) Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数 增加处理服务速度4.特征: 1)请求次数 在请求转发过程中，浏览器只发送一次请求 2）请求地址 只能向Tomcat服务器申请调用**当前网站**下资源文件地址 request.getRequestDispathcer(&quot;/资源文件名&quot;) ****不要写网站名**** 3）请求方式 在请求转发过程中，浏览器只发送一个了个Http请求协议包。 参与本次请求的所有Servlet共享同一个请求协议包，因此 这些Servlet接收的请求方式与浏览器发送的请求方式**保持一致** 九:多个Servlet之间数据共享实现方案12345678910111.数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用2.Servlet规范中提供四种数据共享方案 1.ServletContext接口 2.Cookie类 3.HttpSession接口 4.HttpServletRequest接口 十:ServletContext接口12345678910111213141516171819202122232425262728293031323334353637381.介绍： 1）来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar 在Tomcat中负责提供这个接口实现类 2）如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享 3）开发人员习惯于将ServletContext对象称为【全局作用域对象】2.工作原理： 每一个网站都存在一个全局作用域对象。这个全局作用域对象【相当于】一个Map. 在这个网站中OneServlet可以将一个数据,存入到全局作用域对象，当前网站中其他 Servlet此时都可以从全局作用域对象得到这个数据进行使用3.全局作用域对象生命周期： 1）在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象 2）在Http服务器运行期间时，一个网站只有一个全局作用域对象 3）在Http服务器运行期间，全局作用域对象一直处于存活状态 4）在Http服务器准备关闭时，负责将当前网站中全局作用域对象进行销毁处理 *****全局作用域对象生命周期贯穿网站整个运行期间*** 4.命令实现： 【同一个网站】OneServlet将数据共享给TwoServlet OneServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; //1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】 ServletContext application = request.getServletContext(); //2.将数据添加到全局作用域对象作为【共享数据】 application.setAttribute(&quot;key1&quot;,数据) &#125; &#125; TwoServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; //1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】 ServletContext application = request.getServletContext(); //2.从全局作用域对象得到指定关键字对应数据 Object 数据 = application.getAttribute(&quot;key1&quot;); &#125; &#125; 十一:Cookie12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970711.介绍: 1)Cookie来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中 2)如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时 借助于Cookie对象进行数据共享 3) Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量 4) 在现实生活场景中，Cookie相当于用户在服务端得到【会员卡】2.原理: 用户通过浏览器第一次向【MyWeb网站】发送请求申请OneServlet。 OneServlet在运行期间创建一个Cookie存储与当前用户相关数据 OneServlet工作完毕后，【将Cookie写入到响应头】交还给当前浏览器。 浏览器收到响应响应包之后，将cookie存储在浏览器的缓存 一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。 【浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头】发送过去 此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据3.实现命令: 同一个网站 OneServlet 与 TwoServlet 借助于Cookie实现数据共享 OneServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse resp)&#123; //1.创建一个cookie对象，保存共享数据（当前用户数据） Cookie card = new Cookie(&quot;key1&quot;,&quot;abc&quot;); Cookie card1= new Cookie(&quot;key2&quot;,&quot;efg&quot;); ****cookie相当于一个map ****一个cookie中只能存放一个键值对 ****这个键值对的key与value只能是String ****键值对中key不能是中文 //2.【发卡】将cookie写入到响应头，交给浏览器 resp.addCookie(card); resp.addCookie(card1) &#125; &#125; 浏览器/用户 &lt;---------响应包 【200】 【cookie: key1=abc; key2=eft】 【】 【处理结果】浏览器向myWeb网站发送请求访问TwoServlet----&gt;请求包 【url:/myWeb/two method:get】 【 请求参数：xxxx Cookie key1=abc;key2=efg 】 【】 【】 TwoServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse resp)&#123; //1.调用请求对象从请求头得到浏览器返回的Cookie Cookie cookieArray[] = request.getCookies(); //2.循环遍历数据得到每一个cookie的key 与 value for(Cookie card:cookieArray)&#123; String key = card.getName(); 读取key &quot;key1&quot; String value = card.getValue();读取value &quot;abc&quot; 提供较好的服务。。。。。。。。 &#125; &#125; &#125;4.Cookie销毁时机: 1.在默认情况下，Cookie对象存放在浏览器的缓存中。 因此只要浏览器关闭，Cookie对象就被销毁掉 2.在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie 在硬盘上存活时间。在存活时间范围内，关闭浏览器 关闭客户端计算机，关闭服务器，都不会导致Cookie 被销毁。在存活时间到达时，Cookie自动从硬盘上被 删除 cookie.setMaxAge(60); //cookie在硬盘上存活1分钟 十一:HttpSession12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182831.介绍： 1）HttpSession接口来自于Servlet规范下一个接口。存在于Tomcat中servlet-api.jar 其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar 2）如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时 借助于HttpSession对象进行数据共享 3）开发人员习惯于将HttpSession接口修饰对象称为【会话作用域对象】2.HttpSession 与 Cookie 区别：【面试题】 1）存储位置: 一个在天上，一个在地下 Cookie：存放在客户端计算机（浏览器内存/硬盘） HttpSession：存放在服务端计算机内存 2）数据类型： Cookie对象存储共享数据类型只能是String HttpSession对象可以存储任意类型的共享数据Object 3) 数据数量: 一个Cookie对象只能存储一个共享数据 HttpSession使用map集合存储共享数据，所以可以存储任意数量共享数据4）参照物: Cookie相当于客户在服务端【会员卡】 HttpSession相当于客户在服务端【私人保险柜】3.命令实现: 同一个网站（myWeb）下OneServlet将数据传递给TwoServletOneServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; //1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜 HttpSession session = request.getSession(); //2.将数据添加到用户私人储物柜 session.setAttribute(&quot;key1&quot;,共享数据) &#125; &#125; 浏览器访问/myWeb中TwoServletTwoServlet&#123; public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; //1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜 HttpSession session = request.getSession(); //2.从会话作用域对象得到OneServlet提供的共享数据 Object 共享数据 = session.getAttribute(&quot;key1&quot;); &#125; &#125;4.Http服务器如何将用户与HttpSession关联起来 cookie,Tomcat会将第一次的HttpSession的数据保存在cookie请求头中推送给用户,并且保存在 浏览器的内存中,随着第二次访问,会携带这部分cookie去访问5.getSession() 与 getSession(false) 1）getSession(): 如果当前用户在服务端已经拥有了自己的私人储物柜. 要求tomcat将这个私人储物柜进行返回 如果当前用户在服务端尚未拥有自己的私人储物柜 要求tocmat为当前用户创建一个全新的私人储物柜 2)getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜. 要求tomcat将这个私人储物柜进行返回 如果当前用户在服务端尚未拥有自己的私人储物柜 此时Tomcat将返回null6.HttpSession销毁时机: 1.用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中. 2.在浏览器关闭时，意味着用户与他的HttpSession关系被切断 3.由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会 导致Tomcat将浏览器关联的HttpSession进行销毁 4.为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】 这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟 此时Tomcat认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁 掉这个HttpSession7.HttpSession空闲时间手动设置 在当前网站/web/WEB-INF/web.xml&lt;session-config&gt; &lt;session-timeout&gt;5&lt;/session-timeout&gt; &lt;!--当前网站中每一个session最大空闲时间5分钟--&gt;&lt;/session-config&gt; 十二:HttpRequest123456789101112131415161718192021222324252627281.介绍： 1） 在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用， 彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象 因此servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个 Servlet之间实现数据共享 2） 在请求对象实现Servlet之间数据共享功能时，开发人员将请求对象称为【请求作用域对象】2.命令实现： OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据OneServlet&#123; public void doGet(HttpServletRequest req,HttpServletResponse response)&#123; //1.将数据添加到【请求作用域对象】中attribute属性 req.setAttribute(&quot;key1&quot;,数据); //数据类型可以任意类型Object //2.向Tomcat申请调用TwoServlet req.getRequestDispatcher(&quot;/two&quot;).forward(req,response) &#125; &#125;TwoServlet&#123; public void doGet(HttpServletRequest req,HttpServletResponse response)&#123; //从当前请求对象得到OneServlet写入到共享数据 Object 数据 = req.getAttribute(&quot;key1&quot;); &#125; &#125; 十三:监听器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601.介绍： 1）一组来自于Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包 2）监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类 3）监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】2.作用域对象： 1）在Servlet规范中，认为在服务端内存中可以在某些条件下为两个Servlet之间提供 数据共享方案的对象，被称为【作用域对象】 2）Servlet规范下作用域对象: ServletContext： 全局作用域对象 HttpSession : 会话作用域对象 HttpServletRequest:请求作用域对象3.监听器接口实现类开发规范：三步 1）根据监听的实际情况，选择对应监听器接口进行实现 public class OneListener implements ServletContextAttributeListener&#123;&#125; 2）重写监听器接口声明【监听事件处理方法】 3）在web.xml文件将监听器接口实现类注册到Http服务器 &lt;!--注册监听器接口实现类,写当前监听器所在的位置--&gt; &lt;listener&gt; &lt;listener-class&gt;com.bjpowernode.listener.OneListener&lt;/listener-class&gt; &lt;/listener&gt;4.ServletContextListener接口： 1）作用：通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻 2）监听事件处理方法： public void contextInitlized（） ：在全局作用域对象被Http服务器初始化被调用 public void contextDestory(): 在全局作用域对象被Http服务器销毁时候触发调用5.ServletContextAttributeListener接口: 1)作用：通过这个接口合法的检测全局作用域对象共享数据变化时刻 2）监听事件处理方法： public void contextAdd():在全局作用域对象添加共享数据 public void contextReplaced():在全局作用域对象更新共享数据 public void contextRemove():在全局作用域对象删除共享数据6.全局作用域对象共享数据变化时刻 ServletContext application = request.getServletContext(); application.setAttribute(&quot;key1&quot;,100); //新增共享数据 application.setAttribute(&quot;key1&quot;,200); //更新共享数据 application.removeAttribute(&quot;key1&quot;); //删除共享数据 十四:filter过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651.介绍： 1）来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包 2）Filter接口实现类由开发人员负责提供，Http服务器不负责提供 3)Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截2.具体作用： 1）拦截Http服务器，帮助Http服务器检测当前请求合法性 2）拦截Http服务器，对当前请求进行增强操作 3.Filter接口实现类开发步骤：三步 1）创建一个Java类实现Filter接口 2）重写Filter接口中doFilter方法 3）web.xml将过滤器接口实现类注册到Http服务器 public class OneFilter implements Filter &#123;例如: //通知拦截的请求对象，使用UTF-8字符集对当前请求体信息进行一次重新编辑 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;);//增强 //将拦截请求对象和响应对象交还给Tomcat,由Tomcat继续调用资源文件 filterChain.doFilter(servletRequest, servletResponse); &#125;&#125;4.Filter拦截地址格式 &lt;!--将过滤器类文件路径交给Tomcat--&gt; &lt;filter&gt; &lt;filter-name&gt;oneFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.bjpowernode.filter.OneFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;oneFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/mm.jpg&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 1) 命令格式: &lt;filter-mapping&gt; &lt;filter-name&gt;oneFilter&lt;/filter-name&gt; &lt;url-pattern&gt;拦截地址&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2) 命令作用： 拦截地址通知Tomcat在调用何种资源文件之前需要调用OneFilter过滤进行拦截 3）要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截 &lt;url-pattern&gt;/img/mm.jpg&lt;/url-pattern&gt; 4）要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用OneFilter拦截 &lt;url-pattern&gt;/img/*&lt;/url-pattern&gt; 5）要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截 &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; 6)要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 十五:防止恶意登录 12345678910111213141516171819202122232425public class OneFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest)servletRequest; HttpSession session = null; //1.调用请求对象读取请求包中请求行的URI,了解用户访问的资源文件是谁 String uri = request.getRequestURI();//[/网站名/资源问价名 /myWeb/login.html or /myweb/login or...] //2.如果本次请求资源文件于登陆相关[login.html 或者 loginservlet]此时应该无条件放行 //indexOf---&gt;uri首次出现的位置,如果没有则=-1 if(uri.indexOf(&quot;login&quot;)!=-1 || &quot;/myWeb/&quot;.equals(uri))&#123; filterChain.doFilter(servletRequest,servletResponse); return; &#125; //3.如果本次请求访问的是其他的资源文件,需要的得到用户在服务器端HttpSession session = requset.getSession(false); if(session != null)&#123; filterChain.doFilter(servletRequest, servletResponse); return; &#125; //4.做拒绝请求 request.getRequestDispatcher(&quot;/login_error.html&quot;).forward(servletRequest, servletResponse); &#125;&#125; request.getSession(true)：若存在会话则返回该会话，否则新建一个会话。 request.getSession(false)：若存在会话则返回该会话，否则返回NULL 十六:最终版互联网流程图","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"mysql","slug":"mysql","date":"2020-10-15T13:40:48.436Z","updated":"2020-10-15T07:25:02.267Z","comments":true,"path":"2020/10/15/mysql/","link":"","permalink":"http://example.com/2020/10/15/mysql/","excerpt":"","text":"一.数据库管理1.MySql服务器管理数据库位置1C:\\ProgramData\\MySQL\\MySQL Server 5.5\\data 2.查看所有的数据库名1show databases; 3.创建一个数据库1create database 数据库名; 4.删除一个数据库1drop database 数据库名; 二:表文件管理1.查看表12USE 数据库名;show tables; 2.创建表12345use 数据库;create table 表文件名(字段名 数据类型名,段名 数据类型名 #最后一个字段不要以&quot;,&quot;) 3.删除一个表文件1drop table 表文件名； 4.查看表文件字段信息1show create table 表文件名; 5.为表文件添加字段1alter table 表文件名 add 新字段名 数据类型名; 6.删除表文件字段1alter table 表文件名 drop 字段名; 三:表文件数据行管理1.插入命令负责要求MySql服务器向指定的表文件添加数据行 12insert into 表文件名(字段名1,字段名2，字段名3)values(值1，值2，&#x27;值3&#x27;);#插入字符串的时,value值中需要加单引号 2.查询命令负责要求MySql服务器将指定的表文件数据行展示 1select * from 表文件名; 3.删除命令负责要求MySql服务器将指定的表文件数据行删除 123delete from 表文件名; #删除表文件中所有的数据行delete from 表文件名 where 判断条件; #将满足条件的数据行进行删除 4.更新命令负责要求MySql服务器将指定的表文件数据行更新 1234update 表文件名 set 字段名1=值,字段名2=值 ；将所有数据行指定字段的值赋值新值update 表文件名 set 字段名1=值,字段名2=值 where 判断条件; 将满足条件的数据行字段信息更新 四:高级插入命令1.一次性向表文件插入多行数据12345INSERT INTO表文件名(字段1，字段2，字段3)values(值1，值2，值3)，(值10，值20，值30); 2.简化版插入命令如果插入数据时每一个字段都能赋值，此时插入命令不需要指定字段名，插入值顺序此时需要与表文件字段顺序保持一致 1insert into 表文件名 values(值1，值2，值3) 3.数据行备份命令可以将表A中数据行复制到表B,(表A与表B字段结构完全一致) 1insert into B select * from A 五:表文件备份命令将表文件A进行一份备份，备份生成的表文件B 1create table B select * from A 六:==临时表==1234567891011121314151617181.临时表定义：由查询命令在执行时，在内存中生成的表文件2.临时表作用：每一个查询命令在执行时，实际上操作都是上一个查询命令生成的临时表3.临时表生命周期： 在当前查询命令执行完毕后，MySql服务器自动将上一个查询命令生成的 临时表从内存中销毁。导致用户最终看到的临时表只能查询语句中，最后 一个查询生成的临时表 4.七个查询命令与临时表之间关系： 1.七个查询命令中，只有FROM命令不需要操作临时表，FROM负责将硬盘上表文件加载到内存 中生成第一个临时表，剩下的六个查询命令操作的都是上一个查询命令生成的临时表 2.七个查询命令中，只有GROUP BY命令在执行完毕后，才有机会在内存中生成多个临时表。 其他五个查询命令在执行完毕后，只能在内存中生成一个临时表 3.七个查询命令中，只有HAVING命令在执行完毕后，不会生成新临时表。负责将GROUP BY 生成的临时表中不满足条件的临时表从内存中进行删除处理 七:查询命令#==七个查询执行顺序==1from--&gt;where--&gt;group by--&gt;having--&gt;select--&gt;order by--&gt;limit 1.where1234567891011121314151617181.执行顺序：FROM--&gt;WHERE--&gt;SELECT2.书写顺序： SELECT 字段名，函数， 子查询 FROM 表文件 WHERE 关系运算/逻辑运算where 后面可以接判断条件例如:1) &gt; &lt; = &gt;=2) and 与运算符 or 或运算符3) between and 区间运算符4) in: where 字段名 in(值1,值2)5) not in: where 字段名 not in(值1,值2)6) is null : 查询指定字段的值为null7) is not null: 查询指定字段值不是null 2.like 模糊查询12345 % 是一个通配符,表示一个任意长度额字符串1) where 字段值 like &#x27;s%&#x27; ---&gt;前置条件模糊查询2) where 字段值 like &#x27;%s&#x27; ---&gt;后置条件模糊查询3) where 字段值 like &#x27;%s%&#x27; ---&gt;包含条件模糊查询4) where 字段值 like &#x27;_A%&#x27; ---&gt;第二个字母是A的,_是通配符,表示任意一个字符 3.聚合函数1234561) max(字段): 返回指定字段的最大值2) min(字段): 返回指定字段的最小值3) sum(字段): 返回指定字段下所有数据相加之和4) avg(字段): 返回指定下所有数据平均值5) count(字段): 返回指定字段下内容不等于null的数据个数6) count(*): 统计临时表下所有数据行个数,不考虑数据行是否存在null 4.group by 分组查询七个查询命令中，只有GROUP BY有机会在执行完毕后，一次生成==多个==临时表 12345678910111213141.执行顺序： FROM--&gt;WHERE--&gt;GROUP BY--&gt;SELECT 2.书写顺序: SELECT 字段名,函数，子查询(一般是根据分组字段属性选) FROM 表名 WHERE 定位数据行条件 GROUP BY 分组字段***如果同时出现WHERE与GROUP BY;GROUP BY应该在where之后3.执行原理： GROUP BY 分组字段 执行时,首先根据分组字段数据种类，将临时表数据行进行分类。 然后将具有相同特征的数据行读取出来保存到一个全新临时表 5.group by 的多字段查询12345678910111.多字段分组时，分组字段出现顺序对于最终查询结果没有 任何影响的。 Group by deptno,job 与 group by job,deptno 给出最终结果是一致的2.多字段分组时，GROUP By一次只能根据一个分组字段进行分组 GROUP BY DEPTNO,JOB ,此时GORUP BY需要执行两次3.多字段分组时，从第二个分组字段开始，操作的是上一个分组字段生成的临时表。GROUP BY DEPTNO,JOB.当执行group by job时，操作临时表由Group by deptno来生成 6.降序,升序一般和order by合用 12desc 降序asc 升序 7.order by123456789101112131415161.执行顺序FROM--&gt;WHERE--&gt;GORUP BY--&gt;HAVING--&gt;SELECT--&gt;ORDER BY 2.书写顺序 SELECT 字段，函数，子查询 FROM 表名 WHERE 定位数据行判断条件 GROUP BY 分组字段1，分组字段2.。。 HAVING 进行临时表删除判断条件 ORDER BY 排序字段1，排序字段2 desc or asc3.执行原理： order by 负责将SELECT生成临时表数据行进行重新排序。 然后将排序后数据行保存到一个全新临时表4.例子: order by 不仅仅可以写字段命，也可以写字段在【当前临时表位置】select deptno,ename,job,sal from emp where deptno=20 order by 4 desc 8.having1234567891011121314151617181.执行顺序： FROM--&gt;WHERE--&gt;GROUP BY--&gt;HAVING--&gt;SELECT2.书写顺序： HAVING命令不能独立出现在查询语句。&quot;只能出现在GROUP BY 后面&quot; SELECT 字段名，函数名，子查询 FROM 表名 WHERE 数据行定位判断 GROUP BY 分组字段1，分组字段2 HAVING 通过统计临时表信息决定是否删除临时表3.执行原理： having命令在group by之后执行的。负责将GROUP BY生成临时表中不满足条件的临时表从内存中删除掉4.七个查询命令中，只有having在执行完毕后不会生成全新临时表 9.==limit== 截至MySql服务器中，表文件字段位置从1开始计算，表文件数据行位置从0开始计算 例子:查询销售人员工资排在前两名的职员信息 1select * from emp where job=&#x27;salesman&#x27; order by sal desc limit 0,2 1234567891011121314151.执行顺序： FROM--&gt;WHERE--&gt;GROUP BY--&gt;HAVING--&gt;SELECT--&gt;ORDER BY--&gt;LIMIT2.书写顺序: SELECT 字段，函数，子查询 FROM 表 WHERE 定位数据行条件【关系运算/逻辑运算/特殊运算符】 GROUP BY 分组字段1，分组字段2 HAVING 对临时表进行删除判断条件 ORDER BY 排序字段1，排序字段2 Limit 起始行位置，从起始行开始向下截取行数3.执行原理： 从临时表指定位置的数据行开始，向下截取指定数量的数据行。将截取出来的数据行保存到一个全新的临时表 八:多表查询1.表关系 表文件字段分类： 1.主键字段：用于存放主键编号的字段就是主键字段。每一个表都应该存在一个主键字段。主键编号相当于身份证编号，用于对表文件中 数据行身份进行确认。 主键字段中既不能出现null值，也不能出现重复值 2.非主键字段：描述主键编号 3.外键字段： 外键字段只存在于【多方表】，描述多方数据与一方数据之间依赖关系 ==外键字段的值应该来自于一方表中主键值== 2.多表查询的本质 1.将多张表数据行合并到同一个临时表，然后使用【六个查询命令】根据需求对临时表数 据行进行定位分组排序等操作最终为用户提供需要的数据的查询过程 2.多表查询关键点： 如何将多张表数据合并到同一个临时表 3.==多张表合并方案== 1.==连接查询合并方案==：[最常见] 1）首先确保两张表之间存在了【隶属关系】，才可以使用连接查询合并方案2）将两张表中数据行【沿着水平方向进行拼接】,最终得到一个拥有【完整隶属关系】新数据行 2.==联合查询合并方案==： 1）不需要两张表之间存在了【隶属关系】 2）将两张表中数据行【沿着垂直方向进行堆砌】 4.jion连接 1.将两个表文件数据行沿着水平方向进行拼接，拼接后数据行存在内存的一个临时表 2.命令格式 FROM 一方表 JOIN 多方表 FROM 多方表 JOIN 一方表 3.JOIN两边出现表位置，对于最终查询结果==没有==任何影响 4.JOIN生成临时表字段由一方表字段与多方表字段相加而来(m+n) 5.JOIN生成临时表字段名由==表名.字段==名组成，防止在同一个临时表出现同名字段问题 6.JOIN生成临时表数据行由一方表(n行)每一个数据行与多方表(m行)所有数据行拼接而成==(n*m)==行—–&gt;笛卡尔积 7.JOIN生成临时表必然存在【脏数据行】，可以达到50%以上。【脏数据行】对后续统计分析带来巨大错误，因此在JOIN工作完毕后，必须要将【合法数据行】从当前临时表读取出来存放一个全新临时表，为后续操作做准备 5.连接查询过滤方案 on 概念: ​ JOIN生成临时表必然存在【脏数据行】，【脏数据行】对后续操作带来巨大影响。因此在JOIN生成临时表之后，必须要做的一件事将【合法数据行】与【脏数据行】进行==剥离==这个行为称之为【连接查询过滤方案】 语法: ​ FROM 一方表 JOIN 多方表​ ON 定位合法数据行条件 【连接查询过滤方案】 合法数据行与脏数据行区分原则： 1.如果表文件存在了明显的【外键字段】 ON 当前数据行来自于一方表主键字段值 = 当前数据行来自于多方外键字段值 2.如果表文件没有存在明显的【外键字段】 ON 根据实际隶属关系进行判断 例子: 123456789SELECT DEPT.DNAME, EMP.JOB, COUNT(*)FROM DEPT JOIN EMPON DEPT.DEPTNO = EMP.DEPTNO---&gt;(on一般接的是主键值和对应的外键值)WHERE DEPT.DEPTNO =20GROUP BY EMP.JOB 6.union联合查询 1.要求参与合并的两个临时表的字段结构必须保持一致【字段个数，字段类型顺序】 2.将两个临时表数据行沿着垂直方向堆砌到同一个临时表 3.联合查询生成临时表的字段只能来自于==【第一个临时表字段】== 4.UNION命令在执行时，自动将两个临时表内容相同数据行进行过滤，类似于Java中Set集合 5.UNION ALL命令在执行时，不会将临时表重复的数据进行过滤 12345需求： 将部门编号，部门名称，职员编号，职员名称展示出来SQL: select deptno,dname from dept #第一个临时表 UNION #联合查询合并方案 select empno,ename from emp #第二个临时表 7.select子查询123概念: 1.查询时无法从当前临时表得到需要的数据，此时MySql服务器允许开发人员通过【完整查询语句】从别处得到 2.需要数据，从而保证查询正常执行，这个起到帮助作用【完整查询语句】相当于外援。在技术上被称为【子查询】 子查询可以在哪些场景中提供数据 123456789101112131415 SELECT 字段，函数，子查询 FROM 将硬盘上表文件加载到内存中生成一个临时表 指向在内存中已经存在的临时表，此时可以借助于子查询提供这个临时表 WHERE 可以通过子查询得到进行判断的数据 GROUP BY 分组字段名1，分组字段2 HAVING 可以通过子查询得到删除临时表时需要判断数据ORDER BY 排序字段1，排序字段2Limit 起始行位置，向下截取行数 九:字符串类型1.varchar12345678varchar(m): 定长可变字符串 定长： 当前字段可以存储的字符个数是固定的 ename varchar(3) # 3表示ename字段可以存储3个英文字符或则3个中文 可变： ename字段在硬盘上存储字符空间可以根据实际情况进行【缩小】 ename varchar(3) insert into test1 values(&#x27;abc&#x27;) #硬盘 【a】【b】【c】 insert into test1 values(&#x27;ef&#x27;) #硬盘 【e】【f】 2.char1234567891011121314char(m): 定长不可变字符串定长： 当前字段可以存储的字符个数是固定的 sex char(1) #1表示sex字段可以存储1个英文字母或则1个中文不可变: sex字段在硬盘上存储字符空间是固定的sex char(3)insert into test1 values(&#x27;abc&#x27;) 【a】 【b】 【c】insert into test1 values(&#x27;ef&#x27;) 【e】 【f】 【空格】针对char类型字段进行数据读取时，MySql服务器自动将字符串中【结尾处空格去掉】如果插入字符串以空格结尾，不要添加到由char类型修饰的字段 十:约束123456789101112131.非空约束 not null： 要求管理的字段不能存储null值2.唯一性约束 unique：要求管理的字段存储值不能有重复，但是可以存储null值3.主键约束 primary key： 管理主键字段，要求主键字段内容不能为null同时也不能出现重复值4.外键约束:管理外键字段，要求外键字段的值应该来自于关联的一方表中主键字段的值 但是可以存储null值LTER TABLE 多方表ADD CONSTRAINT 外键约束对象名 foreign key(外键字段名)REFERENCES 一方表(主键字段名) 十一:index索引123456789101112131415161718191.索引作用： 在表文件数据行增加时候，不会大幅度降低查询语句执行效率2.索引工作原理 索引工作原理，事先将字段中内容进行排序，在WHERE 命令进行定位时，避免对表中所有的数据行进行遍历 将会提升查询速度 3.索引管理:1)将字段内容交给某个索引进行管理 create index 索引名 on 表名（字段）2)查询表文件关联的索引 show index from 表名 ***在为表文件绑定【主键约束】，【唯一性约束】，【外键约束】时 mysql服务器自动将当前字段数据进行排序并交给指定索引管理 3）删除表文件指定索引 DROP INDEX 索引名 ON 表名 十二:explain执行计划12345678910111213141516171819202122232425262728291.命令格式: explian 查询语句2.命令作用： 展示当前查询得到结果是否通过索引来进行定位 DBA通过执行计划了解在本次查询过程，是否使用预先创建好的索引3.执行计划对于查询语句执行效率判断 1）在执行计划中，通过type属性展示查询语句执行效率 2）执行效率分类:[慢----快]ALL：WHERE对表文件所有数据行进行遍历，才得到了查询结果 这种级别查询语句，随着数据行增加导致执行速度大幅度 降低(DBA来说，极力避免这种级别查询)type:WHERE对表文件所有数据行进行遍历，只不过在SELECT 抓取字段内容时，从索引中抓取。 这种级别虽然在抓取数据速度有所提升，但是依然面对 随着数据行增加导致执行速度大幅度（DBA来说，极力避免这种级别查询）range:WHERE不会对表文件数据行进行遍历，而是直接从索引得到 定位的数据行行数，将大幅度提升查询效率。 这是DBA进行SQL优化时要保证最低级别。但是这种级别存在[不稳定性] 当字段内容发生变化时，导致索引失效 ref: WHERE不会对表文件数据行进行遍历，而是直接从索引得到 定位的数据行行数,同时在这种情况根据定位条件一次只能 得到一个数据行，属于比较稳定执行效率.DBA努力达到的优化程度const: 根据主键字段上索引进行定位，是执行效率最快的。但是 在实际使用过程中，几乎不会被用到的。 十三:view视图123456789101112131415161718191.定义： 是MySql服务器中一个对象，用于存储查询语句。 目的提供查询语句使用效率，避免在多处地方 重复性开发相同查询语句 2.命令： 1）将查询语句交给一个视图对象管理 CREATE VIEW 视图对象名 AS 查询语句 2）通过视图对象调用管理查询语句 select * from 视图对象名3.额外功能： 视图对象存储一个查询语句，同时视图对象拥有对当前查询语句关联的表文件操作能力 1）通过视图对象对关联表文件数据行进行插入 2）通过视图对象对关联表文件数据行进行删除 3）通过视图对象对关联表文件数据行进行更新 4.视图作用：【面试】 1）提高了查询语句复用性，避免了在多处地方重复进行查询语句开发行为 2）隐藏业务中涉及表关系，开发人员通过视图进行操作时是不会知道其具体 操作的表 十四:存储引擎123456789101112131415161718192021222324252627282930313233341.定义： 是MySql服务器对应表文件内容管理方式。目前MySql服务器主要采用 INNODB,MyIsam2.管理命令: 1)查看MySql服务器支持存储引擎种类 show engines; 2)修改MySql服务器默认存储引擎 C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\\my.ini下 default-storage-engine=INNODB 进行修改 myIsam 3)设置表文件依赖存储引擎 show create table 表名； alter table 表名 engine=存储引擎3.MyIsam存储引擎特征: 1.在对表文件内容进行修改时，不会进行备份操作。 提高操作执行效率，但是在操作完毕后无法取消本次操作 2.MyIsam存储引擎 使用三个文件存储表文件信息 test1.frm : 存储表文件字段信息 test1.myd : 存储表文件数据行信息 test1.myi : 存储表文件字段关联的索引信息4.INNODB存储引擎: 1.在对表文件内容进行修改时，首先进行一次备份。 在进行操作，因此执行效率相对较慢。 但是在执行完毕后，由于有备份存在，可以使用 备份取消当前操作，增加数据安全性 2.INNODB存储引擎，使用一个文件存储表文件信息 test1.frm: 存储表文件字段信息 存储表文件数据行信息 存储表文件字段关联的索引信息 十五:事务(transaction)==事务—-&gt;备份== 123456789101112131.介绍： 事务是MySql服务器提供一个管理对象，用于对当前表文件备份进行管理2.使用: start transaction; #通知MySql服务器提供一个事务对象，这个事务对象对接下来操作产生所有备份进行管理 delete from emp where deptno=30 # 生成emp.bak delete from dept where deptno=30 #声明dept.bak rollback; #通知mysql服务器将本次操作中所有备份信息覆盖到表文件，来取消本次操作 commit; #通知mysql服务器将本次操作中生成所有备份信息进行删除，称之为提交操作","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"MayBatis","slug":"MayBatis","date":"2020-10-15T13:40:48.433Z","updated":"2020-10-15T07:24:56.633Z","comments":true,"path":"2020/10/15/MayBatis/","link":"","permalink":"http://example.com/2020/10/15/MayBatis/","excerpt":"","text":"第一章:框架概述:1.回顾JDBC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void findStudent() &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; //注册 mysql 驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //连接数据的基本信息 url ，username，password String url = &quot;jdbc:mysql://localhost:3306/springdb&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //创建连接对象 conn = DriverManager.getConnection(url, username, password); //保存查询结果 List&lt;Student&gt; stuList = new ArrayList&lt;&gt;(); //创建 Statement, 用来执行 sql 语句 stmt = conn.createStatement(); //执行查询，创建记录集， rs = stmt.executeQuery(&quot;select * from student&quot;); while (rs.next()) &#123; Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); //从数据库取出数据转为 Student 对象，封装到 List 集合 stuList.add(stu); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; //关闭资源 if (rs != null) ; &#123; rs.close(); &#125; if (stmt != null) &#123; stmt.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 第二章:MyBatis框架快速入门1环境搭建1.1:加入pom.xml依赖123456789101112131415161718192021222324&lt;dependencies&gt; 加入junit依赖: &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; 加入mabtis依赖 &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 加入mysql依赖 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2:加入maven插件123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt; &lt;includes&gt;&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 1.3编写 Dao 接口 Mapper 映射文件 StudentDao.xml要求： 在 dao 包中创建文件 StudentDao.xml 要 StudentDao.xml 文件名称和接口 StudentDao 一样，区分大小写的一样。 StudentDao.xml配置: 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace ：必须有值，自定义的唯一字符串 推荐使用： dao 接口的全限定名称 --&gt; &lt;mapper namespace=&quot;com.bjpowernode.dao.StudentDao&quot;&gt; &lt;!-- &lt;select&gt;: 查询数据， 标签中必须是 select 语句 id: sql 语句的自定义名称，推荐使用 dao 接口中方法名称， 使用名称表示要执行的 sql 语句 resultType: 查询语句的返回结果数据类型，使用全限定类名 --&gt; &lt;select id=&quot;selectStudents&quot;resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; &lt;!-要执行的 sql 语句 --&gt; select id,name,email,age from student &lt;/select&gt; &lt;/mapper&gt; 1.4:创建 MyBatis 主配置文件项目 src/main 下创建 resources 目录，设置 resources 目录为 resources root 创建主配置文件：名称为 mybatis.xml 说明：主配置文件名称是自定义的，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--settings：控制mybatis全局行为--&gt; &lt;settings&gt; &lt;!--设置mybatis输出日志--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!--定义别名--&gt; &lt;typeAliases&gt; &lt;!-- 第一种方式： 可以指定一个类型一个自定义别名 type:自定义类型的全限定名称 alias:别名（短小，容易记忆的） --&gt; &lt;!--&lt;typeAlias type=&quot;com.bjpowernode.domain.Student&quot; alias=&quot;stu&quot; /&gt; &lt;typeAlias type=&quot;com.bjpowernode.vo.ViewStudent&quot; alias=&quot;vstu&quot; /&gt;--&gt; &lt;!-- 第二种方式 &lt;package&gt; name是包名， 这个包中的所有类，类名就是别名（类名不区分大小写） --&gt; &lt;package name=&quot;com.bjpowernode.domain&quot;/&gt; &lt;package name=&quot;com.bjpowernode.vo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-配置 mybatis环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!--id: 数据源的名称 --&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!--配置事务类型：使用 JDBC 事务（使用 Connection的提交和回滚） --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 数据源 dataSource ：创建数据库 Connection对象 type: POOLED 使用数据库的连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-连接数据库的四个要素 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-告诉 mybatis 要执行的 sql 语句的位置 --&gt; &lt;mapper resource=&quot;com/bjpowernode/dao/StudentDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2.基本的CURD2.1: MyBatisUtils.java12345678910111213141516171819202122232425public class MyBatisUtils &#123; private static SqlSessionFactory factory = null; static &#123; String config=&quot;mybatis.xml&quot;; // 需要和你的项目中的文件名一样,放在resource目录下面 try &#123; InputStream in = Resources.getResourceAsStream(config); //创建SqlSessionFactory对象，使用SqlSessionFactoryBuild factory = new SqlSessionFactoryBuilder().build(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取SqlSession的方法 public static SqlSession getSqlSession() &#123; SqlSession sqlSession = null; if( factory != null)&#123; sqlSession = factory.openSession();// 非自动提交事务 &#125; return sqlSession; &#125;&#125; 2.2: mapper中传参方式方式2.2.0:一个简单的参数12345678Dao 接口中方法的参数只有一个简单类型（java 基本类型和 String），占位符 #&#123; 任意字符 &#125;，和方 法的参数名无关。 接口方法： Student selectById(int id); mapper 文件：&lt;select id=&quot;selectById&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name,email,age from student where id=#&#123;studentId&#125;&lt;/select&gt; 2.2.1: parameterTyp12345678910111213141516&lt;!-- parameterType ： dao接口中方法参数的数据类型。 parameterType它的值是java的数据类型全限定名称或者是mybatis定义的别名 例如：parameterType=&quot;java.lang.Integer&quot; parameterType=&quot;int&quot; 注意：parameterType不是强制的，mybatis通过反射机制能够发现接口参数的数类型。 所以可以没有。 一般我们也不写。--&gt; 1. &lt;select id=&quot;selectStudentById&quot; parameterType=&quot;int&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name, email,age from student where id=$&#123;studentId&#125; &lt;/select&gt; 2.2.2: 多个参数,使用@Param(“自定义参数名称”)123456789101112/** * 多个参数： 命名参数，在形参定义的前面加入 @Param(&quot;自定义参数名称&quot;) */接口方法: List&lt;Student&gt; selectMultiParam(@Param(&quot;myname&quot;) String name, @Param(&quot;myage&quot;) Integer age);mapper 文件：&lt;!--多个参数，使用@Param命名--&gt; &lt;select id=&quot;selectMultiParam&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name, email,age from student where name=#&#123;myname&#125; or age=#&#123;myage&#125; &lt;/select&gt; 2.2.3: 使用引用java对象类型做参数1234567891011121314151617&lt;!--多个参数， 使用java对象的属性值，作为参数实际值 使用对象语法： #&#123;属性名,javaType=类型名称,jdbcType=数据类型&#125; 很少用。 javaType:指java中的属性数据类型。 jdbcType:在数据库中的数据类型。 例如： #&#123;paramName,javaType=java.lang.String,jdbcType=VARCHAR&#125; 我们使用的简化方式： #&#123;属性名&#125; ，javaType, jdbcType的值mybatis反射能获取。不用提供 --&gt;接口方法:List&lt;Student&gt; selectMultiStudent(Student student);mapper 文件：&lt;select id=&quot;selectMultiStudent&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name, email,age from student where name=#&#123;name&#125; or age=#&#123;age&#125; &lt;/select&gt; 2.2.4: 按照位置1234567891011121314/** * 多个参数-简单类型的，按位置传值， * mybatis.3.4之前，使用 #&#123;0&#125; ，#&#123;1&#125; * mybatis。3.4之后 ，使用 #&#123;arg0&#125; ,#&#123;arg1&#125; */接口方法:List&lt;Student&gt; selectMultiPosition( String name,Integer age);mapper 文件:&lt;!--多个参数使用位置--&gt; &lt;select id=&quot;selectMultiPosition&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name, email,age from student where name = #&#123;arg0&#125; or age=#&#123;arg1&#125; &lt;/select&gt; 2.2.5: 多个参数，使用Map存放多个值12345678910111213141516171819202122232425接口方法:List&lt;Student&gt; selectMultiByMap(Map&lt;String,Object&gt; map);mapper 文件:&lt;!--多个参数，使用Map , 使用语法 #&#123;map的key&#125;--&gt; &lt;select id=&quot;selectMultiByMap&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name, email,age from student where name = #&#123;myname&#125; or age=#&#123;age1&#125; &lt;/select&gt; public void testSelectMultiByMap()&#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); Map&lt;String,Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;myname&quot;,&quot;张三&quot;); data.put(&quot;age1&quot;,28); List&lt;Student&gt; students = dao.selectMultiByMap(data); for(Student stu: students)&#123; System.out.println(&quot;学生=&quot;+stu); &#125; sqlSession.close(); &#125; 第三章:Dao代理实现CURD3.1: 步骤3.1.1:StudentDao 接口中增加方法1int insertStudent(Student student); 1int updateStudent(Student student); 1int deleteStudent(int id); 3.1.2: StudentDao.xml 加入 sql 语句12多个参数， 使用java对象的属性值，作为参数实际值我们使用的简化方式： #&#123;属性名&#125; ，javaType, jdbcType的值mybatis反射能获取。不用提供 1234&lt;insert id=&quot;insertStudent&quot;&gt; insert into student(id,name,email,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;) &lt;/insert&gt; 123&lt;update id=&quot;updateStudent&quot;&gt; update student set age = #&#123;age&#125; where id=#&#123;id&#125; &lt;/update&gt; 123&lt;delete id=&quot;deleteStudent&quot;&gt; delete from student where id=#&#123;studentId&#125; &lt;/delete&gt; 3.1.3增加测试方法 (动态代理)123456789101112//使用mybatis的动态代理机制， 使用SqlSession.getMapper(dao接口)// getMapper能获取dao接口对于的实现类对象。 SqlSession sqlSession = MyBatisUtils.getSqlSession();StudentDao dao = sqlSession.getMapper(StudentDao.class);//com.sun.proxy.$Proxy2 : jdk的动态代理 System.out.println(&quot;dao=&quot;+dao.getClass().getName()); //调用dao的方法， 执行数据库的操作 List&lt;Student&gt; students = dao.selectStudents(); for(Student stu: students)&#123; System.out.println(&quot;学生=&quot;+stu); &#125; 3.2封装MyBatis输出结果:3.2.1: resultTyperesultType: 执行 sql 得到 ResultSet 转换的类型，使用类型的完全限定名或别名。 注意如果返回的是集 合，那应该设置为集合包含的类型，而不是集合本身。resultType 和 resultMap，不能同时使用。 3.2.2: 简单类型12345678910111213接口方法： int countStudent();mapper 文件： &lt;select id=&quot;countStudent&quot; resultType=&quot;int&quot;&gt; select count(*) from student &lt;/select&gt; 测试方法： @Test public void testRetunInt()&#123; int count = studentDao.countStudent(); System.out.println(&quot;学生总人数：&quot;+ count);&#125; 3.2.3:对象类型1234567接口方法： Student selectById(int id); mapper 文件：&lt;select id=&quot;selectById&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select id,name,email,age from student where id=#&#123;studentId&#125;&lt;/select&gt; 3.2.4:Mapsql 的查询结果作为 Map 的 key 和 value。推荐使用 Map&lt;Object,Object&gt;。 注意：Map 作为接口返回值，sql 语句的查询结果最多只能有一条记录。大于一条记录是错误。 1234567891011121314接口方法： Map&lt;Object,Object&gt; selectReturnMap(int id);mapper 文件： &lt;select id=&quot;selectReturnMap&quot; resultType=&quot;java.util.HashMap&quot;&gt; select name,email from student where id = #&#123;studentId&#125;&lt;/select&gt; 测试方法： @Test public void testReturnMap()&#123; Map&lt;Object,Object&gt; retMap = studentDao.selectReturnMap(1002); System.out.println(&quot;查询结果是 Map:&quot;+retMap);&#125;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Linux","slug":"Linux","date":"2020-10-15T13:40:48.430Z","updated":"2020-10-15T07:24:52.294Z","comments":true,"path":"2020/10/15/Linux/","link":"","permalink":"http://example.com/2020/10/15/Linux/","excerpt":"","text":"一:linux的目录1). linux只有一个根目录 / 2). 层级式的目录结构 ==bin== –&gt;usr/bin : 系统的可执行文件,可以在任何目录下执行 ==usr/local/bin== : 用户自己的可执行文件,可以在任何目录下执行 ==etc== : 存放系统管理所需要的配置文件,配置环境变量(/etc/profile) ==home== : 每一个用户的根目录 ==opt== : 存放额外安装的软件,相当于windows系统中的Program files目录 二:linux的远程操作1).Xshell : linux的终端模拟软件 安装并破解 : 解压,破解(运行两个.bat文件),启动(Xshell) 连接远程linux系统:建立会话: SSH协议,默认端口号是22 查看linux系统的ip地址: ==ifconfig== 三:vimvi和vim：是linux中的文本编辑器，用来在linux中创建、查看或者编辑文本文件，就好像windows中的记事本一样。vim是vi的增强版本，vi的绝大多数用法在vim都适用。 创建目录: mkdir 查看: ls 切换: cd 创建文件: vim 文件名 123456789101112131415161718192021222324vi和vim的使用：一般模式：用vi或者vim命令打开文件(vim test.txt)，进入了一般模式； 可以查看文件的内容，并且可以通过上下左右键移动光标，查看文件某一部分； 但是不能编辑文件内容。编辑模式：按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可,在一般模式下，按i 键或者a键，进入编辑模式；可以编辑文件内容；但是不能保存编辑的内容； 按Esc键，可以回到一般模式。 命令行模式：在一般模式下，按shift+:，进入命令行模式； 输入： q!-----不保存强制退出编辑器 wq-----保存并且退出编辑器 q------只是退出编辑器vi和vim编辑器的快捷键： 1)复制当前行：在一般模式下，按yy，把光标所在行复制到剪切板 按p，把剪切板中的内容粘贴到光标所在的下一行。 2)复制当前行往下5行：在一般模式下，按5yy，把光标所在行往下5行复制到剪切板 按p，把剪切板中的内容粘贴到光标所在的下一行。 3)在文本文件中查找关键字：在命令行模式下，输入/关键字，回车 按n表示光标查找下一个关键字 4)删除光标所在的当前行：在一般模式下，按dd，删除光标所在的当前行 5)删除光标所在的行往下5行：在一般模式下，按5dd 6)撤销上次编辑的内容：在一般模式下，按u 7)显示行号：命令行模式下，设置文件的行号，取消文件的行号.[命令行下(: set nu) 和(:set nonu)] 四:Linux用户管理1234567891011121314151617181920211)、任何使用linux的系统资源的用户，必须使用一个合法的账号和密码，账号和密码一般都是向系统管理员申请。 root是linux系统安装时默认创建的系统管理员账号，由root创建普通账号。 2)、添加用户：useradd [选项] 用户名 useradd lisi |-&gt;创建一个用户lisi |-&gt;在/home目录下创建用的根目录，目录名称默认跟用户名相同 |-&gt;在linux中任何一个用户都至少属于一个组，新建用户时如果不指定组，则会新建一个组，组名跟用户名相同， 并且把该用户添加到该组中。 useradd -d /home/ww wangwu 创建用户的同时，指定用户的根目录 3)、给用户设置密码:passwd 用户名 passwd lisi *密码要满足一定的复杂度 4)、删除用户：userdel 用户名 userdel lisi userdel -r lisi 删除用户的同时级联删除它的主目录 5)、查看用户信息：id 用户名 id zhangsan 6)、切换用户：su 用户名 su zhangsan *从权限高的用户切换权限低的用户，不需要密码验证； 从权限低的用户切换到权限高的用户，必须密码验证。 五:linux中的组管理123456789101112131)、linux中的组相当于角色的概念，可以对有共性的用户进行统一管理； 每一个用户至少属于一个组，不能独立于组存在，也可以属于多个组； 新建用户时如果不指定组，则会新建一个组，组名跟用户名相同，并且把该用户添加到该组中。2)、添加组：groupadd 组名 groupadd dev3)、删除组：groupdel 组名 groupdel dev4)、把用户添加到组中：gpasswd -a 用户名 组名 (-a add) gpasswd -a zhangsan dev5)、把用户从组中移除：gpasswd -d 用户名 组名 (-d delete) gpasswd -d zhangsan dev6)、添加用户时，指定所属的组(主组)：useradd -g 组名 用户名 (-g group) useradd -g dev lisi 六:Linux中的系统操作命令12345关机：shutdown now 立即关机 shutdown -h xxx 定时关机 shutdown -r now 立即重启重启：reboot 立即重启同步数据库：sync 七:linux中的帮助命令 1)、用来查看linux系统手册上的帮助信息：man 命令man ls分屏显示、按回车翻一行、按空格翻一页、按q退出查看。2)、用来查看命名的内置帮助信息：help 命令help cd 八:linux文件和目录操作 1)、查看当前所在目录：pwdpwd2)、查看指定目录下所有的子目录和文件列表：ls [选项] [指定目录]ls /homels 查看当前目录下所有的子目录和文件列表 ls -l /home ：以列表形式显示 (-l是list缩写) ls -a /home：显示指定目录下所有的子目录和文件(包括虚拟的目录)ls -al /home:以列表形式显示指定目录下所有的子目录和文件(包括虚拟的目录) 3)、切换目录：cd 目录名绝对目录：以盘符开始的目录叫绝对目录，从盘符开始查找目标目录cd /opt/testDir~：当前用户的根目录。在任何目录下执行:cd ~，进入当前用户的根目录。相对目录：以目录名开始的目录叫相对目录，从当前目录开始查找目标目录cd testDir.. –&gt;当前目录的上一级目录，从的当前目录开始查找它的上一级目录。. –&gt;当前目录xxx.sh====&gt;./xxx.sh 4)创建目录：mkdir [选项] 目录名绝对目录相对目录mkdir /opt/testDir/test1 //在/opt/testDir目录下创建一个目录test1(使用绝对目录)mkdir test2 //在/opt/testDir目录下创建一个目录test2(使用相对目录) mkdir -p /opt/testDir/test3/test4 //在/opt/testDir目录下创建目录test3,并且在test3下创建test4(一次创建多级目录)mkdir -p test5/test6 5)、删除一个空目录：rmdir 目录名rmdir test1rmdir test36)、创建一个或者多个空文件：touch 文件名列表(文件名之间用空格隔开)touch t1.txttouch t2.txt t3.txt t4.txt 7)、复制文件或者目录：cp [选项] source(源) dest(目标)cp t1.txt test2 //把t1.txt文件复制到test2目录中cp -r test2 test5 //把test2目录复制到test5目录中(递归地复制目录) cp t1.txt test2 8)、删除文件或者目录：rm 文件名或者目录名rm t1.txt 提示删除文件rm -f t2.txt 强制删除文件 rm -r test2 提示递归删除目录​ rm -rf test5 强制递归删除目录 9)、移动目录或者文件：mv source(源) dest(目标)mv test.txt test1mv test1 test2 mv t3.txt t3_new.txt 文件重命名*如果目标中已经存在该文件或者目录，则会提示是否覆盖。 10)、查看文件内容：cat 文件名文件内容一次性显示出来。cat t4.txtcat -n t4.txt 显示行号11)、分页查看文件文件内容：more 文件名 一次性加载文件所有内容到内存，分页显示按回车翻一行、按空格翻一页more t4.txt12)、分页查看文件文件内容：less 文件名 分页加载文件所有内容到内存，分页显示less t4.txt按回车翻一行、按空格翻一页，按q退出查看13)、查看文件的头10行：head [选项] 文件名(默认查看文件头10行内容)head t4.txthead -n 5 t4.txt14)、查看文件的后10行：tail [选项] 文件名(默认查看文件尾10行内容)tail t4.txttail -n 5 t4.txt 5)、echo：输出系统变量或者常量的值到命令行终端。echo $JAVA_HOMEecho $PATH echo Hello World! —-&gt;输出控制台上Hello World! 类似windows中的配置环境变量 JAVA_HOME=D:\\DPFS\\Java\\jdk1.8.0_101​ PATH=%JAVA_HOME%\\bin;…….​ CLASSPATH=%JAVA_HOME%\\lib;. 16)把前一个查看命令的结果输出到指定的文件中： 查看命令 &gt; 文件名*如果目标文件不存在,则新建一个文件*如果目标文件已存在，则把文件以前的内容覆盖 ls &gt; ret.txt​ ls -al &gt; ret.txt​ cat ret.txt &gt; t3_new.txt 文件内容的复制​ cat t4.txt &gt; t3_new.txt 17)把前一个查看命令的结果追加输出到指定的文件中：查看命令 &gt;&gt; 文件名*如果目标文件不存在,则新建一个文件*如果目标文件已存在，则在文件原来内容的基础上进行追加 ls &gt; ret.txt​ ls -al &gt;&gt; ret.txt​ cat t4.txt &gt;&gt; ret.txt 九:关于日期和时间 1)、查看或者设置系统的日期或者时间：datedate 查看系统当前的完整的日期和时间date +%Y 系统当前的年份date +%m 系统当前的月份date +%d 系统当前的日期 date ‘+%Y-%m-%d %H:%M:%S’ 按yyyy-MM-dd HH:mm:ss格式显示 date -S ‘2020-10-20 10:20:30’ 设置当前的系统时间2)、查看系统日历：calcal：查看当前月份的日历cal 2020：查看指定年份的日历 十:搜索文件和目录 1)find [搜索范围][搜索标准] 关键字-name：默认按名称搜索(文件或者目录所在的路径也在搜索范围之内)-size：按文件大小搜索-user：按文件的所有者搜索find *.txt 搜索当前目录下，所有的.txt文件finde* 搜索当前目录下，所有名称中包含e的那些文件或者目录 find /etc *.txt 搜索/etc目录下所有.txt文件 find /etc -size -5k 搜索/etc目录下所有小于5k的文件 find /etc -size +5k 搜索/etc目录下所有大于5k的文件 find /etc -user zhangsan 搜索/etc目录下所有的所有者是zhangsan的文件和目录 2)locate:在整棵目录树中搜索文件或者目录，都是根据名称搜索，效率高。updatedb —&gt;跟新目录树的数据库,可以及时更新locate 关键字 updatedb​ locate *.txt 3)搜索过滤命令，在前一个搜索命令的结果中进行按名称进一步过滤： 搜索命令 |grep [选项] 过滤条件​ 查看命令 |grep [选项] 过滤条件​ find *.txt|grep new 搜索当前目录下，所有名称包含new的.txt文件​ find /etc -size -5k|grep firefox cat t1.txt|grep beijing 搜索t1.txt目录下包含bejing关键字的内容​ cat t1.txt|grep -ni beijing (-i 忽略大小写,i就是ignore,-n显示行号) ls -al|grep new (搜索包含new的文件) 十一:压缩与解压 1)、压缩或者解压单个文件： gzip 文件名：压缩单个文件，生成一个.gz的压缩包，并且会把原来的文件删除。​ gunzip .gz压缩包名:解压.gz压缩包，并且会把原来的.gz压缩包删除。 gzip ret.txt​ gunzip ret.txt.gz 2)、压缩(打包)或者解压多个文件和目录： zip 目标压缩包名称(通常使用.zip压缩包) 文件或者目录列表：​ unzip 压缩包名(.zip) -d 解压目录名：将指定的.zip压缩包解压到当前目录(或者指定目录)。(-d direct直接) zip test.zip ret.txt t1.txt test2 (把 ret.txt t1.txt test2这三个文件打包到test.zip包中)​ unzip test.zip -d test3 zip mytest.zip test.zip t3_new.txt t4.txt test2 3)、压缩(打包)或者解压多个文件和目录：tar [选项] 目标压缩包名称(xxx.tar.gz) 文件或者目录列表——&gt; c：打包或者压缩tar [选项] 压缩包名(xxx.tar.gz) -C 解压目录名：将指定的.tar.gz压缩包解压到当期目录(或者指定目录)——&gt;x: 解压tar -zcvf xxx.tar.gz 文件或者目录列表tar -zxvf xxx.tar.gz -C 解压目录名 tar -zcvf mytar.tar.gz mytest.zip ret.txt t1.txt test2​ tar -zxvf mytar.tar.gz -C /opt/testDir/test5 -c：产生.tar.gz打包文件 -v：显示详细信息 -f：指定压缩后的文件名 -z：打包同时压缩 -x：解压.tar.gz文件 -C: 指定解压到哪个目录 十二:文件或目录与组 1)文件或者目录与组基本介绍:在linux中,每一个用户都至少属于一个组，用户不能独立于组存在，一个用户可以属于多个组。 在linux中，每一个文件或者目录也必须属于一个组，而且只能属于一个组，默认情况下，文件所有者所属的主组就是文件所属的组；​ 文件或者目录通过组来控制哪些用户可以对它进行哪些操作，即文件或者目录的访问权限;​ 在文件或者目录看来，linux系统中所有的用户分为三类：​ 所有者：默认情况下，文件或者目录的所有者都是创建者，可以修改​ 同组用户：跟文件或者目录属于同一个组的用户​ 其它组用户：既不是文件或者目录的所有者，也不是同组用户2)查看文件的所有者和所在的组：​ ls -l3)、修改文件或者目录的所有者：chown 新的所有者 文件名或者目录名​ chown 新的所有者:新的组 文件名或者目录名chown zhangsan t1.txt —-&gt;将t1.txt文件的所有者改为zhangsanchown zhangsan test3 —–&gt;将test3目录所属者改为zhangsan,不改变目录下面的文件的所属chown zhangsan:dev t4.txt ——&gt;将t4.txt文件的所有者改为zhangsan,所属的组改为dev chown zhangsan:dev test2chown -R zhangsan:dev test2 递归修改目录的所有者和所在的组 ,-R意为递归4)、修改文件或者目录的所在组：chgrp 新的组 文件名或者目录名chgrp dev t2.txtchgrp -R dev test3 十三:文件或者目录的权限管理 1)准备工作：一个用户至少属于一个组，也可以属于多个组；一个文件或者目录也必须属于一个，并且只能属于一个组；在一个文件或者目录看来，linux系统中所有的用户可以分为三类：所有者：同组用户：其它组用户：2)、文件或者目录的三种权限：在linux中，任何文件或者目录都有三种权限：读(Read)、写(Write)、执行(Execute)对于文件而言:读：可以读取、查看文件的内容， 比如：cat、more、less、head、tail等。写：可以修改文件的内容，比如：vi或者vim等执行：如果该文件是可执行文件(.sh)，可以直接运行，比如：./xxx.sh。对于目录而言：读：可以读取、查看目录下边的内容，比如：ls等写：可以修改目录中的内容，创建子目录、删除子目录、创建文件、删除文件、重名文件或者目录执行：可以进入该目录， 比如：cd等。 3)、文件或者目录的权限控制：在linux中，任何一个文件或者目录都有三部分权限：所有者权限、同组用户权限、其它组用户权限。第一部分权限：所有者权限，文件或者目录的所有者对该文件所拥有的权限，使用r、w、x分表表示读、写、执行的权限。比如：rwx：拥有读写执行的权限，r-x：拥有读和执行的权限，r–：只拥有读的权限，—：没有任何权限。第二部分权限：同组用户权限，文件或者目录的同组用户对该文件所拥有的权限，使用r、w、x分表表示读、写、执行的权限。第三部分权限：其它组用户权限，文件或者目录的其它组用户对该文件所拥有的权限，使用r、w、x分表表示读、写、执行的权限。4)、查看文件或者目录的权限：ls -aul5)、修改文件或者目录的权限：chmod用r、w、x分辨表示读、写、执行的权限，用u、g、o、a分别表示给所有者、同组用户、其它组用户、所有用户修改权限用+、-、=分别表示给指定的用户增加、减少、设置对应的权限 chmod g-w,o+w t5.txt​ chmod g=rwx t5.txtchmod a-r t5.txt 6)、使用数字的方式修改文件或者目录的权限：每一个权限可以用一个数字来表示：r、w、x4、2、12^2 2^1 2^0每一个文件或者目录都有三部分权限，每一部分权限都可以用一组数据之和来表示，三部分权限就是一组三个数据序列：rw- r-x r-x6 5 5 -rwx r-x -wx —&gt;第一位 - 意思是文件,第一位是d表示目录753：rwxrwxrwx 777: chmod 777 t5.txtchmod 753 t5.txt 十四:网络管理 在linux的配置文件： vi /etc/sysconfig/network-scripts/ifcfg-ens33 BOOTPROTO=”static”ONBOOT=”yes”IPADDR=192.168.11.128 ip地址GATEWAY=192.168.11.2 网关DNS=192.168.11.2 DNS和网关保持一致 改好后重启linux: reboot 十五:进程管理 线程：一个程序的线路进程：一个程序的执行，一个进程占用一个端口。 查看正在运行的进程：ps —-&gt;process statusps //只会显示应用进程ps -e //显示所有进程ps -ef //以全格式的形式显示所有进程//用于查看linux系统中某一些软件或者应用是否处于启动状态 ps -ef|grep mysql 关闭进程：使用ps命令查看进程的PID使用命令kill -9 PID 十六:服务进程 1)、服务介绍：服务是支持Linux运行的一些必要程序，本质上也是进程，叫守护进程。2)、操作服务：systemctl [start|stop|restart|reload|status|enable] 服务名称systemctl status firewalld 查看防火墙运行状态systemctl stop firewalld 关闭防火墙systemctl start firetalld 开启防火墙systemctl enable firewalld 设置防火墙开机启动 *老版的linux或者有些发行版本的linux，操作服务使用service命令。 十七:软件安装包 1)、RPM包管理：a)RPM：一种LInux的软件包的打包和安装工具，它操作的软件包都是.rpm结尾。b)使用RPM：rpm命令。 查看当前系统中已经安装的rpm软件包：rpm -qa|grep firefox —–&gt;qa就是query all npm选项说明: -i = install 安装 -v = verbose 提示 -h = hash 进度条 卸载rpm软件包：rpm -e firefox安装rpm包：rpm -ivh xxx.rpmcp firefox-45.4.0-1.el7.centos.x86_64.rpm /optrpm -ivh firefox-45.4.0-1.el7.centos.x86_64.rpm2)、YUM包管理：是一种基于RPM的软件包管理工具，它能够从指定服务器上自动下载RPM包并且自动安装，可以自动处理软件包之间的依赖关系。查看当前系统中已经安装的rpm软件包：yum list installed|grep firefox卸载rpm软件包：yum remove firefox.x86_64安装rpm包：yum install firefox","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JSP","slug":"JSP","date":"2020-10-15T13:40:48.427Z","updated":"2020-10-15T07:24:48.806Z","comments":true,"path":"2020/10/15/JSP/","link":"","permalink":"http://example.com/2020/10/15/JSP/","excerpt":"","text":"1.执行命令123456&lt;% %&gt;叫做脚本片段，其中写的内容会翻译在Servlet的Service方法中，显然我们可以在Service方法中定义局部变量或者调用其他方法，但是不能在Service中再定义其他的方法，也就是我们可以在&lt;%%&gt;中定义局部变量或者调用方法，但不能定义方法。在jsp页面可以有多个脚本片段，但是多个脚本片段之间要保证结构完整。&lt;% //只有书写在执行标记中的内容才会被当作java命令%&gt;相当于java中的代码 2输出12345678910111213&lt;% int num1 =100; int num2 =200;%&gt;&lt;!--在JSP文件，通过输出标记，通知JSP将Java变量的值写入到响应体--&gt;变量num1的值:&lt;%=num1%&gt;&lt;br/&gt;变量num2的值:&lt;%=num2%&gt;&lt;br/&gt;&lt;!--执行标记还可以通知Jsp将运算结果写入到响应体--&gt;num1 + num2 = &lt;%=num1+num2%&gt;&lt;%=%&gt;称作jsp表达式，用于将已经声明的变量或者表达式输出到网页上面。 举例: 12345678910111213141516171819202122232425262728293031&lt;% Student stu1 = new Student(10,&quot;mike&quot;); Student stu2 = new Student(20,&quot;allen&quot;); Student stu3 = new Student(30,&quot;smith&quot;); List&lt;Student&gt; list = new ArrayList(); list.add(stu1); list.add(stu2); list.add(stu3);%&gt;&lt;!--数据输出--&gt;&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;学员编号&lt;/td&gt; &lt;td&gt;学员姓名&lt;/td&gt; &lt;/tr&gt; &lt;% for(Student stu:list)&#123; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=stu.getSid()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=stu.getSname()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt;&lt;/table&gt;普通的就相当于 out.ptint(&lt;/table&gt;);都是在前面加了这out.print() 三:JSP文件的内置对象1.request1234567891011121314151617&lt;!-- JSP文件内置对象: request 类型：HttpServletRequest 作用: 在JSP文件运行时读取请求包信息 与Servlet在请求转发过程中实现数据共享 浏览器： http://localhost:8080/myWeb/request.jsp?userName=allen&amp;password=123--&gt;&lt;% //在JSP文件执行时，借助于内置request对象读取请求包参数信息 String userName = request.getParameter(&quot;userName&quot;); String password =request.getParameter(&quot;password&quot;);%&gt;来访用户姓名:&lt;%=userName%&gt;&lt;br/&gt;来访用户密码:&lt;%=password%&gt; 2.session123456789101112131415161718192021222324251.session_1.jsp&lt;!-- JSP文件内置对象:session 类型:HttpSession 作用：JSP文件在运行时，可以session指向当前用户私人储物柜，添加 共享数据，或则读取共享数据--&gt;&lt;!--将共享数据添加到当前用户私人储物柜--&gt;&lt;% // HttpSession session = request.getSession(); session.setAttribute(&quot;key1&quot;, 200);%&gt;2.session_2.jsp&lt;!-- session_1.jsp 与 session_2.jsp为同一个用户/浏览器提供服务。 因此可以使用当前用户在服务端的私人储物柜进行数据共享 --&gt;&lt;% Integer value=(Integer) session.getAttribute(&quot;key1&quot;);%&gt;session_2.jsp从当前用户session中读取数据:&lt;%=value%&gt; 3.ServletContext123456789101.application.jsp:&lt;!-- ServletContext application;全局作用域对象 同一个网站中Servlet与JSP，都可以通过当前网站的全局作用域对象实现数据共享 JSP文件内置对象 ： application--&gt;&lt;% application.setAttribute(&quot;key1&quot;, &quot;hello world&quot;);%&gt; 123456789102.oneServlet:public class OneServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext application = request.getServletContext(); String value = (String)application.getAttribute(&quot;key1&quot;); System.out.println(&quot;value = &quot;+value); &#125;&#125; 四:servlet和jsp的联合调用123456789101112131415一。Servlet 与 JSP 分工: Servlet： 负责处理业务并得到【处理结果】--------------------大厨 JSP： 不负责业务处理，主要任务将Servlet中【处理结果】写入到响应体----传菜员二。Servlet 与 JSP 之间调用关系 Servlet工作完毕后，一般通过请求转发方式 向Tomcat申请调用JSP三。Servlet 与 JSP 之间如何实现数据共享 Servlet将处理结果添加到【请求作用域对象】 JSP文件在运行时从【请求作用域对象】得到处理结果 例子: 12345678910111213141516171819201.OneServletpublic class OneServlet extends HttpServlet &#123; //处理业务，得到处理结果-----查询学员信息 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Student s1 = new Student(10,&quot;mike&quot;); Student s2 = new Student(20,&quot;allen&quot;); List stuList = new ArrayList(); stuList.add(s1); stuList.add(s2); //将处理结果添加到请求作用域对象 request.setAttribute(&quot;key&quot;, stuList); //通过请求转发方案，向Tomcat申请调用user_show.jsp //同时将request与response通过tomcat交给user_show.jsp使用 request.getRequestDispatcher(&quot;/user_show.jsp&quot;).forward(request, response); &#125;&#125; 1234567891011121314151617181920212223242.user_show.jsp &lt;% //从请求作用域对象得到OneServlet添加进去的集合 List&lt;Student&gt; stuList = (List)request.getAttribute(&quot;key&quot;);%&gt;&lt;!--将处理结果写入到响应体--&gt;&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;用户编号&lt;/td&gt; &lt;td&gt;用户姓名&lt;/td&gt; &lt;/tr&gt; &lt;% for(Student stu:stuList)&#123; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=stu.getSid()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=stu.getSname()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt;&lt;/table&gt; 五:Http服务器调用JSP文件步骤123456789101112一。Http服务器调用JSP文件步骤:【2019年北京地区常考面试题】 1.Http服务器将JSP文件内容【编辑】为一个Servlet接口实现类（.java） 2.Http服务器将Servlet接口实现类【编译】为class文件(.class) 3.Http服务器负责创建这个class的实例对象，这个实例对象就是Servlet实例对象 4.Http服务器通过Servlet实例对象调用_jspService方法，将jsp文件内容写入到响应体二。Http服务器【编辑】与【编译】JSP文件位置： 标准答案：我在【work】下看到这个证据 C:\\Users\\[登录windows系统用户角色名]\\.IntelliJIdea2018.3\\system\\tomcat\\[网站工作空间]\\work\\Catalina\\localhost\\【网站别名】\\org\\apache\\jsp","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"jQurey","slug":"jQurey","date":"2020-10-15T13:40:48.424Z","updated":"2020-10-15T07:24:44.732Z","comments":true,"path":"2020/10/15/jQurey/","link":"","permalink":"http://example.com/2020/10/15/jQurey/","excerpt":"","text":"一:jQurey1:dom对象dom对象:(使用javascript的语法创建的对象叫做dom对象,也叫做js对象) 1var obj = document.getElementById(&quot;&quot;); jquery对象是一个数组,数组中就一个值 2.dom对象转jquery对象:1var jobj = $(obj) 3.jquery对象转dom对象1var obj = $(&quot;#id&quot;)[0] 4.使用jQuery条件12讲jQuery库引入&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; 3.$()1234567$(document).ready()函数是当DOM 对象加载完毕后，马上执行的函数。$(document).ready()与$()、jQuery()、window.jQuery()是等价的，所以$(document).ready()可以写成 $(function() &#123; alert(“Hello jQuery”) &#125; ); 二:选择器2.1: 基本选择器来定位dom对象的 1.==id选择器==1语法: $(&quot;#dom对象的id&quot;) 2.==class(样式)选择器==class表示css中样式,使用样式名称定位dom对象 1语法: $(&quot;.class 名称&quot;) 3.==标签选择器==1语法: $(&quot;标签名&quot;) 4.==class样式==1234567891011&lt;span class= &quot;two&quot; value=&quot;样式&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .two&#123; background : red width : 200px height : 100px &#125; &lt;/style&gt;&lt;/head&gt; 5.全部选择器1var obj = $(&quot;*&quot;) 6.混合选择器1var obj = $(&quot;#id,.class,标签名&quot;) 2.2 : 表单选择器123456789101112131415语法: $(&quot;:type 属性值&quot;)&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;radio&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;input type=&quot;button&quot;&gt; &lt;input type=&quot;file&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;input type=&quot;reset&quot;&gt; 例如:$(&quot;:text&quot;)选取所有的单行文本框$(&quot;:password&quot;)选取所有的密码框$(&quot;:radio&quot;)选取所有的单选框$(&quot;:checkbox&quot;)选取所有的多选框$(&quot;:file&quot;)选取所有的上传按钮 2.3: 过滤器过滤器不能单独使用， 必须和选择器一起使用。 2.3.1:first1$(&quot;选择器:first&quot;) : 第一个dom对象 2.3.2:last1$(&quot;选择器:last&quot;): 数组中的最后一个dom对象 2.3.3: eq(数组下标),指定dom1$(&quot;选择器:eq(数组的下标)&quot;) ：获取指定下标的dom对象 2.3.4: lt(下表),小于1$(&quot;选择器:lt(下标)&quot;) ： 获取小于下标的所有dom对象 2.3.5: gt(小标),大于1$(&quot;选择器:gt(下标)&quot;) ： 获取大于下标的所有dom对象 2.3.6:表单属过滤器123启用状态， enabled , 不可用状态 disabled选择状态 ， checked ， 例如radio， checkbox 2.3.7: 表单对象属性过滤器1.选择可用的文本框1$(“:text:enabled”) 2.选择不可用的文本框1$(“:text:disabled”) 3.复选框选中的元素1$(“:checkbox:checked”) 4.选择指定下拉列表的被选中元素1选择器&gt;option:selected 2.4:函数第一组:1.val(操作数组中 DOM 对象的 value 属性. ) 123$(选择器).val() ：无参数调用形式， 读取数组中第一个 DOM 对象的 value 属性值 $(选择器).val(值)：有参形式调用;对数组中所有 DOM 对象的 value 属性值进行统一赋值 2.text操作数组中所有 DOM 对象的【文字显示内容属性】 1234$(选择器).text():无参数调用，读取数组中所有 DOM 对象的文字显示内容，将得到内容拼接为一个字符串返回$(选择器).text(值):有参数方式，对数组中所有 DOM 对象的文字显示内容进行统一赋值 3.attr对 val, text 之外的其他属性操作 12345$(选择器).attr(“属性名”): 获取 DOM 数组第一个对象的属性值$(选择器).attr(“属性名”,“值”): 对数组中所有 DOM 对象的属性设为新值 可以转换图片: $(&quot;img&quot;).attr(&quot;src&quot;,&quot;图片资源路径&quot;) 第二组:1.hide1$(选择器).hide() :将数组中所有 DOM 对象隐藏起来 2.show1$(选择器).show():将数组中所有 DOM 对象在浏览器中显示起来 3.remove1$(选择器).remove() : 将数组中所有 DOM 对象及其子对象一并删除 4.empty1$(选择器).empty()：将数组中所有 DOM 对象的子对象删除 5.append为数组中所有 DOM 对象添加子对象 1$(选择器).append(&quot;&lt;div&gt;我动态添加的 div&lt;/div&gt;&quot;) 6.html设置或返回被选元素的内容（innerHTML）。 12 $(选择器).html()：无参数调用方法，获取 DOM 数组第一个匹元素的内容。 $(选择器).html(值)：有参数调用，用于设置 DOM 数组中所有元素的内容。 ==7.each==each 是对数组，json 和 dom 数组等的遍历,对每个元素调用一次函数。 12345678910111213141516171819语法 1：$.each( 要遍历的对象, function(index,element) &#123; 处理程序 &#125; ) 语法 2：jQuery 对象.each( function( index, element ) &#123; 处理程序 &#125; ) index: 数组的下标element: 数组的对象 例子:第一种语法:$(&quot;#id&quot;).click(function()&#123; var domArray = $(&quot;:text&quot;);//dom数组 $.each(domArray,function(i,n)&#123; alert(&quot;i=&quot;+i+ &quot;, n=&quot;+n.value); &#125;) &#125;)第二种语法:$(&quot;#id&quot;).click(function()&#123; $(&quot;:text&quot;).each(domArray,function(i,n)&#123; alert(&quot;i=&quot;+i+ &quot;, n=&quot;+n.value); &#125;) &#125;) 123456789101112131415161). 可以对 数组， json ，dom数组循环处理。 数组， json中的每个成员都会调用一次处理函数。 var arr &#x3D; [1, 2, 3] &#x2F;&#x2F;数组 var json &#x3D; &#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:20 &#125; var obj &#x3D; $(&quot;:text&quot;); 语法： $.each( 循环的内容， 处理函数 ) ：表示使用jquery的each，循环数组，每个数组成员，都会执行后面的“处理函数”一次。 $: 相当于是java的一个类名 each:就是类中的静态方法。 静态方法调用，可以使用 类名.方法名称 var arr &#x3D; [1, 2, 3] &#x2F;&#x2F;数组 处理函数:function(index, emelent) : index, element都是自定义的形参， 名称自定义。 index：循环的索引(下标0,1,2) element：数组中的成员(数组中对应位置的数据,1,2,3) 2.5:==事件绑定==1.jquery对象绑定事件12345678语法：$(选择器).监听事件名称(处理函数);说明：监听事件名称是 js 事件中去掉 on 后的内容， js 中的 onclick 的监听事件名称是 click例如： 为页面中所有的 button 绑定 onclick,并关联处理函数 fun1 $(&quot;button&quot;).click(fun1) 为页面中所有的 tr 标签绑定 onmouseover，并关联处理函数 fun2 $(&quot;tr&quot;).mouseover(fun2) 2.on() 绑定事件on() 方法在被选元素上添加事件处理程序(可以给内存中新创建的对象绑定事件) 123456789101112语法：$(选择器).on(event,data,function) $(选择器).on( 监听事件名称 , 事件的处理函数) 监听事件名称： 就是js事件中去掉on的部分， 例如js中onclick ,这里就是click 事件的处理函数： function 定义。 例如， &lt;input type=&quot;button&quot; id=&quot;btn&quot;&gt; $(&quot;#btn&quot;).on(&quot;click&quot;, function() &#123; 处理按钮单击 &#125; )event：监听事件一个或者多个，多个之间空格分开data：可选。规定传递到函数的额外数据，json 格式function: 可选。规定当事件发生时运行的函数。 2.6:AJAX2.6.1:==$.ajax()==$.ajax() 是 jQuery 中 AJAX 请求的核心方法，所有的其他方法都是在内部使用此方法。 123语法：$.ajax( &#123; name:value, name:value, ... &#125; ) 说明：==&quot;参数是 json 的数据&quot;==，包含请求方式，数据，回调方法等 123456789101112131415161718192021222324252627282930313233343536373839&gt;例如： $.ajax( &#123;名称:值， 名称1:值1..... &#125; ) 例如： $.ajax( &#123; async:true , contentType:&quot;application/json&quot; , data: &#123;name:&quot;lisi&quot;,age:20 &#125;, dataType:&quot;json&quot;, error:function()&#123; 请求出现错误时，执行的函数 &#125;, success:function( data ) &#123; // data 就是responseText, 是jquery处理后的数据。 &#125;, url:&quot;bmiAjax&quot;, type:&quot;get&quot; &#125; ) json结构的参数说明： 1)async:是一个boolean类型的值， 默认是true ，表示异步请求的。可以不写async这个配置项 xmlHttp.open(get,url,true),第三个参数一样的意思。 2)contentType: 一个字符串，表示从浏览器发送服务器的参数的类型。 可以不写。 例如你想表示请求的参数是json格式的， 可以写application/json 3)data: 可以是字符串，数组，json，表示请求的参数和参数值。 常用的是json格式的数据 4)dataType: 表示期望从服务器端返回的数据格式，可选的有： xml ， html ，text ，json 当我们使用$.ajax()发送请求时， 会把dataType的值发送给服务器， 那我们的servlet能够 读取到dataType的值，就知道你的浏览器需要的是 json或者xml的数据，那么服务器就可以 返回你需要的数据格式。 5)error: 一个function ，表示当请求发生错误时，执行的函数。 error:function() &#123; 发生错误时执行 &#125; 6)sucess:一个function , 请求成功了，从服务器端返回了数据，会执行success指定函数 之前使用XMLHttpRequest对象， 当readyState==4 &amp;&amp; status==200的时候。 7)url:请求的地址 8)type:请求方式，get或者post， 不用区分大小写。 默认是get方式。 主要使用的是 url , data ,dataType, success . 2.6.2: $.get()$.get() 方法使用 HTTP GET 请求从服务器加载数据。 123456789101112131415语法：$.get(url,data,function(data,status,xhr),dataType)url 必需。规定您需要请求的 URL。data 可选。规定连同请求发送到服务器的数据。function(data,status,xhr)可选。当请求成功时运行的函数。data,status,xhr 是自定义形参名。参数说明：data - 包含来自请求的结果数据status - 包含请求的状态（&quot;success&quot;、&quot;notmodified&quot;、&quot;error&quot;、&quot;timeout&quot;、&quot;parsererror&quot;）xhr - 包含 XMLHttpRequest 对象dataType 可选。规定预期的服务器响应的数据类型。默认地，jQuery 会智能判断。可能的 类型：&quot;xml&quot; - 一个 XML 文档&quot;html&quot; - HTML 作为纯文本&quot;text&quot; - 纯文本字符串 &quot;json&quot; - 以 JSON 运行响应，并以对象返回 2.6.3: $.post()$.post() 方法使用 HTTP POST 请求从服务器加载数据 12345678910语法：$.post(URL,data,function(data,status,xhr),dataType)参数同$get() 例子: var obj = $(&quot;#province&gt;option:selected&quot;); var provinceId = obj.val();//1,2,3 $.post(&quot;queryCity&quot;,&#123;proid:provinceId&#125;,function(resp)&#123; aler(resp); &#125;,&quot;json&quot;) 三:==前端转json==12ObjectMapper om = new ObjectMapper();om.writeValueAsString(); 12345678910111213141516171819$(&quot;#province&quot;).on(&quot;change&quot;,function()&#123; var provID = $(&quot;#province&gt;option:selected&quot;).val(); if(provID ==0)&#123; alert(&quot;请重新选择&quot;); &#125;else&#123; $.post(&quot;queryCity&quot;,&#123;provID:provID&#125;,callback,&quot;json&quot;); &#125; function callback(reslut)&#123; $(&quot;city&quot;).empty(); $(&quot;city&quot;).append( &quot;&lt;option value=&#x27;0&#x27;&gt;请选择...&lt;/option&gt;&quot; ); $.each(result,function(i,resp)&#123; $(&quot;city&quot;).append( &quot;&lt;option value=&#x27;&quot;+resp.id+&quot;&#x27;&gt;&quot;+resp.name+&quot;&lt;/option&gt;&quot; ); &#125;) &#125;&#125;)","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-10-15T13:40:48.421Z","updated":"2020-10-15T07:24:40.659Z","comments":true,"path":"2020/10/15/JDBC/","link":"","permalink":"http://example.com/2020/10/15/JDBC/","excerpt":"","text":"一:JDBC规范12345678910111213141516171819202122232425262728293031323334一。JDBC规范调用流程【背】1.将MySql服务器厂商提供Driver接口实现类注册到JVM 2.通过JDBC规范中DriverManager在Java工程与MySql服务器之间建立一个【连接通道】 3.通过MySql服务器厂商提供Connection接口实现类建立一个交通工【PreparedStatement】 4.通过交通工具【PreparedStatement】将SQL命令从Java工程推送到MySql服务器上执行并带回执行结果 5.销毁本次交易过程涉及所有资源对象二。JDBC规范下接口介绍：1.位置：JDBC规范下接口存在于JDK_1.8.jar下java.sql包2.分类： 1）java.sql.DriverManager类：这个类存在于JDK_1.8下。负责将数据库厂商提供 Driver接口实现进行注册负责在Java工程与MySql服务器之间建立一个【连接通道】 2）java.sql.Connection接口：负责管理Java工程与数据库服务器之间【连接通道】 3）java.sql.PreparedStatement接口：负责管理在【连接通道】 上进行往返交通的【交通工具】 4) java.sql.ResultSet接口：负责管理数据库服务器返回【临时表】三。ps.executeUpdate 与 ps.executeQuery 区别: 1.ps.executeUpdate： 1） 负责推送插入命令【insert】，更新命令[update]，删除命令[delete] 2） 返回结果对表文件进行操作时，收到影响行数，比如插入了多少行，更新了多少行删除了多少行 2.ps.executeQuery： 1） 负责推送查询命令【select * from 表名】 2） 返回结果是查询命令得到【临时表】，在JDBC规范中【临时表】 交给ResultSet接口实现类管理。实际上返回ResultSet实例对象 二:补充1.ResultSet123456789101112131415ResultSet对象----&gt;临时表 指针---&gt; DeptNo Dname Loc 10 mike beijing 20 jack henanrs.next()方法: next()方法每次执行时,要求指针向下移动一行,如果指针指向位置是一个具体数据行,此时 next()方法将返回true,如果指针指向位置不是一个数据行,此时返回false 指针只能向下移动,不能向上移动while(rs.next())&#123; //读取指针指向数据行中字段信息 int deptNo = rs.getInt(&quot;DeptNo&quot;); String dname = rs.getString(&quot;Dname&quot;); String loc = rs.getString(&quot;Loc&quot;);&#125; 2.Batch弹夹123456789101112//4.向MySql服务器推送100条数据for(int i=1;i&lt;=100;i++)&#123; //通过向预编译SQL命令填充数据生成全新的SQL命令 ps.setInt(1, i); //inser into dept (deptno,dname,loc) values(1,?,?) ps.setString(2, &quot;dept_&quot;+i); //inser into dept (deptno,dname,loc) values(1,&#x27;dept_1&#x27;,?) ps.setString(3, &quot;北京&quot;);//inser into dept (deptno,dname,loc) values(1,&#x27;dept_1&#x27;,&#x27;北京&#x27;) //在新的SQL语句生成之后，将SQL语句作为子弹添加到PS的弹夹 ps.addBatch(); //[sql1,sql2,...] &#125;//5.【一次性】通过ps将100条sql语句推送到mysql服务器执行ps.executeBatch(); // 推送100条SQL命令只需要往返一次 DBUtil–老杜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package jdbc001;import java.sql.*;/** JDBC工具类,简化JDBC编程* */public class DBUtil &#123; /* * 工具类中的构造方法都是私有的, * 因为工具类中的方法都是静态的,不需要new对象,直接采用类名调用 * */ //放在静态代码块中,静态代码快只在类时执行,并且只执行一次 private DBUtil()&#123;&#125; static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;//这里要扔出异常,因为外面释放资源要catch public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbctext?useSSL=false&quot;, &quot;root&quot;, &quot;1207071819&quot;); return conn; &#125; //关闭资源 /* * conn 连接对象 * ps 数据操作对象 * rs 结果集 * */ public static void close(Connection conn, Statement ps, ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; DBUtilText–老杜1234567891011121314151617181920212223242526272829303132333435363738package jdbc001;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** 第一:测试DBUtil是否好用* 第二:模糊查询怎么写?* */public class DBUtilText &#123; public static void main(String[] args) &#123; Connection conn=null; PreparedStatement ps=null;//这里使用preparedStatement(预编译的数据库操作对象),注意这里preparedStatement有个d,下面有没有 ResultSet rs=null; try &#123; //获取连接 conn=DBUtil.getConnection(); //编译预处理对象 //SQL语句的框子,其中一个?表示一个占位符,一个?将来接收一个&quot;值&quot;,注意:占位符不能使用单引号括起来 String sql=&quot;select realName from t_user where loginPwd like ?&quot;; ps=conn.prepareStatement(sql);//这里prepareStatement,没有d //给占位符 ? 传值(第一个问号下标是1,第二个问号下标是2,JDBC中所有下标从1开始) ps.setString(1,&quot;XX%&quot;); rs=ps.executeQuery();//这里面括号一定不要传&quot;sql&quot;这个变量,传进去就还是会发生sql注入 while(rs.next())&#123; System.out.println(rs.getString(&quot;realName&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 DBUtil.close(conn,ps,rs); &#125; &#125;&#125; DBUtil–老杨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.bjpowernode.util;import java.sql.*;/** * 将JDBC规范下相关对象【创建】与【销毁功能】封装到方法 * * 一。JDBC开发步骤： * 1.注册数据库服务器提供的Driver接口实现类 * 2.创建一个连接通道交给Connection接口的实例对象【JDBC4Connection】管理 * 3.创建一个交通工具交给PreparedStatement接口的实例对象【JDBC4PreparedStatement】管理 * 4.由交通工具在Java工程与数据库服务器之间进行传输，推送SQL命令并带回执行结果 * 5.交易结束后，销毁相关资源【Connection,PreparedStatement,ResultSet】 */public class JdbcUtil &#123; private Connection con = null;//类文件属性，可以在类文件中所有的方法中使用 private PreparedStatement ps=null;//类文件属性，可以在类文件中所有的方法中使用 //静态语句块 static&#123;&#125; //在当前类文件第一次被加载到JVM时，JVM将会自动调用当前类文件静态语句块 static&#123; //1.注册数据库服务器提供的Driver接口实现类 try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Driver接口实现类被注册了&quot;); &#125; //封装Connection对象创建细节 不需要考虑使用对象创建细节 public Connection createCon()&#123; try &#123; con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;, &quot;root&quot;, &quot;123&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); System.out.println(&quot;Connection对象创建失败。。。。。&quot;); &#125; return con; &#125; //封装PreparedStatement对象创建细节 public PreparedStatement createStatement(String sql)&#123; Connection con = createCon(); try &#123; ps = con.prepareStatement(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return ps; &#125; //封装PreparedStatement对象与Connection对象销毁细节 public void close()&#123; if(ps!=null)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(con!=null)&#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //封装PreparedStatement对象与Connection对象与ResultSet对象销毁细节 public void close(ResultSet rs)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; close(); &#125;&#125; DBUtilText–老杨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.bjpowernode.test;import com.bjpowernode.util.JdbcUtil;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.Scanner;/** * 2020/4/24 */public class TestMain &#123; public static void main(String[] args)throws Exception &#123; JdbcUtil util = new JdbcUtil(); PreparedStatement ps=null; ResultSet rs = null; Scanner request = new Scanner(System.in); String userName,password,deptNo,dname,loc; String sql_1=&quot;select count(*) from emp where ename=? and empno=?&quot;; String sql_2=&quot;insert into dept (deptNo,dname,loc) values(?,?,?)&quot;; int flag = 0; //-----登录验证-----start System.out.println(&quot;请输入用户名&quot;); userName = request.next(); System.out.println(&quot;请输入密码&quot;); password = request.next(); ps = util.createStatement(sql_1); ps.setString(1, userName); ps.setString(2, password); rs = ps.executeQuery(); while(rs.next())&#123; flag = rs.getInt(&quot;count(*)&quot;); &#125; util.close(rs); if(flag!=1)&#123; System.out.println(&quot;输入信息不存在，请重新登录。。。。&quot;); return; &#125; //-----登录验证-----end //-----具体功能页面---start System.out.println(&quot;******欢迎使用某某公司部门管理系统******&quot;); System.out.println(&quot;******1.添加部门******&quot;); System.out.println(&quot;******2.查询部门******&quot;); System.out.println(&quot;******3.删除部门******&quot;); System.out.println(&quot;******4.更新部门******&quot;); System.out.println(&quot;******请输入操作******&quot;); flag = request.nextInt(); if(flag ==1)&#123; System.out.println(&quot;******请输入部门编号******&quot;); deptNo =request.next(); System.out.println(&quot;******请输入部门名称******&quot;); dname =request.next(); System.out.println(&quot;******请输入部门位置******&quot;); loc = request.next(); ps = util.createStatement(sql_2); ps.setInt(1, Integer.valueOf(deptNo)); ps.setString(2, dname); ps.setString(3, loc); flag = ps.executeUpdate(); util.close(); &#125;else if(flag ==2)&#123; &#125;else if(flag ==3)&#123; &#125;else&#123; &#125; //-----具体功能页面---end &#125;&#125; DAO创建12345DAO类开发规则: 1):一个DAO类封装的是一张表操作细节 2):DAO类命名规则:表名+Dao,比如封装emp表操作细节---&gt;EmpDao 封装Dept表操作细节---&gt;DeptDao 3):DAO类所在的包命名规:公司网站域名.dao,比如 com.bjpowernode.dao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.bjpowernode.dao;import com.bjpowernode.entity.Dept;import com.bjpowernode.util.JdbcUtil;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * 增删改查 */public class DeptDao &#123; private JdbcUtil util = new JdbcUtil(); //添加数据行 public int add(String deptNo,String dname,String loc)&#123; String sql=&quot;insert into dept (deptNo,dname,loc) values(?,?,?)&quot;; int result=0; PreparedStatement ps = util.createStatement(sql); try &#123; ps.setInt(1, Integer.valueOf(deptNo)); ps.setString(2, dname); ps.setString(3, loc); result=ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; util.close(); &#125; return result; &#125; //删除数据行 public int delete(String deptNo)&#123; String sql =&quot;delete from dept where deptno=?&quot;; PreparedStatement ps = util.createStatement(sql); int result = 0; try &#123; ps.setInt(1, Integer.valueOf(deptNo)); result = ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; util.close(); &#125; return result; &#125; //更新数据行 public int update(String deptNo,String dname,String loc)&#123; String sql =&quot;update dept set dname=?,loc=? where deptno=?&quot;; PreparedStatement ps = util.createStatement(sql); int result=0; try &#123; ps.setString(1, dname); ps.setString(2, loc); ps.setInt(3, Integer.valueOf(deptNo)); result = ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; util.close(); &#125; return result; &#125; //查询数据行 public List findAll()&#123; String sql =&quot;select * from dept&quot;; PreparedStatement ps = util.createStatement(sql); ResultSet rs = null; List list = new ArrayList(); try &#123; rs = ps.executeQuery(); //将是临时表数据行转换为实体类实例对象保管 while(rs.next())&#123; int deptNo = rs.getInt(&quot;deptno&quot;); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); Dept dept = new Dept(deptNo, dname, loc); list.add(dept); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; util.close(rs); &#125; return list; &#125;&#125; 实体类1234567891011121314151617181).一个实体类用于描述一张表2).实体类的类名应该于关联的表名保持一致,但是可以忽略大小写 DEPT.frm---------&gt;public class Dept&#123;&#125;3).实体类的属性应该和关联的表文件字段保持一致 Dept.frm----&gt;DEPRNO INT DNAME VARCHAR(20) LOC VARCHAR(20) public class Dept&#123; private Integer deptNo; private String dname; private String loc; &#125;4).实体类的一个实例对象用于在内存中存储对应的表文件中一个数据行 Dept.frm------------------&gt;JVM内 DeptNo dname loc 10 Account NEW York Dept dept1 = new Dept(10,&quot;Account&quot;,&quot;NEW York&quot;); 20 Sales BeiJing Dept dept2 = new Dept(20,&quot;Sales&quot;,&quot;BeiJing&quot;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.bjpowernode.entity;/** * 2020/4/24 */public class Dept &#123; private Integer deptNo; private String dname; private String loc; public Integer getDeptNo() &#123; return deptNo; &#125; public void setDeptNo(Integer deptNo) &#123; this.deptNo = deptNo; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; public Dept() &#123; &#125; public Dept(Integer deptNo, String dname, String loc) &#123; this.deptNo = deptNo; this.dname = dname; this.loc = loc; &#125;&#125; 查询 1234567891011121314151617181920212223//查询数据行 public List findAll()&#123; String sql =&quot;select * from dept&quot;; PreparedStatement ps = util.createStatement(sql); ResultSet rs = null; List list = new ArrayList(); try &#123; rs = ps.executeQuery(); //将是临时表数据行转换为实体类实例对象保管 while(rs.next())&#123; int deptNo = rs.getInt(&quot;deptno&quot;); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); Dept dept = new Dept(deptNo, dname, loc); list.add(dept); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; util.close(rs); &#125; return list; &#125;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2020-10-15T13:40:48.418Z","updated":"2020-10-15T07:24:36.357Z","comments":true,"path":"2020/10/15/JavaScript/","link":"","permalink":"http://example.com/2020/10/15/JavaScript/","excerpt":"","text":"一:介绍12345678910111213141516171819202122232425262728293031323334一。介绍: 1.JavaScript是一种专门在浏览器编译并执行的编程语言 2.JavaScript处理用户与浏览器之间请求问题 3.JavaScript采用【弱类型编程语言风格】对【面向对象思想】来进行实现的编程语言二。弱类型编程语言风格 VS 强类型编程语言风格 1.强类型编程语言风格：认为对象行为应该受到其修饰类型严格约束。 Java采用【强类型编程语言风格】对【面向对象思想】来进行实现的编程语言 class Student&#123; public String sname; public void sayHello()&#123; System.out.print(&quot;hello world&quot;); &#125; &#125; Student stu = new Student(); stu.sname=&quot;mike&quot;; stu对象能够调用属性只有sname stu.sayHello(); stu对象能够调用方法只有sayHello() stu.sid =10; // 在Java认为是语法错误，修饰stu对象的Student类型没有提供这个属性 2.弱类型编程语言风格： 认为对象行为不应该受到其修饰类型约束。可以根据实际需要来决定 对象可以调用属性和方法 JavaScript采用【弱类型编程语言风格】对【面向对象思想】来进行实现的编程语言 var stu = new Object();//stu对象相当于【阿Q】 stu.car = &quot;劳斯莱斯&quot;;//合法 stu.play = function ()&#123; return &quot;天天打游戏&quot;&#125; stu.play(); 示例: 1234567common.js://在JavaScript命令文件（静态资源文件），可以直接声明JavaScript命令或则JavaScript函数//不需要声明&lt;script&gt;//通知浏览器弹出一个对话框function fun2()&#123; window.alert(&quot;你愁啥&quot;);&#125; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 通知浏览器将common.js文件内容加载到当前网页中 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;common.js&quot;&gt; /* * 当浏览器解析script标签时，根据src要求 * 将common.js文件所有的内容加载到当前script * 标签内部 * function fun2()&#123; window.alert(&quot;你愁啥&quot;); &#125; */ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;input type=&quot;button&quot; value=&quot;老崔&quot; onclick=&quot;fun2()&quot;/&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 二:JavaScript中变量声明方式:123456781.命令格式: var 变量名; var 变量名 = 值; var 变量名1,变量名2=值；2.注意： 在JavaScript变量/对象，在声明不允许指定【修饰类型】 只能通过var来进行修饰 三:JavaScript中标识符命名规则:1231.标识符只能由四种符号组成 英文字母，数字 , 下划线，美元符号($)2.标识符首字母不能以&quot;数字&quot;开头3.标识符不能采用JavaScript关键字 比如 var 四:JavaScript数据类型：123456789101112131415161718192021222324251.分类： 基本数据类型 &amp; 高级引用数据类型2.基本数据类型：数字类型（number）, 字符串类型(string), 布尔类型(boolean)3.数字类型（number）：JavaScript中将整数与小数合称为number类型4.字符串类型(string)：JavaScript中字符与字符串合称为string类型 JavaScript字符或则字符串既可以使用&#x27;&#x27;又可以使用&quot;&quot;5.布尔类型(boolean): JavaScript中boolean类型的值只有true或则false6.高级引用数据类型: object类型 function类型7.object类型： JavaScript中所有通过【构造函数】生成的对象都是object类型8.function类型： 相当于Java中（java.lang.reflect.Method） JavaScript所有函数都是function类型********** JavaScript是弱类型编程语言，根据变量赋值内容来判断变量数据类型 JavaScript中变量的数据类型可以根据赋值内容来进行动态改变 五:JavaScript中特殊【值】12345678910111213141516171.undefined: JavaScript中所有变量在没有赋值时，其默认值都是undefined 由于JavaScript根据变量的赋值来判断变量类型，此时由于变量 没有赋值因此JavaScript无法判断当前变量数据类型，此时返回 也是undefiled,因此初学者将undefined也理解为是一种数据类型 这种理解是错误2.null： JavaScript中当一个对象赋值为null时，表示对象引用了一个【空内存】 这个空内存既不能存储数据也不能读取数据。 此时这个对象数据类型，在JavaScript依然认为是object类型3.NaN: JavaScript中当一个变量赋值为NaN，表示变量接收了一个【非法数字】（123 合法数字 abc123 非法数字） 此时这个变量数据类型，在JavaScript依然认为number类型4.infinity： JavaScript中当一个变量赋值为infinity，表示变量接收了一个【无穷大数字】 此时这个变量数据类型，在JavaScript依然认为number类型 六:JavaScript中控制语句1JavaScript中控制语句与Java中控制语句语法格式完全一致 七:JavaScript中函数声明方式1234567891011121314151.命令格式: function 函数名(形参名1，形参名2)&#123; JavaScript命令行 JavaScript命令行 return 将函数运行结果进行返回 &#125;2.注意: 1)JavaScript中，所有函数在声明时，都需要使用function进行修饰 2)JavaScript中，所有函数在声明时，禁止指定函数返回数据类型 3)JavaScript中，所有函数在声明时，形参既不能使用var来修饰也不能使用数据类型修饰 4)JavaScript中，所有函数在声明时，如果有返回值，此时应该通过return进行返回 八:JavaScript函数调用方式:1234567891011121314151617181920212223241.浏览器并不会自动调用JavaScript函数2.可以通过命令行方式来调用Java函数 &lt;script type=&quot;text/javascript&quot;&gt; function fun1(name)&#123; window.alert(&quot;Hello &quot;+name); &#125; function fun2(n1,n2)&#123; var num = n1 + n2; return num; &#125; function fun3()&#123; window.alert(&quot;瞅你咋地。。。。。&quot;) &#125; fun1(&quot;mike&quot;); //通知浏览器调用fun1; // var result = fun2(25,25) // window.alert(&quot;result &quot;+result); &lt;/script&gt;3.通过绑定在HTML标签上监听事件通知浏览器调用指定函数进行处理 二:JavaScript应用一:JavaScript作用:1帮助浏览器对用户提出请求进行处理 二:DOM对象:12341.DOM = Document Object Model， 【文档模型对象】2.JavaScript不能直接操作HTML标签，只能通过HTML标签 关联的DOM对象对HTML标签下达指令 三:DOM对象生命周期：1234567891.浏览器在接收到html文件之后，将HTML文件标签加载到浏览器缓存中， 每当加载一个html标签时候，自动为这个标签生成一个实例对象，这个实例对象就是DOM对象2.在浏览器关闭之前或则浏览器请求其他资源文件之前，本次生成的DOM对象 一直存活在浏览器缓存中3.在浏览器关闭时候，浏览器缓存中dom对象将要被销毁 4.在浏览器请求到新资源文件后，浏览器缓存中原有的dom对象将会被覆盖 四:document对象：1231.document对象被称为【文档对象】2.document对象用于在浏览器内存中根据定位条件定位DOM对象 五:document对象生命周期:12345671.在浏览器将网页中所有标签加载完毕后，在内存中将使用【树形结构】 存储这些DOM对象。在树形结构生成完毕后由浏览器生成一个document对象管理这颗树（DOM树） ****在浏览器将接收网页中标签加载完毕后，自动在浏览器内存生成一个document对象2.一个浏览器窗口运行期间，只会生成一个document对象3.在浏览器关闭时，负责将document对象进行销毁 六:通过document对象定位DOM对象方式:1234567891011121314151617181920212223242526272829301.根据html标签的id属性值定位DOM对象 命令格式 var domObj = document.getElementById(&quot;id属性值&quot;)； 举个栗子 var domObj = document.getElementById(&quot;one&quot;)； 通知document对象定位id属性等于one的标签关联的DOM对象2.根据html标签的name属性值定位DOM对象 命令格式 var domArray = document.getElementsByName(&quot;name属性值&quot;); 举个栗子 &lt;input type=&quot;checkbox&quot; name=&quot;deptNo&quot; value=&quot;10&quot;&gt;部门10 &lt;input type=&quot;checkbox&quot; name=&quot;deptNo&quot; value=&quot;20&quot;&gt;部门20 &lt;input type=&quot;checkbox&quot; name=&quot;deptNo&quot; value=&quot;30&quot;&gt;部门30 var domArray = document.getElementsByName(&quot;deptNo&quot;); 通知document对象将所有name属性等于deptNo的标签关联的DOM对象 进行定位并封装到一个数组进行返回。 domArray就是一个数组存放 本次返回的所有DOM对象 3.根据html标签类型定位DOM对象 命令格式 var domArray = document.getElementsByTagName(&quot;标签类型名&quot;); 举个栗子 var domArray = document.getElementsByTagName(&quot;p&quot;); &lt;p&gt;段落标签&lt;/p&gt; 通知document对象将所有段落标签关联的dom对象进行定位并封装到一个数组返回 七:DOM对象对HTML标签属性操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661.DOM对象对标签value属性进行取值与赋值操作 取值操作: var domObj = document.getElementById(&quot;one&quot;); var num = domObj.value; 赋值操作: var domObj = document.getElementById(&quot;one&quot;); domObj.value = &quot;abc&quot;;2.DOM对象对标签中【样式属性】进行取值与赋值操作 取值操作: var domObj = document.getElementById(&quot;one&quot;); //读取当前标签【背景颜色属性】值 var color = domObj.style.背景颜色属性 赋值操作: var domObj = document.getElementById(&quot;one&quot;); //通过DOM对象对标签中【背景颜色属性】进行赋值 domObj.style.背景颜色属性 = 值；3.DOM对象对标签中【状态属性】进行取值与赋值操作 状态属性： 状态属性的值都是boolean类型 disabled = true ; 表示当前标签不可以使用 disabled = false; 表示当前标签可以使用 checked: 只存在与radio标签与checkbox标签 checked = true ; 表示当前标签被选中了 checked = false; 表示当前标签未被选中 取值操作: var domObj = document.getElementById(&quot;one&quot;); var num = domObj.checked; 赋值操作: var domObj = document.getElementById(&quot;one&quot;); domObj.checked = true;4. DOM对象对标签中【文字显示内容】进行赋值与取值 文字显示内容: 只存在于双目标签之间;&lt;tr&gt;100&lt;/tr&gt; 取值操作: var domObj = document.getElementById(&quot;one&quot;); var num1 = domObj.innerText; 赋值操作: var domObj = document.getElementById(&quot;one&quot;); domObj.innerText = 值； innerText与innerHTML 区别: innerText与innerHTML都可以对标签文字显示内容属性进行赋值与取值 innerText只能接收字符串 innerHTML既可以接收字符串又可以接收html标签 例子:文字显示内容 &lt;script type=&quot;text/javascript&quot;&gt; function fun1()&#123; //1.得到用户在文本框输入内容 var content = document.getElementById(&quot;two&quot;).value; //2.将得到输入内容作为【文字显示内容】写入到DIV标签之间 document.getElementById(&quot;one&quot;).innerText =content; &#125; &lt;/script&gt; 例子全选与全不选与鼠标悬停变色:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script type=&quot;text/javascript&quot;&gt; //功能0,在浏览器将页面加载完毕时,自动将监听事件与标签进行绑定 function main()&#123; //为标题行checkbox绑定onclike时间并关联fun1 document.getElementById(&quot;one&quot;).onclike = fun1; //为数据行所有checkbox绑定onclike时间并关联fun2 var domArray = document.getElementsByName(&quot;ck&quot;); for(var i=0;i&lt;domArray.length;i++)&#123; var domObj = domArray[i]; domObj.onclike = fun2; &#125; //为所有数据行绑定onmouseover监听事件并关联fun3 domArray = document.getElementByTagName(&quot;tr&quot;); for(var i=1;i&lt;domArray.length;i++)&#123; var domObj =domArray[i]; domObj.onmouseover=fun3; domObj.onmouseout = fun4; &#125; &#125; //通过标题行选中状态来控制数据行所有checkbox的选中状态 function fun1()&#123; //1.获得标题行上checkbox的checked属性值 var flag = document.getElementById(&quot;one&quot;).checked; //2.定位数据行所有的checkbox var domArray = document.getElementsByName(&quot;ck&quot;) //3.标题行上checkbox的checked属性值依次赋值给数据行上checkbox for(var i=0;i&lt;domArray.length;i++)&#123; var domObj = domArray[i]; domObj.checked = flag; &#125; &#125; function fun2()&#123; //1.获取数据行上所有checkbox的个数 var domArray = document.getElementByName(&quot;ck&quot;); //2.获取数据行上被选中的checkbox的个数 var checkedNum =0; for(var i=0;i&lt;domArray.length;i++)&#123; var domObj = domArray[i]; if(domOvj.checked == true)&#123; ++checkedNum; &#125; &#125; //3.根据实际情况判断标题行checkbox的状态 if(checkedNum == domarray.length)&#123; document.getElementById(&quot;one&quot;).checked = true; &#125;else&#123; document.getElementById(&quot;one&quot;).checked = false; &#125; //功能3:将鼠标悬停的数据行背景颜色设置为green 将字体颜色设置为红色 function fun3()&#123; this.style.backgroundColor=&quot;green&quot;; this.style.color=&quot;red&quot;; //this指向当前鼠标悬停的tr标签的dom对象 &#125; //功能4:将鼠标移开的数据行背景颜色设置为白色,将字体颜色者只为黑色 function fun4()&#123; this.style.backgroundColor=&quot;white&#x27;&quot;; this.style.color=&quot;black&quot;; //this指向当前鼠标悬停的tr标签的dom对象 &#125; &#125;&lt;/script&gt; &lt;body onload=&quot;main()&quot;&gt; &lt;/body&gt; 八:JavaScript监听事件12345678910111213141516171819202122232425261.监听事件: 监听用户在何时以何种方式对当前标签进行操作。 当监听到相关行为时，通知浏览器调用对应JavaScript 函数对当前用户请求进行处理2.监听事件分类: 1)监听用户何时使用鼠标操作当前标签 2)监听用户何时使用键盘操作当前标签3.监听用户何时使用鼠标操作当前标签： 1） onclick : 监听用户何时使用鼠标【单击】当前标签 2） onmouseover: 监听用户何时将鼠标【悬停】当前标签上方 3） onmouseout : 监听用户何时将鼠标从当前标签上方【移开】 4） onfocus : 监听用户何时通过鼠标让当前标签获得【光标】 5） onblur : 监听用户何时通过鼠标让当前标签丢失【光标】4.监听用户何时使用键盘操作当前标签 1) onkeydown :监听用户何时在当前标签上[按下键盘] 2) onkeyup :监听用户何时在当前标签上[弹起键盘] 1.登陆密码重复验证:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //检测用户是否填写原始密码 function fun1()&#123; //1获得原始密码内容 var content = document.getElementById(&quot;one&quot;).value; if(content == &#x27;&#x27;)&#123; document.getElementById(&quot;one&quot;).focus(); document.getElementById(&quot;font_1&quot;).innerHTML =&quot;密码不能为空&quot; &#125;else&#123; document.getElementById(&quot;font_1&quot;).innerHTML =&quot;*&quot; &#125; &#125; //检测用户密码与重复密码是否一致 function fun2()&#123; //1获得原始密码内容 var content_1 = document.getElementById(&quot;one&quot;).value; //2.获得重复密码 var content_2 = document.getElementById(&quot;two&quot;).value; if(content_1 != content_2)&#123; document.getElementById(&quot;two&quot;).focus(); document.getElementById(&quot;font_2&quot;).innerHTML =&quot;两次输入密码不一致&quot; &#125;else&#123; document.getElementById(&quot;font_2&quot;).innerHTML =&quot;*&quot; &#125; &#125; &lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;form action=&quot;/myWeb/user/add&quot; method=&quot;get&quot;&gt; &lt;table border=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;用户姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;one&quot;/&gt; &lt;font id=&quot;font_1&quot; style=&quot;color: red&quot;&gt;*&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;重复密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;two&quot; onfocus=&quot;fun1()&quot; onblur=&quot;fun2()&quot;/&gt; &lt;font id=&quot;font_2&quot; style=&quot;color: red&quot;&gt;*&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;用户注册&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 2.鼠标移动变色:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fun1()&#123; this.style.backgroundColor=&quot;blue&quot;; &#125; function fun2()&#123; this.style.backgroundColor=&quot;white&quot;; &#125; function main()&#123; var domArray = document.getElementByTagName(&quot;tr&quot;); for(var i=1;i&lt;domArray.length;i++)&#123; var trDom = domArray[i]; trDom.onmouseover = fun1; trDom.onmouseout = fun2; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;main()&quot;&gt;&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; id=&quot;one&quot; &gt;全选/全不选 &lt;/td&gt; &lt;td&gt; 职员姓名 &lt;/td&gt; &lt;td&gt; 职员职位 &lt;/td&gt; &lt;td&gt; 职员工资 &lt;/td&gt; &lt;/tr&gt; &lt;!--this指向当前tr标签关联的DOM对象--&gt; &lt;tr onmouseover=&quot;fun1(this)&quot; onmouseout=&quot;fun2(this)&quot;&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ck&quot;/&gt; &lt;/td&gt; &lt;td&gt; MIKE &lt;/td&gt; &lt;td&gt; 初级程序员 &lt;/td&gt; &lt;td&gt; 10000 &lt;/td&gt; &lt;/tr&gt; &lt;tr onmouseover=&quot;fun1(this)&quot; onmouseout=&quot;fun2(this)&quot;&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ck&quot;/&gt; &lt;/td&gt; &lt;td&gt; SMITH &lt;/td&gt; &lt;td&gt; 高级程序员 &lt;/td&gt; &lt;td&gt; 40000 &lt;/td&gt; &lt;/tr&gt; &lt;tr onmouseover=&quot;fun1(this)&quot; onmouseout=&quot;fun2(this)&quot;&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ck&quot;/&gt; &lt;/td&gt; &lt;td&gt; KING &lt;/td&gt; &lt;td&gt; 架构师 &lt;/td&gt; &lt;td&gt; 50000 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 3.百度的模糊查询:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; var myArray=[ &quot;allen&quot;,&quot;smith&quot;,&quot;tom&quot;,&quot;mike&quot;,&quot;jones&quot;, &quot;tomcat&quot;,&quot;for&quot;,&quot;while&quot;,&quot;java&quot;,&quot;index&quot;,&quot;radio&quot; ]; function fun1()&#123; //1.读取用户在文本框输入的内容 var content = document.getElementById(&quot;one&quot;).value; if(content==&quot;&quot;)&#123; documnet.getElementById(&quot;two&quot;).style.display=&quot;none&quot;; return; &#125; //2.到数组中定位包含了指定内容的字符串 var value=&quot;&quot;; for(var i=0;i&lt;myArray.length;i++)&#123; var str = myArray[i]; //&quot;abc&quot;.indexOf(&quot;a&quot;)==0 a在字符串abc中第一次出现的位置 //&quot;abc&quot;.indexOf(&quot;d&quot;)==-1 if(str.indexOf(content)!=-1)&#123; value+=str+&quot;&lt;/br&gt;&quot;;//allen&lt;/br&gt;tomcat&lt;/br&gt; &#125; &#125; //3.将定位字符串作为文字显示内容填充到DIV标签 var domObj = documnet.getElementById(&quot;two&quot;); if(value==&quot;&quot;)&#123; domObj.style.display=&quot;none&quot;; return; &#125; domObj.innerHTML=value; domObj.style.display=&quot;block&quot;;//显示 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;input type=&quot;text&quot; id=&quot;one&quot; size=&quot;50&quot; onkeyup=&quot;fun1()&quot;/&gt; &lt;input type=&quot;button&quot; style=&quot;background-color: blue; color:white&quot; value=&quot;百度一下&quot;&gt; &lt;div id=&quot;tow&quot; style=&quot;background-color: antiquewhite;color:red:width:400px; height: 300px;display:none&quot;&gt;&lt;/div&gt; &lt;!--display:none是让div隐藏--&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 九:onload监听事件12345671.作用:监听浏览器何时将网页中html标签加载完毕 2.意义: 浏览器每加载一个html标签时,自动在内存生成一个dom对象, 在浏览器将网页所有标签加载完毕时,意味当前网页中所有的 标签都生成对应的dom对象,onload此时就可以触发调用函数对 浏览器中标签进行处理,此时不会出现未找到dom对象问题3.浏览器加载时,javascript是从上而下执行,如果需要用到dom对象,需要将javascript,命令写道dom文本框对象下面,此时显得比较杂乱,可以采用以下方法进行封装 1234567891011使用例子:&lt;script style=&quot;text/javascript&quot;&gt; function fun1()&#123; var domObj=document.getElementById(&#x27;one&#x27;); var str=domObj.value; window.alert(str);&#125;&lt;/script&gt; &lt;body onload=&quot;fun1()&quot;&gt;&lt;/body&gt; 十:dom对象实现监听事件与html标签绑定123456789101.前提: 实际开发过程中,同一个监听事件往往与多个html标签进行绑定 这样增加开发难度,在未来维护过程中增加维护难度2.命令形式: domObj.监听事件名 = 处理函数名 ****此处处理函数名后面是不能出现()****3.举例 var domObj = document.getElementById(&quot;one&quot;); domObbj.onclike = fun1;//注意函数名后面不能有() 相当于: &lt;input type =&quot;button&quot; id=&quot;one&quot; onclike=&quot;fun1()&quot;&gt;//此处函数名后面必须有() 十一:typeof1typeof obj = obj.getClass().getName(); 三:javascript高级篇一:arguments1234567891.JavaScript中,每一个函数都包含一个arguments属性 2.arguments属性是一个数组 3.在函数调用时,将实参出入到函数arguments中,再由arguments将数据传递给形参 4.arguments属性存在,可以将JavaScript中函数在调用时传递实参与形参进行格式,增加函数调用灵活性 5.arguments属性只能在函数体内使用,不能在函数体外使用 二:function类型对象12345678910111213141516171819202122232425262728291.介绍: 1)function是JavaScript中一种高级数据类型 2)一个function类型对象用于管理一个具体函数 3)JavaScript中function类型相当于Java中Method类型 2.function类型对象声明方式: 1)标准声明方式 2)匿名声明方式 3.function类型对象声明方式----标准声明方式 function 函数对象名(参数1,参数2)&#123; 命令; &#125;4.function类型对象声明方式----匿名声明方式 var 函数对象名 = function(参数1 , 参数2)&#123; 命令; &#125;例子: var fun2 = function(p1,p2)&#123;window.alert(&quot;fun2 is run..&quot;)&#125;调用:fun2();5.function类型对象的创建时机 浏览器在加载&lt;script&gt;时,共加载两次 第一次加载,将&lt;script&gt;标签所有标准形式声明函数对象进行创建(即标准声明函数前后都可以执行调用此函数) 第二次加载,将&lt;script&gt;标签所有命令行按照自上而下顺序来执行(只能在函数声明后调用&#x27;) 三:局部变量和全局变量123456789101112131415161.局部变量: 1)定义: 在函数执行体内,通过var修饰符声明的变量 function fun1()&#123; var name = &quot;mike&quot;;//局部变量 &#125;2) 特征:局部变量只能在当前函数执行体使用,不能在函数执行体外使用2.全局变量: 定义: 1):全局变量可以在当前html文件中所有的函数中使用 2):全局变量被声明时,自动分配给window对象作为其属性 var name=&quot;mike&quot;---&gt;window.name=&quot;mike&quot; 声明全局变量: 第一种方式:直接在script标签下,通过var声明的变量,就是全局变量 第二种方式:在函数执行体内,没有通过var修饰符修饰的变量也是全局变量 四:object类型对象特征1234567891011121314151617181920212223242526271.[定义]: 在JavaScript认为所有通过[构造函数]生成对象其数据类型都是object类型 2.[特征]: object类型对象在创建完毕后,可以根据实际情况,任意添加属性和方法, 也可以移除属性和方法3.[属性维护]: 第一种维护方案: 添加属性 object对象.新属性名=值: 添加函数: object对象.新函数对象名 = function()&#123;&#125;;例子: &lt;script style=&quot;text/javascript&quot;&gt; var obj1 = new Object();//JavaScript内置构造函数 //新增属性: obj1.sid=10; &lt;/script&gt; 第二种维护方案: 添加属性: object对象[&quot;新属性名&quot;] = 值; 添加函数: object对象[&quot;新函数对象名&quot;] = function()&#123;&#125;; 移除对象属性和方法: delete object.属性名 delete object.函数名 五:自定义构造函数12345678910111213141516171. [命令]: function 函数对象名()&#123; &#125;2.[调用] var object类型对象 = new 函数对象名();3.[普通函数与构造函数区分] 1):函数没有调用之前,无法区分函数身份,只能根据函数调用形式区分 2): 判断普通函数: var num = 函数对象名(); 3): 判断构造函数: var num = new 函数对象名(); 4):返回值: 普通函数运行后需要通过return将结果返回 构造函数运行后,直接返回一个object类型对象,此时函数return相当于无效 六:JavaScript中this指向12343/1.JavaScript中this指向和Java中this只想问安全一致 1): 在构造函数中,this指向当前构造函数生成的object类型对象 2): 在普通函数中,this指向调用当前函数的实例对象 ==七:JSON==服务端与浏览器之间的数据通讯格式 1234567891011121314151617181920212223242526271.前提:JavaScript中得到object类型对象方式 方式1: 由构造函数生成的对象都是object类型对象 方式2: 由json数据描述格式生成对象都是object类型对象 2.JSON数据描述格式 JavaScript中获得object类型对象简化版 3.标准命令格式: var obj = &#123;&quot;属性名1&quot;:值,&quot;属性名2&quot;:值&#125;; 开发人员习惯于将由JSON生成object类型对象称为[JSON对象] 4.JSON数组: 专门存放JSON对象的数组被称为JSON数组 例子: &lt;script type=&quot;text/javascript&quot;&gt; //存放多个城市对象 var jsonArray = [ &#123;&quot;cityID&quot;:1,&quot;cityName&quot;:&quot;北京市&quot;&#125;, &#123;&quot;cityID&quot;:2,&quot;cityName&quot;:&quot;上海市&quot;&#125;, &#123;&quot;cityID&quot;:3,&quot;cityName&quot;:&quot;广州市&quot;&#125; ]; for(var i=0;i&lt;jsonArray.length;i++)&#123; var cityObj = jsonArray[i]; window.alert(&quot;城市编号&quot;+cintyObj.cityId+&quot;城市名称&quot;+cityObj.cityName); &#125; &lt;/script&gt; 1.通过反射机制将高级类型转化为json12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Student&#123; private Integer sid; private String sname; set和get方法,无参和有参构造方法&#125;public class RelectUtil&#123; //作用: 将任意类型对象内容转换成json格式字符串返回 //参数: 一个高级引用对象 Student对象,Dept对象..... public static String jsonObject(Object obj)&#123; Class classFile =null; Filed filedArray[] = null; StringBUffer str = new StringBuffer(&quot;&#123;&quot;); //1.获取当前对象隶属的[class文件] classFile = obj.getClass(); //Student.class //2.获取[class文件]所有属性 filedArray = classFile.getDeclaredFields(); //3.获取当前对象所有属性 try&#123; for(int i=0;i&lt;filedArray.length;i++)&#123; Field field = fieldArray[i]; field.setAccessible(true);//确保私有访问权限属性可以在class文件外使用 String fieldName = filed.getName();//获取属性名称 Object value = field.get(obj); //4.将获得属性以及其值拼接为json格式字符串 str.append(&quot;\\&quot;&quot;); str.append(filedName); str.append(&quot;\\&quot;:&quot;); str.append(&quot;\\&quot;&quot;); str.append(value); str.append(&quot;\\&quot;&quot;);//&#123;&quot;sid&quot;:&quot;10&quot;,&quot;sname&quot;:&quot;mike&quot;&#125; if(i&lt;fieldArray.length-1)&#123; str.append(&quot;,&quot;); &#125; &#125;catch(IllegalAccessException e)&#123; e.printStackTrace(); &#125;finally&#123; str.append(&quot;&#125;&quot;); &#125; &#125; return str.toString(); &#125;&#125;oneServlet调用: protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; Student stu = new Student(20,&quot;allen&quot;); //通过反射机制将Student类型对象转换为JSON格式字符串 String str = RelectUtil.jsonObject(stu); //将学员对象存入到请求作用于对象 request.setAttribute(&quot;key&quot;,str); //请求转发,向tomcat申请调用index_1.jsp,并将request和response 通过tomcat交给index_1.jsp requset.getRequestDispatcher(&quot;/index_1.jsp&quot;).forword(request,reponse); &#125;index_1.jsp:&lt;script type=&quot;text/javascript&quot;&gt; var stuObj = $&#123;requestScope.key&#125;;//从request作用域对象得到服务端提供的学生对象 window.alert(&quot;学员编号&quot;+stuObj.sid+&quot;学员姓名&quot;+stuObj.sname);&lt;/script&gt; 2.json数据在前端表格显示12345678910111213141516171819202122232425262728&lt;script type=&quot;text/javascript&quot;&gt; function init()&#123; var jsonArray = $&#123;requsetScope.key&#125;;//得到一个json数组[dept1,dept2....] for(var i=0;i&lt;jsonArray.length;i++)&#123; var jsonObj = jsonArray[i]; var trDom = doucment.createElement(&quot;tr&quot;)//&lt;tr&gt;&lt;/tr&gt; var tdDom_1 = doucment.createElement(&quot;td&quot;); var tdDom_2 = doucment.createElement(&quot;td&quot;); var tdDom_3 = doucment.createElement(&quot;td&quot;); tdDom_1.innerHTML = jsonObj.deptNo;//&lt;td&gt;10&lt;/td&gt; tdDom_2.innerHTML = jsonObj.dname;//&lt;td&gt;Accounting&lt;/td&gt; tdDom_3.innerHTML = jsonObj.loc;//&lt;td&gt;New York&lt;/td&gt; trDom.appendChid(tdDom_1);//将td添加到tr中 trDom.appendChid(tdDom_2); trDom.appendChid(tdDom_3); doucment.getElementById(&quot;one&quot;).appendChild(trDom);//将tr添加到表格中 &#125; &#125;&lt;/script&gt; &lt;body&gt; &lt;table boder=&quot;2&quot; align=&quot;center&quot; id=&quot;one&quot;&gt; &lt;tr&gt; &lt;td&gt;部门编号&lt;/td&gt; &lt;td&gt;部门名称&lt;/td&gt; &lt;td&gt;部门位置&lt;/td&gt; &lt;/tr&gt; &lt;/body&gt; 四:MVC开发规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667681.介绍: 1.MVC开发规则制定了互联网通信开发过程中必须出现角色有哪些 2.MVC开发规则制定了互联网通信开发过程中必须出现角色担任职责 3.MVC开发规则制定了互联网通信开发过程中必须出现角色的出场顺序 2.角色: DAO对象: DAO对象提供某张表文件的操作细节,降低对表文件操作难度 避免反复开发表文件操作的代码提高代码复用性 service对象: 服务对象,提供[业务]的具体解决方案 service对象一个方法指定一个业务的解决方案 避免业务开发重复性开发行为,提供复用性 网站每一个业务都有一个独立的标准解决方案 3.业务: 浏览器向Http服务器发送请求 用户向网站发送请求 4.业务特征: 1.真实业务场景中,一个业务往往包含多个分支任务,因此解决业务开发工作量往往比较大 2.真实业务场景中,只有所有分支任务都顺利成功解决,才可以认为当前业务处理成功 5.解决业务开发困扰: 1.一个业务可能在网站的多个地方重复出现,如果不做[封装],增加开发难度,进行业务解决代码重复性开发 2.[百人百味],不同程序员面对同一个业务时,给出解决方法往往有偏差,导致最终解决数据会有偏差 6.MVC开发规则-----互联网通信开发过程中必须出现的角色有哪些 一次互联网开发过程,必须出现角色有三个: C , controller object ; 控制层对象 (servlet对象) M , model object ; 业务模型对象 (Service对象) V , view object ; 视图层对象 (jsp or HttpServletResponse) 7.MVC开发规则--------------互联网开发过程中必须出现角色担负职责 C(Servlet对象): 1): [可以] 调用 [请求对象] 读取 [请求包] 参数信息 2): [必须] 调用 [Service对象] 处理业务 3): [必须] 调用 [视图层对象] 将结果写入到响应体 M(service对象): 1): 处理业务中所有分支任务 2): 根据分支任务执行情况判断业务是否处理成功 3): 必须通过return将处理结果返回给 [控制层对象] V(jsp/HttpServletRespnse) 1): [禁止参与业务处理] 2): 唯一任务将处理结果写入到响应体8.互联网通信开发过程中必须出现角色的出场顺序 发送请求 --------&gt;DeptDao业务 请求调用顺序: 浏览器-------&gt;Servlet-------&gt;Service ---------&gt;EmpDao业务 分支任务结果 DeptDao---------&gt; tomcat 响应顺序 分支任务结果 Service----&gt;Servlet----&gt;View----&gt;响应体-------&gt;浏览器 EmpDao----------&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Http网络协议包","slug":"Http网络协议包","date":"2020-10-15T13:40:48.416Z","updated":"2020-10-15T07:24:32.266Z","comments":true,"path":"2020/10/15/Http网络协议包/","link":"","permalink":"http://example.com/2020/10/15/Http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85/","excerpt":"","text":"一。网络协议包：12345678910111213141.在网络中传递信息都是以【二进制】形式存在的。2.接收方【浏览器/服务器】在接收信息后，要做第一件事 就是将【二进制数据】进行编译【文字，图片，视频，命令】3.传递信息数据量往往比较巨大，导致接收方很难在一组连续二进制得到对应数据 比如 浏览器发送一个请求： http://192.168.100.2:8080/index.html 这个请求信息以二进制形式发送 01010101010110101010101101010 Http服务器很难从二进制数据得到相关信息4.网络协议包一组有规律二进制数据，在这组数据存在了固定空间 每一个空间专门存放特定信息，这样接收方在接收网络协议包之后 就可以到固定空间得到对应信息，网络协议包出现极大降低了 接收方对接收二进制数据编译难度 【0000（ip地址）0000（端口号）0000（资源文件名）0000】 二。常见网络协议：1231.FTP网络协议包2.Http网络协议包 三。Http网络协议包：123456在基于B/S结构下互联网通信过程中，所有在网络中传递信息都是保存在Http网络协议包分类： Http请求协议包 Http响应协议包 四。Http请求协议包与Http响应协议包介绍:12345678910 1.Http请求协议包：在浏览器准备发送请求时，负责创建一个Http请求协议包浏览器将请求信息以二进制形式保存在Http请求协议包各个空间由浏览器负责将Http请求协议包推送到指定服务端计算机 2.Http响应协议包：Http服务器在定位到被访问的资源文件之后。负责创建一个Http响应协议包Http服务器将定位文件内容或则文件命令以二进制形式写入到Http响应协议包各个空间由Http服务器负责将Http响应协议包推送回发起请求的浏览器上。 ==五。Http请求协议包内部空间：【背】==123456789101112131415161718191.按照自上而下划分，分为4个空间2.空间划分: 请求行：[ url:请求地址（http://192.168.100.2:8080/index.html） method:请求方式（POST/GET） ] 请求头：[ 请求参数信息【GET】 ] 空白行：[ 没有任何内容，起到隔离作用 ] 请求体:[ 请求参数信息【POST】 ] ==六。Http响应协议包内部结构 【背】==123456789101112131415161718192021221.按照自上而下划分，分为4个空间2.空间划分: 状态行：[ Http状态码 ] 响应头：[ content-type: 指定浏览器采用对应编译器 对响应体二进制数据进行解析 ] 空白行：[ 没有任何内容，起到隔离作用 ] 响应体：[ 可能被访问静态资源文件内容 可能被访问的静态资源文件命令 可能被访问的动态资源文件运行结果 *****都是以二进制形式*** ]","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTML","slug":"HTML","date":"2020-10-15T13:40:48.412Z","updated":"2020-10-15T07:24:25.056Z","comments":true,"path":"2020/10/15/HTML/","link":"","permalink":"http://example.com/2020/10/15/HTML/","excerpt":"","text":"[toc] 一:语法规范1.换行HTML编程语言中所有命令都是声明在标签中,比如 2.HTML编程语言中所有命令都是预先定义好，不允许开发人员自行创建新的命令 3.HTML编程语言中所有命令不区分英文字母大小写，比如 1&lt;BR&gt; &lt;br&gt; &lt;Br&gt; 都是合法命令 4.HTML编程语言中命令开发时主要通过对命令中属性进行赋值实现开发目的。 属性赋值时内容可以包含一个””中，也可以包含在’’,也可以省略双引号与单引号，此时 属性之间必须采用空格进行隔离 123&lt;input type=&quot;text&quot; name=&quot;one&quot;/&gt;&lt;input type=&#x27;text&#x27; name=&#x27;one&#x27;/&gt;&lt;input type=text name=one/&gt; 5.HTML编程语言中命令根据书写方式分为：双目标签命令与单目标签命令6.双目标签命令书写命令分别出现在开始标签与结束标签，比如 双目标签命令在书写时结束标签是不能省略的,比如,由于没有书写结束标签因此是一个非法命令7.单目标签命令书写命令出现一个标签之内，比如：单目标签命令用于表示结束”/“可以省略不写，比如 , 这两个都是合法单目标签命令 2.基本格式设置和语言设置12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 二:==知识点总汇==1.浏览器发送请求三要素:123451.控制浏览器发送请求地址2.控制浏览器发送请求采用请求方式3.控制浏览器发送请求携带请求参数 2.控制浏览器发送请求地址1234567891011121314151617 1.超链接标签命令: 1)格式: &lt;a href=&quot;请求地址&quot;&gt;提示信息&lt;/a&gt; 2)工作原理: 超链接标签命令不会被浏览器自动执行。 在用户使用鼠标单击超链接标签命令时， 此时这个命令才会执行，执行要求浏览器 立刻按照href属性地址发送请求2.表单标签命令1)格式: &lt;form action=&quot;请求地址&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;!--提交按钮--&gt; &lt;/form&gt; 2)工作原理: 表单标签命令不会被浏览器自动执行。 在用户单击提交按钮时，此时表单标签命令 被触发执行。执行时要求浏览器立刻按照 action属性地址发送请求 3.控制浏览器发送请求采用请求方式123456789101112131415161718192021222324252627282930313233341.请求方式：决定浏览器在发送请求时行为特征 2.浏览器可以选择请求方式：7种，目前为止只考虑【POST请求方式】和【GET请求方式】3.GET请求方式: 1) 要求浏览器发送请求时，携带的【请求参数数量】不能超过4K 2) 要求浏览器发送请求时，必须在浏览器地址栏上将【请求参数信息】展示出来 3) 要求浏览器发送请求时，必须将请求参数信息保存在Http请求协议包中【请求头】 4) 要求浏览器在接收到服务器返回的资源文件内容后，必须将资源文件内容保存在浏览器的缓存4.POST请求方式： 1）要求浏览器发送请求时，可以携带任意数量的【请求参数】 2）要求浏览器发送请求时，必须在浏览器地址栏上隐藏请求参数信息 3）要求浏览器发送请求时，必须将请求参数信息保存在Http请求协议包中【请求体】 4）禁止浏览器将服务器返回资源文件内容进行保存【阅后即焚】5.控制浏览器发送请求时采用GET请求方式 1.超链接标签命令在执行时，要求浏览器必须采用GET方式发送请求 2.表单标签存在一个method属性，通过这个属性可以要求浏览器采用对应请求方式发送请求 &lt;form action=&quot;请求地址&quot; method=&quot;get&quot;&gt; &lt;form action=&quot;请求地址&quot; method=&quot;post&quot;&gt;***method属性默认值是GET&lt;form action=&quot;请求地址&quot;&gt;----&gt;浏览器以GET方式发送请求6.控制浏览器发送请求时采用POST请求方式 &lt;form method=&quot;post&quot;&gt;&lt;/form&gt;7.请求方式适用场景【面试】 1.考虑到POST请求方式，用户可以将【病毒文件内容】发送到服务器上进行攻击。 因此绝大多数门户级网站拒绝接收POST请求，日常开发过程绝大多数请求都是GET 2.在某些特殊场景下必须使用POST 1)文件上传，必须使用POST 2)发起登录验证请求，必须使用POST 3)索要服务器中实时变化数据时（股票价格，车票数量。。。），必须采用POST 4.控制浏览器发送请求携带请求参数1.请求参数作用:1234567891011121314比如用户通过浏览器访问服务端计算机动态资源文件Student.classclass Student&#123; public int add(int n1,int n2)&#123; //请求处理 int sum = n1 + n2; return sum; &#125;&#125; Http服务器： Student stu = new Student(); stu.add(?,?) //add方法运行时需要实参，需要由用户通过浏览器以请求参数方式提供 浏览器发送请求时需要携带调用方法需要实参（请求参数） http://www.baidu.com?n1=100&amp;n2=200 [n1=100&amp;n2=200]就是浏览器发送请求参数 2.请求参数格式1浏览器发送请求时 请求地址?请求参数名1&#x3D;值1&amp;请求参数名2&#x3D;值2 3.浏览器发送请求时携带的请求参数来源:121).通过超链接标签命令指定请求参数2).通过表单域标签命令指定请求参数 4.通过超链接标签命令指定请求参数1&lt;a href=&quot;http://www.baidu.com?userName=mike&amp;password=123&quot;&gt;百度&lt;/a&gt; 5.表单域标签命令:1234567891)一组声明在form标签内部的标签命令2)提示用户填写对应的【请求参数内容】，用于提供相对灵活的请求参数内容3)所有的表单域标签都拥有两个属性【name,value】 name属性声明【请求参数名】,value属性声明【请求参数内容】 &lt;form action=&quot;http://www.baidu.com&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; value=&quot;mike&quot;/&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;当用户单击submit后，浏览器发送请求信息 http://www.baidu.com?userName=mike 6.表单域标签分类：1231）&lt;input/&gt;2）&lt;select&gt;&lt;/select&gt;3）&lt;textarea&gt;&lt;/textarea&gt; 7.表单域标签value属性默认值121)大多数表单域标签value属性默认值是空字符串 userName=&#x27;&#x27;2)对于radio与checkbox来说，value属性默认值&#x27;on&#x27;字符串 8.表单域标签作为请求参数条件123456789101112 对于大多数表单域标签来说，只要同时满足一下两个条件，就可以作为请求参数 1)必须声明在form标签内部 2)必须声明name属性对于radio标签与checkbox标签来说在满足上述两个条件同时，还必须满足第三个条件才可以作为请求参数，3)第三个条件radio与checkbox必须在【被选中】的情况下才可以作为请求参数 如果表单域标签使用disabled来修饰时，失去作为请求参数条件 ***readOnly与disabled区别：readOnly：要求当前标签中value属性只能看但是不能被修改，readOnly不会影响表单域标签 作为请求参数条件disabled：设置当前标签为不可用状态，此时标签中value属性内容不能被修改的. disabled修饰的表单域标签是永远都不能作为请求参数 三:基本标签1.段落标签–p1&lt;p&gt;&lt;/p&gt; 2.标题标签–h112345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;h2&gt;标题标签&lt;/h2&gt; &lt;h3&gt;标题标签&lt;/h3&gt; &lt;h4&gt;标题标签&lt;/h4&gt; &lt;/body&gt;&lt;/html&gt; 3.有序标签–ol12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;ol&gt; &lt;li&gt;中国&lt;/li&gt; &lt;li&gt;德国&lt;/li&gt; &lt;li&gt;美国&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt;&lt;/html&gt; 4.无序标签–ul12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;中国&lt;/li&gt; &lt;li&gt;德国&lt;/li&gt; &lt;li&gt;美国&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 5.有序,无序嵌套123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;职员管理 &lt;ol&gt; &lt;li&gt;中国&lt;/li&gt; &lt;li&gt;德国&lt;/li&gt; &lt;li&gt;美国&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;部门管理 &lt;ol&gt; &lt;li&gt;部门注册&lt;/li&gt; &lt;li&gt;部门查询&lt;/li&gt; &lt;li&gt;部门更新&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 6.表格标签–table123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt; &lt;body&gt; &lt;table border=&quot;2&quot; align=&quot;center&quot;&gt; &lt;!--align:对齐方式--&gt; &lt;tr style=&quot;background-color:green&quot;&gt; &lt;td&gt;职员编号&lt;/td&gt; &lt;td&gt;职员姓名&lt;/td&gt; &lt;td&gt;职员职位&lt;/td&gt; &lt;td&gt;职员工资&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;smith&lt;/td&gt; &lt;td&gt;JAVA工程师&lt;/td&gt; &lt;td&gt;13000&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;mike&lt;/td&gt; &lt;td&gt;中级JAVA工程师&lt;/td&gt; &lt;td&gt;35000&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;allen&lt;/td&gt; &lt;td&gt;高级JAVA工程师&lt;/td&gt; &lt;td&gt;55000&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;40&lt;/td&gt; &lt;td&gt;king&lt;/td&gt; &lt;td&gt;架构师&lt;/td&gt; &lt;td&gt;85000&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 7.rowspan标签1.==行==合并 2.即相同的属性可以合并为一个单元格 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;html&gt; &lt;body&gt; &lt;table border=&quot;2&quot; align=&quot;center&quot;&gt; &lt;tr style=&quot;background-color:green&quot;&gt; &lt;td&gt;部门名称&lt;/td&gt; &lt;td&gt;职员编号&lt;/td&gt; &lt;td&gt;职员姓名&lt;/td&gt; &lt;td&gt;职员职位&lt;/td&gt; &lt;td&gt;职员工资&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td rowspan=&quot;3&quot;&gt;金融事业部&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;smith&lt;/td&gt; &lt;td&gt;JAVA工程师&lt;/td&gt; &lt;td&gt;13000&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;mike&lt;/td&gt; &lt;td&gt;中级JAVA工程师&lt;/td&gt; &lt;td&gt;35000&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;allen&lt;/td&gt; &lt;td&gt;高级JAVA工程师&lt;/td&gt; &lt;td&gt;55000&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt;云仓库&lt;/td&gt; &lt;td&gt;40&lt;/td&gt; &lt;td&gt;king&lt;/td&gt; &lt;td&gt;架构师&lt;/td&gt; &lt;td&gt;85000&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 8.colspan标签1.==列==合并 2.即单元格不够(空白的)的可以扩充宽度,与下面多余的对其,保持整体充满 1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt; &lt;body&gt; &lt;table border=2 align=&quot;center&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;学员名称&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;学习科目&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;mike&lt;/td&gt; &lt;td&gt;96&lt;/td&gt; &lt;td&gt;89&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;jones&lt;/td&gt; &lt;td&gt;67&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;92&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;allen&lt;/td&gt; &lt;td&gt;78&lt;/td&gt; &lt;td&gt;70&lt;/td&gt; &lt;td&gt;78&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 9.图片标签–src123456789101112&lt;html&gt; &lt;body&gt; &lt;center&gt; &lt;div&gt; &lt;font style=&quot;font-size:50&quot;&gt;怀念我的恩师&lt;/font&gt; &lt;/div&gt; &lt;div style=&quot;border:1px solid black;width:500;height:500&quot;&gt; &lt;img src=&quot;cuicui.jpg&quot; title=&quot;崔手凉老师&quot; width=300 height=300 style=&quot;margin:50&quot;/&gt; &lt;div&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 10.超链接–href要求浏览器必须采用GET方式发送请求 123456&lt;html&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;图片标签.html&quot;&gt;我的恩师&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 11.表单–from表单标签存在一个method属性，通过这个属性可以要求浏览器采用对应请求方式发送请求 1234&lt;form action=&quot;请求地址&quot; method=&quot;get&quot;&gt;&lt;form action=&quot;请求地址&quot; method=&quot;post&quot;&gt;***method属性默认值是GET&lt;form action=&quot;请求地址&quot;&gt;----&gt;浏览器以GET方式发送请求 1234567&lt;html&gt; &lt;body&gt; &lt;form action=&quot;http://www.sina.com&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;新浪&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12.==input标签==1.单选框:radio2.多选框:checkbox3.文件:file4.多行文本框:textarea5.重置:reset1234567891011121314151617181920212223&lt;html&gt; &lt;form action=&quot;http://www.baidu.com&quot;&gt; 用户姓名&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/br&gt; 用户密码&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;/br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;woman&quot;&gt;&lt;/br&gt; &lt;!--单选框radio,当name相同时表示是同一组,只能选一个--&gt; 擅长的技术:&lt;input type=&quot;checkbox&quot; name=&quot;技术&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;技术&quot; value=&quot;c++&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;技术&quot; value=&quot;mysql&quot;&gt;mysql &lt;!--多选框--&gt; 用户头像:&lt;input type=&quot;file&quot; name=&quot;myfile&quot;/&gt;&lt;br/&gt; &lt;!--文件选择框,将选中的文件内容作为请求参数内容--&gt; 备注信息:&lt;textarea name=&quot;tt&quot; rows=10 cols=30&gt;&lt;/textarea&gt; &lt;!--rows:在界面上显示的行数 cols:每行可以写的字个数--&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;!--提交按钮,属于表单域标签,但是用于触发form命令,不作为请求参数使用--&gt; &lt;input type=&quot;reset&quot;/&gt; &lt;!--重置标签,属于表单域标签,但是用于将form表单域标签value设置初始值,即清空,不作为请求参数使用--&gt; &lt;/form&gt;&lt;/html&gt; 13.下拉列表:select123456789101112&lt;html&gt; &lt;center&gt; &lt;form action=&quot;http://www.baidu.com&quot;&gt; 籍贯:&lt;select name=&quot;home&quot;&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;tj&quot;&gt;天津&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot;/&gt;&lt;input type=&quot;reset&quot;/&gt; &lt;/form&gt; &lt;/center&gt;&lt;/html&gt; 14.disable,readonly标签–不可更改1234567&lt;html&gt; &lt;form action=&quot;http://www.baidu.com&quot;&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;sex&quot; value=&quot;man&quot; disabled&gt;性别不能改&lt;br/&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; value=&quot;mike&quot; readOnly&gt;姓名不能改,只读&lt;br/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"EL表达式","slug":"EL表达式","date":"2020-10-15T13:40:48.409Z","updated":"2020-10-15T07:24:20.812Z","comments":true,"path":"2020/10/15/EL表达式/","link":"","permalink":"http://example.com/2020/10/15/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"一:作用1代替响应对象,将servlet中doGet&#x2F;doPost的执行结果写入到响应体 二:EL表达式12345671.命令格式：$&#123;作用域对象别名.共享数据&#125;2.命令作用： 1）EL表达式是EL工具包提供一种特殊命令格式【表达式命令格式】 2）EL表达式在JSP文件上使用 3）负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体 三:EL表达式——作用域对象别名123456789101112131415161718192021222324251.JSP文件可以使用的作用域对象 1) ServletContext application: 全局作用域对象 2) HttpSession session: 会话作用域对象 3) HttpServletRequest request: 请求作用域对象 4) PageContext pageContext： 当前页作用域对象，这是JSP文件独有的作用域对象。Servlet中不存在,在当前页作用域对象存放的共享数据仅能在当前JSP文件中使用，不能共享给其他Servlet或则其他JSP文件,真实开发过程，主要用于JSTL标签与JSP文件之间数据共享 数据 JSTL-------&gt;pageContext----&gt;JSP 2.EL表达式提供作用域对象别名 JSP EL表达式 application $&#123;applicationScope.共享数据名&#125; session $&#123;sessionScope.共享数据名&#125; request $&#123;requestScope.共享数据名&#125; pageContext $&#123;pageScope.共享数据名&#125; 四:jsp获取数据1234567891011121314151617181920212223242526272829public class OneServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.分别将共享数据添加到作用域对象 ServletContext application = request.getServletContext(); HttpSession session = request.getSession(); application.setAttribute(&quot;sid&quot;, 10); session.setAttribute(&quot;sname&quot;, &quot;mike&quot;); request.setAttribute(&quot;home&quot;, &quot;新起屯&quot;); //2.通过请求转发方式，向Tomcat申请调用index_1.jsp，由index_1.jsp负责将 // 作用域对象共享数据读取并写入到响应体，交给浏览器 request.getRequestDispatcher(&quot;/index_1.jsp&quot;).forward(request, response); &#125;&#125;旧的获取数据的方法,比较繁琐:index.jsp:&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% Integer sid =(Integer) application.getAttribute(&quot;sid&quot;); String sname= (String)session.getAttribute(&quot;sname&quot;); String home= (String)request.getAttribute(&quot;home&quot;);%&gt;学员ID:&lt;%=sid%&gt;&lt;br/&gt;学员姓名:&lt;%=sname%&gt;&lt;br/&gt;学员地址:&lt;%=home%&gt; 1234EL表达式获取:学员ID: $&#123;applicationScope.sid&#125;&lt;br/&gt;-----&gt;applicationScope是全局作用域对象的别名学员姓名: $&#123;sessionScope.sname&#125;&lt;br/&gt;学员地址：$&#123;requestScope.home&#125; 五:EL表达式将引用对象属性写入到响应体1234567891.命令格式: $&#123;作用域对象别名.共享数据名.属性名&#125;2.命令作用: 从作用域对象读取指定共享数据关联的引用对象的属性值。 并自动将属性的结果写入到响应体3.属性名： 一定要去引用类型属性名完全一致（大小写）4.EL表达式没有提供遍历集合方法，因此无法从作用域对象读取集合内容输出 例子: 1234567891011public class OneServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建一个引用类型实例对象 Student stu = new Student(20, &quot;allen&quot;); //2.将引用类型对象存入到请求作用域对象作为共享数据 request.setAttribute(&quot;key&quot;, stu); //3.请求转发，向Tomcat申请调用index_1.jsp request.getRequestDispatcher(&quot;/index_1.jsp&quot;).forward(request, response); &#125;&#125; 123index_1.jsp:学员编号:$&#123;requestScope.key.sid&#125;&lt;br/&gt;&lt;!--sid来自于Student类属性名，大小写完全一致--&gt;学员姓名:$&#123;requestScope.key.sname&#125; 六:El表达式简化版1234567891011121314151617181920212223241.命令格式： $&#123;共享数据名&#125;2.命令作用： EL表达式允许开发人员开发时省略作用域对象别名3.工作原理： EL表达式简化版由于没有指定作用域对象，所以在执行时采用【猜】算法 首先到【pageContext】定位共享数据，如果存在直接读取输出并结束执行 如果在【pageContext】没有定位成功，到【request】定位共享数据，如果存在直接读取输出并结束执行 如果在【request】没有定位成功，到【session】定位共享数据，如果存在直接读取输出并结束执行 如果在【session】没有定位成功，到【application】定位共享数据，如果存在直接读取输出并结束执行 如果在【application】没有定位成功，返回null pageContext---&gt;request---&gt;session---&gt;application4.存在隐患： 容易降低程序执行速度【南辕北辙】 容易导致数据定位错误5.应用场景： 设计目的，就是简化从pageContext读取共享数据并输出难度6.EL表达式简化版尽管存在很多隐患，但是在实际开发过程中，开发人员为了节省时间，一般都使用 简化版，拒绝使用标准版 七:EL表达式—–支持运算表达式1234567891.前提： 在JSP文件有时需要将读取共享数据进行一番运算之后，将运算结果写入到响应体2.运算表达式: 1) 数学运算 2) 关系运算: &gt; &gt;= == &lt; &lt;= != gt ge eq lt le != 3)逻辑运算： &amp;&amp; || ！ 相加: 1234567891011121314151617181920212223public class OneServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;key1&quot;, &quot;100&quot;); request.setAttribute(&quot;key2&quot;, 200); request.getRequestDispatcher(&quot;/index_1.jsp&quot;).forward(request, response); &#125;&#125;index_1.jsp:&lt;!--将作用域对象中共享数据读取出来相加，将相加结果写入到响应体--&gt;&lt;% String num1 = (String)request.getAttribute(&quot;key1&quot;); Integer num2 = (Integer)request.getAttribute(&quot;key2&quot;); int sum = Integer.valueOf(num1) + num2;%&gt;传统的Java命令计算后的结果:&lt;%=sum%&gt;EL表达式计算后的结果:$&#123;key1+key2&#125; 比较: 123456789101112131415161718192021222324public class TwoServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;age&quot;, &quot;25&quot;); request.getRequestDispatcher(&quot;/index_2.jsp&quot;).forward(request, response); &#125;&#125;index_2.jsp:&lt;!--传统Java命令方式实现关系运算输出--&gt;&lt;% String age = (String)request.getAttribute(&quot;age&quot;); if(Integer.valueOf(age)&gt;=18)&#123;%&gt; 欢迎光临&lt;br/&gt;&lt;% &#125;else&#123;%&gt; 谢绝入内&lt;br/&gt;&lt;% &#125;%&gt;EL表达式输出关系运算: $&#123;age ge 18?&quot;欢迎光临&quot;:&quot;谢绝入内&quot;&#125; 八:EL表达式提供内置对象1234567891011121314151.命令格式: $&#123;param.请求参数名&#125; 2.命令作用： 通过请求对象读取当前请求包中请求参数内容 并将请求参数内容写入到响应体 3.代替命令: index.jsp 发送请求： Http://localhost:8080/myWeb/index.jsp?userName=mike&amp;password=123 &lt;% String userName = request.getParameter(&quot;userName&quot;); String password = request.getParameter(&quot;password&quot;); %&gt; &lt;%=userName%&gt; &lt;%=password%&gt; 例子: 123456&lt;!-- http:&#x2F;&#x2F;localhost:8080&#x2F;myWeb&#x2F;index_1.jsp?userName&#x3D;mike&amp;password&#x3D;123--&gt;来访者姓名:$&#123;param.userName&#125;&lt;br&#x2F;&gt;来访者密码:$&#123;param.password&#125; 123456789101112131415161718192021222324252. 1.命令格式：$&#123;paramValues.请求参数名[下标]&#125; 2.命令作用: 如果浏览器发送的请求参数是[一个请求参数关联多个值] 此时可以通过paramVaues读取请求参数下指定位置的值 并写入到响应体 3.代替命令: http://localhost:8080/myWeb/index_2.jsp?pageNo=1&amp;pageNo=2&amp;pageNo=3 此时pageNo请求参数在请求包以数组形式存在 pageNo:[1,2,3] &lt;% String array[]= request.getParameterValues(&quot;pageNo&quot;); %&gt; 第一个值:&lt;%=array[0]%&gt; 第二个值:&lt;%=array[1]%&gt; 例子:&lt;!--http://localhost:8080/myWeb/index_2.jsp?deptNo=10&amp;deptNo=20&amp;deptNo=30--&gt;第一个部门编号:$&#123;paramValues.deptNo[0]&#125;&lt;br/&gt;第二个部门编号:$&#123;paramValues.deptNo[1]&#125;&lt;br/&gt;第三个部门编号:$&#123;paramValues.deptNo[2]&#125;&lt;br/&gt; 九:随机查询123select rand() #随机返回0-1之间的小数select * from question order by rand() limit 0,4 #rand()放在order by之后会生成随机整数 rand() 0.5---&gt; order by 5","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"dubbo","slug":"dubbo","date":"2020-10-15T13:40:48.407Z","updated":"2020-10-15T07:24:15.868Z","comments":true,"path":"2020/10/15/dubbo/","link":"","permalink":"http://example.com/2020/10/15/dubbo/","excerpt":"","text":"快捷键: 1.alt+下划线字母 —&gt;打开相对应的选项 2.ctrl+shift+f12—-&gt;切换大小窗口 3.ctrl-shift+o—-&gt;翻译 4.alt+左右键盘—&gt;切换不同的窗口 5.ctrl+I —&gt;重写方法 6.ctrl+alt+L—&gt;格式化pom.xml依赖格式 步骤创建三个web工程: 1.link-interface—&gt;对外的接口 它是一个maven工程,dubbo官方推荐使用的一个模式,将实体bean和业务接口存放到接口工程中 2.link-userservice-provider—&gt;实现接口业务方法,并且暴漏这些接口 3.consumer—&gt;调用 interface注意:这里的实体类要实现序列化Serializable 12345678910111213141516171819202122232425262728293031public class Student implements Serializable &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 123456789101112public interface UserService &#123; /** * 根据用户标识获取用户的信息 * @param id * @param username * @return */ User queryUserById(Integer id,String username);&#125; link-userservice-providedubbo-zk-userservice-provider.xml:123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--声明dubbo服务提供者的名称:保证唯一性--&gt; &lt;!--这里application选择的是第二个http://dubbo.apache.org/schema/dubbo--&gt; &lt;dubbo:application name=&quot;007-zk-userservice-provider&quot;/&gt; &lt;!--声明dubbo使用的协议名称和端口号--&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!--现在要使用zookeeper注册中心--&gt; &lt;!--指定注册中心地址和端口号--&gt; &lt;!--&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;--&gt; &lt;!--使用linux系统中的zookeeper服务,使用虚拟机中linux的ip地址,用ifconfig查看--&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.154.128:2181&quot;/&gt; &lt;!--暴露服务接口--&gt; &lt;dubbo:service interface=&quot;com.bjpowernode.dubbo.service.UserService&quot; ref=&quot;userServiceImpl&quot;/&gt; &lt;!--加载接口实现类--&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.bjpowernode.dubbo.service.impl.UserServiceImpl&quot;/&gt;&lt;/beans&gt; pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;dependencies&gt; &lt;!--Spring依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Dubbo依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--接口工程依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.bjpowernode.dubbo&lt;/groupId&gt; &lt;artifactId&gt;006-zk-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--zookeeper依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--JDK1.8编译插件--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; web.xml:注册监听器1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dubbo-zk-userservice-provider.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; consumerdobbo-zk-consumer.xml:1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--声明dubbo服务消费者名称:保证唯一性--&gt; &lt;dubbo:application name=&quot;008-zk-consumer&quot;/&gt; &lt;!--指定注册中心--&gt; &lt;!--&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;--&gt; &lt;!--使用linux系统中的zookeeper服务--&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.154.128:2181&quot;/&gt; &lt;!--引用远程接口服务--&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.bjpowernode.dubbo.service.UserService&quot;/&gt;&lt;/beans&gt; applicationContext.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.bjpowernode.dubbo.web&quot;/&gt; &lt;!--配置注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!--格式化:ctrl+alt+L--&gt; &lt;dependencies&gt; &lt;!--Spring依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dubbo依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--接口工程--&gt; &lt;dependency&gt; &lt;groupId&gt;com.bjpowernode.dubbo&lt;/groupId&gt; &lt;artifactId&gt;006-zk-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--注册中心依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--JDK1.8编译插件--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; web.xml:注册中央调度器123456789101112&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml,classpath:dubbo-zk-consumer.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Controller调用:123456789101112131415161718192021@Controllerpublic class UserController &#123; @Autowired private UserService userService; @Autowired private UserService userService2; @RequestMapping(value = &quot;/userDetail&quot;) public String userDetail(Model model,Integer id,String username) &#123; User user = userService.queryUserById(id, username); User user2 = userService2.queryUserById(id,username); model.addAttribute(&quot;user&quot;,user); model.addAttribute(&quot;user2&quot;,user2); return &quot;userDetail&quot;; &#125; 思路1234567思路:1.创建一个maven web工程:服务的消费者2.配置pom文件:添加需要的依赖(spring,dubbo)3.设置dubbo的核心配置文件()4.编写controller5.配置中央调度器(就是一个servlet:DispatcherServlet)","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"CSS","slug":"CSS","date":"2020-10-15T13:40:48.404Z","updated":"2020-10-15T07:24:10.124Z","comments":true,"path":"2020/10/15/CSS/","link":"","permalink":"http://example.com/2020/10/15/CSS/","excerpt":"","text":"[toc] 一:介绍121.是一种专门在浏览器编译并执行的编程语言.2.用于定位浏览器中HTML标签并对定位的HTML标签中【样式属性】进行统一管理 二:HTML标签属性分类1.基本属性12345678大多数HTML标签都拥有属性，是一个非常庞大群体比如 id属性，相当于身份证编号，用于区分HTML标签input type=&quot;text&quot; id=&quot;one&quot;/&gt;&lt;input type=&quot;text&quot; id=&quot;two&quot;/&gt;比如 name属性，相当于人名字,允许一组标签拥有相同name&lt;input type=&quot;text&quot; id=&quot;one&quot; name=&quot;myText&quot;/&gt;&lt;input type=&quot;text&quot; id=&quot;two&quot; name=&quot;myText&quot;/&gt; 2.样式属性12是一个非常庞大群体，通知浏览器将HTML标签中数据在浏览器中以指定形态展示&lt;div style=&quot;background-color:red;width:300px;height:200px;font-size:50;color:red&quot;&gt;&lt;/div&gt; 3.工作状态属性:12345只存在于【表单域标签】中，用于表示【表单域标签】状态.checked:存在于radio与checkbox中，表示标签是否被选中disabled:表示标签处于不可用状态readOny:表示标签处于只读状态seleteced：存在option标签，表示标签是否被选中 4.监听属性123456监听属性用户与HTML标签之间进行通信通道，监听属性用于监听用户在何时对当前标签进行何种操作,当指定操作产生时，监听属性将会通知浏览器调用对应JavaScript方法处理当前请求例如: mouseover(鼠标悬停) 三:样式属性开发难度12341.由于网页经常出现大量的HTML标签拥有相同的样式属性设置，因此导致 前端工程师进行大量重复性开发操作.2.当用户修改需求时，导致前端工程师进行大量重复维护工作 四:css编程语言作用121.通知浏览器将所有满足定位条件的HTML标签进行统一定位2.通知浏览器对已经定位HTML标签中样式属性进行集中统一赋值管理 五:CSS选择器:123456789101112131415161.介绍：CSS选择器，实际上就是一组定位条件用于定位HTML标签。CSS选择器有9个大的分类2.CSS选择器语法格式:&lt;html&gt; &lt;head&gt; &lt;!--type=&#x27;text/css&#x27;，--&gt; &lt;style type=&quot;text/css&quot;&gt; 定位条件&#123; &quot;样式属性1&quot;:&quot;值1&quot;; &quot;样式属性2&quot;：&quot;值2&quot; &#125; &lt;/style&gt; &lt;/head&gt;&lt;/html&gt; 六:ID选择器:12345678910 1.介绍： 根据HTML标签中ID属性的值进行定位2.语法:&lt;style type=&quot;text/css&quot;&gt; #id编号&#123; &quot;样式属性1&quot;:&quot;值1&quot;; &quot;样式属性2&quot;：&quot;值2&quot; &#125;&lt;/style&gt; 例子: 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; #one&#123; font-size:50; color:red &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;one&quot;&gt;这是第一个段落标签&lt;/p&gt; &lt;p id=&quot;one&quot;&gt;这是第一个段落标签&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 七:标签类型选择器:123456789101.介绍:根据HTML标签类型进行定位2.语法: &lt;style type=&quot;text/css&quot;&gt; 标签类型名&#123; &quot;样式属性1&quot;:&quot;值1&quot;; &quot;样式属性2&quot;：&quot;值2&quot; &#125; &lt;/style&gt; 例子: 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; width:100; height:100; background-color:green; border:2px solid yellow; &#125; p&#123; color:Red; font-size:30 &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是第一个div&lt;/div &lt;p&gt;这是第一个段落标签&lt;/p&gt; &lt;div&gt;这是第二个div&lt;/div &lt;p&gt;这是第二个段落标签&lt;/p&gt; &lt;div&gt;这是第三个div&lt;/div &lt;p&gt;这是第三个段落标签&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 八:层级选择器123456789101112131415161718192021222324252627282930313233 1.HTML标签之间关系： 父子关系 兄弟关系 2.父子关系: 即为包含关系 &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;text&quot;&gt; &lt;/td&gt; &lt;/tr&gt; td标签是tr标签的子标签 input标签是td标签的子标签3.兄弟关系: 一组标签拥有相同的父标签，并且彼此之间 没有任何包含关系，即为兄弟 &lt;body&gt; &lt;div&gt;1&lt;/div&gt; 大哥 &lt;p&gt;2&lt;/p&gt; 二哥 &lt;span&gt;3&lt;/span&gt; 三弟 &lt;/body&gt;4.层级选择器介绍: 根据标签之间父子关系或则兄弟关系进行定位5.简单的层级选择器&lt;style type=&quot;text/css&quot;&gt; 定位父标签条件 定位子标签条件&#123; 找到指定父标签下满足条件的所有子标签&lt;/style&gt; 例子: 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; #one p&#123; font-size:30; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;one&quot;&gt; &lt;p&gt; 这是第一个段落标签&lt;/p&gt; &lt;p&gt; 这是第二个段落标签&lt;/p&gt; &lt;p&gt; 这是第三个段落标签&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;two&quot;&gt; &lt;p&gt; 这是第四个段落标签&lt;/p&gt; &lt;p&gt; 这是第五个段落标签&lt;/p&gt; &lt;p&gt; 这是第六个段落标签&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 九:自定义选择器1234567891011121314 1.介绍： 如果一组HTML标签之间没有相同的特征，但是却需要 对指定属性赋值相同内容，此时将自定义选择器绑定 到对应标签上2.语法:&lt;style type=&quot;text/css&quot;&gt; .自定义选择器名&#123; color:red; &#125;&lt;/style&gt;&lt;div class=&quot;自定义选择器名&quot;&gt;&lt;/div&gt;&lt;p class=&quot;自定义选择器名&quot;&gt;&lt;/p&gt; 例子: 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; .redStyle&#123; color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;one&quot;&gt; &lt;p&gt; 这是第一个段落标签&lt;/p&gt; &lt;p class=&quot;redStyle&quot;&gt; 这是第二个段落标签&lt;/p&gt;&lt;!--此处变成红色字体--&gt; &lt;p&gt; 这是第三个段落标签&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;two&quot;&gt; &lt;p&gt; 这是第四个段落标签&lt;/p&gt; &lt;p&gt; 这是第五个段落标签&lt;/p&gt; &lt;p class=&quot;redStyle&quot;&gt; 这是第六个段落标签&lt;/p&gt;&lt;!--此处变成红色字体--&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"CRM项目知识点补充","slug":"CRM项目知识点补充","date":"2020-10-15T13:40:48.399Z","updated":"2020-10-15T07:24:05.518Z","comments":true,"path":"2020/10/15/CRM项目知识点补充/","link":"","permalink":"http://example.com/2020/10/15/CRM%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/","excerpt":"","text":"一:AJAX12345678910111213141516关于同步和异步： 设置 async:true 异步 通过观察得到结果，下面的alert弹框没有等到上面的ajax执行完毕，就执行了 全程是两根线程，一根主线程负责执行方法中普通的代码，一根线程负责执行ajax 两根线程彼此之间相互独立，互相是不受影响的 async:false 同步 通过观察得到结果，下面的alert弹框必须要等到上面的ajax执行完毕后，才能够执行 全程是一根线程，线程是按照代码从上向下的顺序依次执行 下面的代码必须要等到上面的代码执行完毕后，才能够执行 未来实际项目开发中，一般情况下，我们都是使用异步请求可以有效的提升用户体验 在特殊需求下，也会使用到同步 1.设置全局的绝对路径1234567&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;// 2.JSON12格式: //一般key和value都要加双引号,数字类型和boolean类型的valu可以不用加双引号 &#123;&quot;string&quot;:&quot;abc&quot;,&quot;num&quot;:10,&quot;success&quot;:true&#125; 3.json应用 如果后端传入json,jsp中alert(data)的类型是object Object servlet 123456789101112131415161718public class MyServlet02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;进入到servlet02&quot;); //&#123;&quot;str1&quot;:&quot;aaa&quot;,&quot;str2&quot;:&quot;bbb&quot;&#125; String str = &quot;&#123;\\&quot;str1\\&quot;:\\&quot;aaa\\&quot;,\\&quot;str2\\&quot;:\\&quot;bbb\\&quot;&#125;&quot;; PrintWriter out = response.getWriter(); out.print(str); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;mytitle&lt;/title&gt; &lt;script src=&quot;js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;#djBtn&quot;).click(function () &#123; //$(&quot;#msg&quot;).html(123); $.ajax(&#123; url : &quot;myServlet02.do&quot;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function (data) &#123; //alert(data); //object Object //我们是以json.key的形式来取得value alert(data.str2); &#125; &#125;) &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;djBtn&quot;&gt;点击&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 4.domin:领域模型123pojo, bean, javabeen, 实体类//实体类是为了方便和数据库交互,每一张表都对应一个实体类,并且数据库中表中每一个字段都与实体类//的属性相对应,其中每个属性都是private,set个get方法为了方便存取值 实体类的无参构造方法是为了反射 5.以后最常用的json格式多个json对象的嵌套: 1&#123;&quot;s1&quot;:&#123;&quot;id&quot;:&quot;?&quot;,&quot;name&quot;:&quot;?&quot;,&quot;age&quot;:?&#125;,&quot;s2&quot;:&#123;&quot;id&quot;:&quot;?&quot;,&quot;name&quot;:&quot;?&quot;,&quot;age&quot;:?&#125;&#125; 取值: 1234567891011success : function (data) &#123; $(&quot;#id1&quot;).html(data.s1.id); $(&quot;#name1&quot;).html(data.s1.name); $(&quot;#age1&quot;).html(data.s1.age); $(&quot;#id2&quot;).html(data.s2.id); $(&quot;#name2&quot;).html(data.s2.name); $(&quot;#age2&quot;).html(data.s2.age); &#125; 6.jQuery存取值理解1234567891011121314151617相当于原生js的 document.getElementById(“”).value针对于表单元素的value属性值的存取值操作例如input,selectval(值):存值val():取值相当于原生js的document.getElementById(“”).innerHTML针对于标签对中的内容的存取值操作该形式对于html元素，随着内容可以动态的赋予html(“&lt;font color=’red’&gt;aaa&lt;/font&gt;”):存值html():取值与上述的html()方法非常相似，也是针对于标签对中的内容的存取值操作与上述html()方法不同的是，text()方法只针对于内容本身，不注重html元素的动态赋予text(“aaa”):text(): 7.前后端传值方式123456789101112前端为后端传值，一般都叫做传参数url?key1=value1&amp;key2=value2form nameajax data:&#123;&#125;以上都是前端为后台提供参数的方式，但是不论你使用的是哪种形式为后台提供参数，后台一律使用String value = request.getParameter(key)的形式来接收参数 特殊形式：同一个key下有多个value例如，执行批量删除的操作xxx/xxx/delete.do?id=A0001&amp;id=A0002&amp;id=A0003String ids[] = request.getParameterValues(“id”); 8.数据库补充 OA–&gt;办公自动化系统 CRM—&gt;客户关系管理系统 CMS—&gt;内容管理系统 以后一般都是一对多或者多对一的关系,设置外键时一般都在多的一方设置 9.UUID12345678910111213public class Test1 &#123; public static void main(String[] args) &#123; UUID uuid = UUID.randomUUID(); String str = uuid.toString(); str = str.replaceAll(&quot;-&quot;, &quot;&quot;); System.out.println(str); System.out.println(str.length()); &#125;&#125; 实际项目开发中，很少使用整型作为主键来使用 实际项目开发中，使用字符串当做主键字段类型比较多 UUID 使用UUID会为我们生成一组由数字字母以及横杆所组成的随机串，这个随机串有36位，这个随机串一定是全世界唯一的。 char和varchar的区别 char–&gt;不可变长 varchar–&gt;可变长 char类型可以提高sql效率,一般用于已知长度的定量 二:MyBatis1.使用步骤一张表操作对应一个mapper文件 1.xxxMapper.xml创建与实体类对应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace:命名空间 不同的mapper映射文件使用namespace来做区分 不同的mapper映射文件所使用的namespace的命名不允许出现重复 使用命名空间.sqlId的形式来找到我们想要执行的sql语句 test1.getById1--&gt;&lt;mapper namespace=&quot;test1&quot;&gt; &lt;!-- sql语句必须要写在相应的标签当中 &lt;insert&gt;:在标签对中写insert开头的sql语句 处理添加操作 &lt;update&gt;:在标签对中写update开头的sql语句 处理修改操作 &lt;delete&gt;:在标签对中写delete开头的sql语句 处理删除操作 &lt;select&gt;:在标签对中写select开头的sql语句 处理查询操作 parameterType:为sql语句传递的参数的类型 --&gt; &lt;select id=&quot;getById&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select * from tbl_student where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 如果返回的是多条记录，那么resultType返回值类型，应该写为集合的泛型 --&gt; &lt;select id=&quot;getAll&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt; select * from tbl_student &lt;/select&gt; &lt;!-- 注意： 在未来实际项目开发中 所有的标签都必须要写id属性 &lt;select&gt;标签parameterType属性可以省略不写 resultType属性必须得写 对于&lt;insert&gt;&lt;update&gt;&lt;delete&gt;这3个标签 通常我们只写id属性，其他属性一概不写 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.bjpowernode.domain.Student&quot;&gt; insert into tbl_student(id,name,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot;&gt; update tbl_student set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;delete&quot;&gt; delete from tbl_student where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 2.mybatis-config.xml用来注册每个mapper文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt; &lt;mapper resource=&quot;com/bjpowernode/mapper/StudentMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.bjpowernode.test;import com.bjpowernode.domain.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * Author 北京动力节点 */public class Test1 &#123; public static void main(String[] args) &#123; String resource = &quot;mybatis-config.xml&quot;; //输入流 InputStream inputStream = null; try &#123; //通过加载MyBatis的主配置文件mybatis-config.xml，创建输入流对象 inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; /* SqlSessionFactoryBuilder:SqlSessionFactory的建造者 通过该建造者对象调用建造方法，为我们创建一个SqlSessionFactory对象 sqlSessionFactory对象唯一的作用就是为我们创建SqlSession对象 */ SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //我们未来所有的操作，使用的都是SqlSession对象session来完成 //例如增删改查，处理事务等等，都是统一使用session对象来完成 SqlSession session = sqlSessionFactory.openSession(); /* 需求：根据id查单条 如果取得的是单条记录，我们调用selectOne方法 参数1：根据命名空间.sqlId的形式找到我们需要使用的sql语句 参数2：我们要为sql语句中传递的参数 */ Student s = session.selectOne(&quot;test1.getById&quot;, &quot;A0001&quot;); System.out.println(s); session.close(); //查询学生信息表中所有的记录 List&lt;Student&gt; sList = session.selectList(&quot;test1.getAll&quot;); for(Student s:sList)&#123; System.out.println(s); &#125; session.close(); /* MyBatis默认情况下是手动提交事务*/ //添加操作 Student s = new Student(); s.setId(&quot;A0006&quot;); s.setName(&quot;cxk&quot;); s.setAge(23); session.insert(&quot;test1.save&quot;, s); session.commit();//事务提交 session.close(); //修改操作 Student s = new Student(); s.setId(&quot;A0006&quot;); s.setName(&quot;cxk1&quot;); s.setAge(24); session.update(&quot;test1.update&quot;, s); session.commit(); session.close(); //删除操作 session.delete(&quot;test1.delete&quot;, &quot;A0006&quot;); session.commit(); session.close(); &#125;&#125; 4.==注意事项== 我们未来所有的操作，使用的都是SqlSession对象session来完成 实体类pojo—&gt;domain 所有的标签都必须要写id属性,标签parameterType属性可以省略不写,resultType属性必须得写 对于这3个标签,通常我们只写id属性，其他属性一概不写 MyBatis默认情况下是手动提交事务,需要手动seesion.commit() 最后要写session.close() 2.mybatis结合dao层开发三:MyBatis配置文件1.db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=123456 2.mybatis-config.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;!-- 设置与数据库交互的环境 例如可以在此处配置二级缓存，配置查询延迟加载策略等等... 配置的目的是为了更加有效的查询表中的记录 在实际项目开发中，settings的设置基本没用 因为settings对于查询的优化，得到的效果不明显 对于海量级别的数据，使用settings配置优化，起不到任何的效果 对于数据量较少的项目，对于查询的效率要求的比较低，也没有必要使用settings配置 如果遇到了海量级别的数据，我们如何去提高查询的效率呢？ 基础操作 对于常用的查询条件的字段，设置索引 高级操作 使用nosql数据库，redis 专业操作 Elasticsearch与Solr 针对于电商行业 select * from tbl_product where name like &#x27;%手机%&#x27; --&gt; &lt;!--&lt;settings&gt; &lt;setting name=&quot;&quot; value=&quot;&quot;/&gt; &lt;/settings&gt;--&gt; &lt;!-- 为mapper映射文件中的domain起别名 --&gt; &lt;typeAliases&gt; &lt;!-- 方式1： 为指定的类分别起别名，别名的命名由我们自己来决定 type：要为哪个domian起别名 填写包.类名称 alias：别名的名字 --&gt; &lt;!--&lt;typeAlias type=&quot;com.bjpowernode.domain.Student&quot; alias=&quot;stu&quot;/&gt;--&gt; &lt;!-- 方式2： 使用package标签批量起别名 别名是MyBatis默认为我们取好的，命名不是由我们自己决定，别名为类名（类名的字母不区分大小写） 虽然字母不区分大小写，但是我们还是要按照预定俗成的规则填写类名，类名首字母可以小写 name：指定一个包结构，表示在该包下，所有的domain自动起好了别名 --&gt; &lt;!-- 总结： （1）未来实际项目开发中，如果公司需要使用起别名的机制，我们要使用批量起别名的方式 （2）在市场上也有很多企业摒弃使用MyBaits起别名的机制 公司会认为将domian写成全路径，可以有效的提供代码的可读性 --&gt; &lt;package name=&quot;com.bjpowernode.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;//注册 &lt;!--&lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt; &lt;!-- 方式1： 使用resource属性，指定mapper映射文件 --&gt; &lt;!--&lt;mapper resource=&quot;com/bjpowernode/dao/StudentDao.xml&quot;/&gt;--&gt; &lt;!-- 方式2： 使用class属性，找到dao层接口的全路径 --&gt; &lt;!--&lt;mapper class=&quot;com.bjpowernode.dao.StudentDao&quot;/&gt;--&gt; &lt;!-- 方式3： 批量注册 name属性：指向dao层的包，表示在该dao包下，所有的mapper映射文件自动注册--&gt; &lt;!--总结：未来实际项目开发中，我们一定是批量注册mapper映射文件--&gt; &lt;package name=&quot;com.bjpowernode.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.mapper配置文件 使用简单类型（8基本数据类型+String）为参数 在#{}中的标识符可以随意去写,但是虽然可以随意写，还是要写的有意义 如果我们为sql语句传递的参数类型为一个domian引用类型 那么#{}中的标识符必须是domain类的属性名 模糊查询: ‘%’空格#{}空格’%’ 以上空格不能省略 12345678910111213总结： 在实际项目开发中，使用domian引用类型，或者是使用map集合类型都可以为sql语句同时传递多个参数 一般情况下，我们使用domain就可以了 当domain不符合需求的情况下，我们一定要考虑使用map来传值 需求：请查询出 姓名为wyf，班级为一年一班的学员的详细信息 select * from tbl_student s join tbl_classroom c on s.classroomId&#x3D;c.id where s.name&#x3D;#&#123;wyf&#125; and c.name&#x3D;#&#123;一年一班&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bjpowernode.dao.StudentDao&quot;&gt; &lt;!-- 对于parameterType： java.lang.String 好使 String 好使 string 好使 str 不好使 parameterType省略不写 好使 --&gt; &lt;!-- 使用简单类型（8基本数据类型+String）为参数 在#&#123;&#125;中的标识符可以随意去写 但是虽然可以随意写，还是要写的有意义 --&gt; &lt;select id=&quot;select1&quot; parameterType=&quot;string&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 如果我们为sql语句传递的参数类型为一个domian引用类型 那么#&#123;&#125;中的标识符必须是domain类的属性名 --&gt; &lt;select id=&quot;select4&quot; parameterType=&quot;Student&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where name=#&#123;name&#125; and age=#&#123;age&#125; &lt;/select&gt; &lt;!-- 如果我们为sql语句传递的参数类型为一个map类型 那么#&#123;&#125;中的标识符必须是map的key --&gt; &lt;select id=&quot;select5&quot; parameterType=&quot;map&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where name=#&#123;name&#125; and age=#&#123;age&#125; &lt;/select&gt; &lt;select id=&quot;select6&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where id=&#x27;$&#123;value&#125;&#x27; &lt;/select&gt; &lt;select id=&quot;select7&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where name like &#x27;%$&#123;value&#125;%&#x27; &lt;/select&gt; &lt;select id=&quot;select8&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where name like #&#123;name&#125; &lt;/select&gt; &lt;!-- 注意： &#x27;%&#x27;空格#&#123;&#125;空格&#x27;%&#x27; 以上空格不能省略 --&gt; &lt;select id=&quot;select9&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where name like &#x27;%&#x27; #&#123;name&#125; &#x27;%&#x27; &lt;/select&gt; &lt;select id=&quot;select10&quot; resultType=&quot;String&quot;&gt; select name from tbl_student where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;select11&quot; resultType=&quot;String&quot;&gt; select name from tbl_student &lt;/select&gt; &lt;select id=&quot;select12&quot; resultType=&quot;int&quot;&gt; select count(*) from tbl_student &lt;/select&gt; &lt;select id=&quot;select14&quot; resultType=&quot;map&quot;&gt; select * from tbl_student &lt;/select&gt; &lt;!--数据库中的字段名和实体类中属性不一样,可以起别名--&gt; &lt;select id=&quot;select15&quot; resultType=&quot;Student&quot;&gt; select id, fullname as name, age from tbl_student &lt;/select&gt; &lt;!-- id:resultMap标签对的唯一标识 将来在使用到该resultMap标签的时候，使用id来找到这组标签 type：指定一个类型，与数据库表一一对应，建立起表字段和类属性的名字一一匹配的关系 --&gt; &lt;resultMap id=&quot;stuMap&quot; type=&quot;Student&quot;&gt; &lt;!-- id标签：用来配置主键的对应关系的 result标签：用来配置普通字段对应关系的 对于tbl_student表，表结果时一个id，两个普通字段 所以我们需要一个id标签，两个result标签 property属性:配置的是类中的属性名 column属性：配置的是表中的字段名 这样就能够建立起类属性和表字段一一对应的关系了 Student id name age tbl_student tbl_id tbl_name tbl_age --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;fullname&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;select16&quot; resultMap=&quot;stuMap&quot;&gt; select id,fullname,age from tbl_student &lt;/select&gt; &lt;select id=&quot;select17&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student &lt;!-- where标签： 当where标签在使用的时候，必须要搭配where标签对中的if标签来使用 通过if标签的判断，如果有查询条件，则展现where关键字，如果没有查询条件则不展现where关键字 where标签会自动的屏蔽掉第一个连接符 and/or --&gt; &lt;where&gt; &lt;if test=&quot;name!=null and name!=&#x27;&#x27;&quot;&gt; and name like &#x27;%&#x27; #&#123;name&#125; &#x27;%&#x27; &lt;/if&gt; &lt;if test=&quot;address!=null and address!=&#x27;&#x27;&quot;&gt; and address like &#x27;%&#x27; #&#123;address&#125; &#x27;%&#x27; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;select18&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where id in &lt;!-- foreach标签：用来遍历传递来的数组参数 collection:标识传递参数的类型 array:数组 list:集合 item:每一次遍历出来的元素，在使用该元素的时候，需要套用在#&#123;&#125;中 open:拼接循环的开始符号 close:拼接循环的结束符号 separator:元素与元素之间的分隔符 --&gt; &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- 使用sql标签制作sql片段 sql片段的作用是用来代替sql语句中的代码 如果你的mapper映射文件中的sql语句某些代码出现了大量的重复，我们可以使用sql片段来代替他们 id：sql片段的唯一标识，将来找到sql片段使用id来进行定位 将来的实际项目开发中，使用sql片段用来代替重复率高，且复杂的子查询 select * from tbl where name=( select xxxxx xxxxx ( select ..... ) ) 注意： 对于sql片段 在同一个mapper下，大量的出现重复的子查询的几率不高，所以一般情况下没有使用sql片段的必要 在实际项目开发中，如果你大量的使用sql片段，会大大的降低sql语句的可读性 在很多企业中，干脆摒弃使用sql片段的机制 --&gt; &lt;sql id=&quot;sql1&quot;&gt; select * from tbl_student &lt;/sql&gt; &lt;select id=&quot;select19&quot; resultType=&quot;Student&quot;&gt; &lt;include refid=&quot;sql1&quot;/&gt; where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;select20&quot; resultType=&quot;map&quot;&gt; select s.name as sname, c.name as cname from tbl_student s join tbl_classroom c on s.classroomId=c.id &lt;/select&gt; &lt;select id=&quot;select21&quot; resultType=&quot;com.bjpowernode.vo.StudentAndClassroomVo&quot;&gt; select s.id sid, s.name sname, s.age sage, s.address saddress, c.id cid, c.name cname from tbl_student s join tbl_classroom c on s.classroomId=c.id &lt;/select&gt; &lt;select id=&quot;select22&quot; resultType=&quot;com.bjpowernode.vo.StudentAndClassroomVo&quot;&gt; select s.id sid, s.name sname, s.age sage, s.address saddress, c.id cid, c.name cname from tbl_student s join tbl_classroom c on s.classroomId=c.id where s.name like &#x27;%&#x27; #&#123;name&#125; &#x27;%&#x27; &lt;/select&gt;&lt;/mapper&gt; test测试: 12345678910111213141516171819202122232425262728293031323334353637383940411.如果我们要为sql语句传递多个参数，我们应该将这多个参数封装到一个domain对象中，或者是打包到一个map集合中 4.测试：parameterType，使用domain为参数 Student s //需求：查询出姓名为wyf，年龄为23岁的学员信息 Student s = new Student(); s.setName(&quot;wyf&quot;); s.setAge(23); List&lt;Student&gt; sList = studentDao.select4(s); for(Student s1:sList)&#123; System.out.println(s1); &#125; 5.测试：parameterType，使用map为参数 //需求：查询出姓名为wyf，年龄为23岁的学员信息 Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;name&quot;, &quot;wyf&quot;); map.put(&quot;age&quot;, 23); List&lt;Student&gt; sList = studentDao.select5(map); for(Student s1:sList)&#123; System.out.println(s1); &#125;/* 总结： 在实际项目开发中，使用domian引用类型，或者是使用map集合类型都可以为sql语句同时传递多个参数 一般情况下，我们使用domain就可以了 当domain不符合需求的情况下，我们一定要考虑使用map来传值 需求：请查询出 姓名为wyf，班级为一年一班的学员的详细信息 select * from tbl_student s join tbl_classroom c on s.classroomId=c.id where s.name=#&#123;wyf&#125; and c.name=#&#123;一年一班&#125; */ /* 在实际项目开发中，一定要学会使用为sql传值的这几种方式 但是对于在&lt;select&gt;中的parameterType属性，一般我们都是省略不写的 */ 1.map测试:123456789101112131415161718192021222324252627282930/* 对于sql语句查询的结果，我们使用domian来封装这些结果多方便啊，为什么还要使用map呢？ 因为对于查询的结果，很多情况，使用domain封装不了，所以我们会想到使用map来保存结果 例如： 需求：根据姓名分组，查询出来每一个姓名对应的数量 叫wyf的有多少人 叫lh的有多少人 ... select name,count(*) from tbl_student group by name 对于以上查询结果，使用domain能封装查询结果值吗？ 不能！因为domain有name属性，但是没有count属性 使用返回map一定可以保存查询得到的结果 */ List&lt;Map&lt;String,Object&gt;&gt; mapList = studentDao.select14(); for(Map&lt;String,Object&gt; map : mapList)&#123; Set&lt;String&gt; set = map.keySet(); for(String key : set)&#123; System.out.println(&quot;key:&quot;+key); System.out.println(&quot;value:&quot;+map.get(key)); &#125; System.out.println(&quot;----------------------------&quot;); &#125; 当数据库表字段名称和domain类属性名称不一致时的处理: 2.1 起别名:1234567891011&lt;select id=&quot;select15&quot; resultType=&quot;Student&quot;&gt; select id, fullname as name, age from tbl_student &lt;/select&gt; 2.2 resultMap:12345678910111213141516171819202122232425262728293031&lt;resultMap id=&quot;stuMap&quot; type=&quot;Student&quot;&gt; &lt;!-- id标签：用来配置主键的对应关系的 result标签：用来配置普通字段对应关系的 对于tbl_student表，表结果时一个id，两个普通字段 所以我们需要一个id标签，两个result标签 property属性:配置的是类中的属性名 column属性：配置的是表中的字段名 这样就能够建立起类属性和表字段一一对应的关系了 Student id name age tbl_student tbl_id tbl_name tbl_age --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;fullname&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;select16&quot; resultMap=&quot;stuMap&quot;&gt; select id,fullname,age from tbl_student &lt;/select&gt; 3.动态sql–where123456789101112131415161718&lt;select id=&quot;select17&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student &lt;!-- where标签： 当where标签在使用的时候，必须要搭配where标签对中的if标签来使用 通过if标签的判断，如果有查询条件，则展现where关键字，如果没有查询条件则不展现where关键字 where标签会自动的屏蔽掉第一个连接符 and/or --&gt; &lt;where&gt; &lt;if test=&quot;name!=null and name!=&#x27;&#x27;&quot;&gt; and name like &#x27;%&#x27; #&#123;name&#125; &#x27;%&#x27; &lt;/if&gt; &lt;if test=&quot;address!=null and address!=&#x27;&#x27;&quot;&gt; and address like &#x27;%&#x27; #&#123;address&#125; &#x27;%&#x27; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 4.foreach 前端往后端传数据用数组,后端往前端传数据用集合 123456789101112131415161718&lt;select id=&quot;select18&quot; resultType=&quot;Student&quot;&gt; select * from tbl_student where id in &lt;!-- foreach标签：用来遍历传递来的数组参数 collection:标识传递参数的类型 array:数组 list:集合 item:每一次遍历出来的元素，在使用该元素的时候，需要套用在#&#123;&#125;中 open:拼接循环的开始符号 close:拼接循环的结束符号 separator:元素与元素之间的分隔符 --&gt; &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; 4.sql片段12345678910111213141516171819202122232425262728293031&lt;!-- 使用sql标签制作sql片段 sql片段的作用是用来代替sql语句中的代码 如果你的mapper映射文件中的sql语句某些代码出现了大量的重复，我们可以使用sql片段来代替他们 id：sql片段的唯一标识，将来找到sql片段使用id来进行定位 将来的实际项目开发中，使用sql片段用来代替重复率高，且复杂的子查询 select * from tbl where name=( select xxxxx xxxxx ( select ..... ) ) 注意： 对于sql片段 在同一个mapper下，大量的出现重复的子查询的几率不高，所以一般情况下没有使用sql片段的必要 在实际项目开发中，如果你大量的使用sql片段，会大大的降低sql语句的可读性 在很多企业中，干脆摒弃使用sql片段的机制 --&gt; &lt;sql id=&quot;sql1&quot;&gt; select * from tbl_student &lt;/sql&gt; &lt;select id=&quot;select19&quot; resultType=&quot;Student&quot;&gt; &lt;include refid=&quot;sql1&quot;/&gt; where id=#&#123;id&#125; &lt;/select&gt; 5.vo(value Object/ view Object)是dao层查出数据往前端传 StudentAndClassroomVo.class: 原由:查询的内容来自不同的表,可以创建一个实体类合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.bjpowernode.vo;import com.bjpowernode.domain.Student;/** * Author 北京动力节点 */public class StudentAndClassroomVo &#123; //学生相关信息 private String sid; private String sname; private int sage; private String saddress; //班级相关的信息 private String cid; private String cname; public String getSid() &#123; return sid; &#125; public void setSid(String sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSage() &#123; return sage; &#125; public void setSage(int sage) &#123; this.sage = sage; &#125; public String getSaddress() &#123; return saddress; &#125; public void setSaddress(String saddress) &#123; this.saddress = saddress; &#125; public String getCid() &#123; return cid; &#125; public void setCid(String cid) &#123; this.cid = cid; &#125; public String getCname() &#123; return cname; &#125; public void setCname(String cname) &#123; this.cname = cname; &#125; @Override public String toString() &#123; return &quot;StudentAndClassroomVo&#123;&quot; + &quot;sid=&#x27;&quot; + sid + &#x27;\\&#x27;&#x27; + &quot;, sname=&#x27;&quot; + sname + &#x27;\\&#x27;&#x27; + &quot;, sage=&quot; + sage + &quot;, saddress=&#x27;&quot; + saddress + &#x27;\\&#x27;&#x27; + &quot;, cid=&#x27;&quot; + cid + &#x27;\\&#x27;&#x27; + &quot;, cname=&#x27;&quot; + cname + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314151617181920212223242526//21.测试:多表联查 查询出学生和班级所有信息，加VO /* 在实际项目开发中，如果需要为前端展现的数据，使用一个domain类型不足以表现出来这些数据 这时我们可以考虑使用两种技术来实现 分别为： 使用map以及使用vo 例如我们现在的需求 查询出学生和班级所有信息 得到的结果 使用学生的domain或者班级的domian都不能够封装这些结果 所以我们可以使用map去保存这些信息 同时我们也可以使用vo类来保存这些信息 vo指的是创建出来一个类，这个类中的属性是完全由我们自己去定义，属性会保存所有需要展现的信息 例如我们现在的这个例子，我们可以使用vo来封装所有与学生和班级相关的信息 vo student classroom */ List&lt;StudentAndClassroomVo&gt; voList = studentDao.select21(); for(StudentAndClassroomVo vo:voList)&#123; System.out.println(vo); &#125; 1234567891011121314&lt;select id=&quot;select21&quot; resultType=&quot;com.bjpowernode.vo.StudentAndClassroomVo&quot;&gt; select s.id sid, s.name sname, s.age sage, s.address saddress, c.id cid, c.name cname from tbl_student s join tbl_classroom c on s.classroomId=c.id &lt;/select&gt; 四:Git首先找到一个任意的路径当做本地库目录 例如：目录D:\\git\\test 点击右键 –&gt; Git Bash Here 1.初始化本地库1命令：git init 2. 设置签名1234567891011121314151617设置签名的作用：区分不同开发人员的身份 注意：为Git设置签名与远程库（代码托管中心）的账号密码没有任何关系 设置签名命令： 本地库级别设置签名方式： git config user.name zs git config user.email zs@bjpowernode.com 信息保存位置：.&#x2F;.git&#x2F;config 文件 系统用户级别设置签名方式： git config --global user.name zs git config --global user.email zs@bjpowernode.com ~&#x2F;.gitconfig 文件 优先级按照就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别 的签名 五:项目搭建1.文件夹创建 在main文件夹下建立java文件夹和resources文件夹 与main文件夹平级创建一个test文件夹 test文件夹下创建java文件夹和resources文件夹 ==注意：为文件夹赋予功能（颜色）后，文件夹才会生效== 2.登录流程​ 用户 Controller service dao 1.将html文件转为jsp 加入 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; 将html后缀名字改为jsp 2.注意细节注意： 按钮写在form表单中，默认的行为就是提交表单 一定要将按钮的类型设置为button 按钮所触发的行为应该是由我们自己手动写js代码来决定 过滤器: /* 表示过滤所有 通配符+后缀名—&gt;*.do 错误方法:/abc/*.do ==转发重定向==: 转发:可以访问web-inf下面的资源 重定向:不可以访问web-inf下面的资源 12345678910111213141516重定向的路径怎么写？在实际项目开发中，对于路径的使用，不论操作的是前端还是后端，应该一律使用绝对路径 关于转发和重定向的路径的写法如下： 转发： 使用的是一种特殊的绝对路径的使用方式，这种绝对路径前面不加&#x2F;项目名，这种路径也称之为内部路径 &#x2F;login.jsp 重定向： 使用的是传统绝对路径的写法，前面必须以&#x2F;项目名开头，后面跟具体的资源路径 &#x2F;crm&#x2F;login.jsp为什么使用重定向，使用转发不行吗？ 转发之后，路径会停留在老路径上，而不是跳转之后最新资源的路径 我们应该在为用户跳转到登录页的同时，将浏览器的地址栏应该自动设置为当前的登录页的路径 $&#123;pageContext.request.getContextPath&#125;---&gt;得到的是 &#x2F;项目名 使login.jsp始终在顶层窗口中打开: if(window.top!=window){ ​ window.top.location=window.location; ​ } 3.市场活动1.怎么让下拉列表默认选择一项12345678$(&quot;#grade&quot;).val(&quot;2&quot;); &lt;select id=&quot;grade&quot;&gt; &lt;option value=&quot;1&quot;&gt;高中&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;专科&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;本科&lt;/option&gt; &lt;/select&gt; 2.jsp中用el表达式123456在js中使用el表达式，el表达式一定要套用在字符串中var id &#x3D; &quot;$&#123;user.id&#125;&quot;;$(&quot;#create-owner&quot;).val(id);&#x2F;&#x2F;所有者下拉框处理完毕后，展现模态窗口$(&quot;#createActivityModal&quot;).modal(&quot;show&quot;); 3.日历控件 保存市场活动的时候，需要填写日期，一般情况下都是需要相关的日历控件的。 我们这里使用的前端UI框架是基于Bootstrap实现的，为了统一风格，所有的插件建议使用Bootstrap扩展的插件。 我们这里使用的是：bootstrap datetimepicker（日期拾取器） 1.引入 1234&lt;link href=&quot;jquery/bootstrap-datetimepicker-master/css/bootstrap-datetimepicker.min.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/bootstrap-datetimepicker-master/js/bootstrap-datetimepicker.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/bootstrap-datetimepicker-master/locale/bootstrap-datetimepicker.zh-CN.js&quot;&gt;&lt;/script&gt; 2.设置time类 1234567891011$(&quot;.time&quot;).datetimepicker(&#123; language: &quot;zh-CN&quot;, format: &quot;yyyy-mm-ddhh:ii:ss&quot;,//显示格式 minView: &quot;hour&quot;,//设置只显示到月份 initialDate: new Date(),//初始化当前日期 autoclose: true,//选中自动关闭 todayBtn: true, //显示今日按钮 clearBtn : true, pickerPosition: &quot;bottom-left&quot; &#125;); 123456789$(&quot;.time&quot;).datetimepicker(&#123; minView: &quot;month&quot;, language: &#x27;zh-CN&#x27;, format: &#x27;yyyy-mm-dd&#x27;, autoclose: true, todayBtn: true, pickerPosition: &quot;bottom-left&quot; &#125;); 3.在相关组件的class下引入time类标识 多个class之间可以用空格分开 123456789&lt;div class=&quot;col-sm-10&quot; style=&quot;width: 300px;&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control time&quot; id=&quot;edit-startDate&quot;&gt;&lt;/div&gt;&lt;label for=&quot;edit-endTime&quot; class=&quot;col-sm-2 control-label&quot;&gt;结束日期&lt;/label&gt;&lt;div class=&quot;col-sm-10&quot; style=&quot;width: 300px;&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control time&quot; id=&quot;edit-endDate&quot;&gt;&lt;/div&gt; 4.分页1.后端处理 123456789101、给分页查询专门封装一个VO对象。(关于VO类的说明) 关键代码： public class PaginationVO&lt;T&gt; &#123; privateint total; private List&lt;T&gt;dataList; &#123;“total”:100,”dataList”:[&#123;&#125;,&#123;&#125;,&#123;&#125;]&#125; 2.前端 12345678$(function()&#123; display(1 , 2);&#125;); function display(pageNo , pageSize)&#123; ...&#125; 3.使用分页插件 1234567891011121314151617181920212223242526272829303132333435前端处理： 1、动态展现列表数据 2、使用pagination分页插件 （1）导入pagination插件相关css和js &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;jquery/bs_pagination/jquery.bs_pagination.min.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/bs_pagination/jquery.bs_pagination.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/bs_pagination/en.js&quot;&gt;&lt;/script&gt; （2）在列表下面导入分页组件div（将原有默认分页div去掉） &lt;div id=&quot;activityPage&quot;&gt;&lt;/div&gt; （3）在pageList.do处理ajax返回值后，加入分页组件 $(&quot;#activityPage&quot;).bs_pagination(&#123; currentPage: pageNo, // 页码 rowsPerPage: pageSize, // 每页显示的记录条数 maxRowsPerPage: 20, // 每页最多显示的记录条数 totalPages: totalPages, // 总页数 totalRows: data.total, // 总记录条数 visiblePageLinks: 3, // 显示几个卡片 showGoToPage: true, showRowsPerPage: true, showRowsInfo: true, showRowsDefaultInfo: true, onChangePage : function(event, data)&#123; pageList(data.currentPage , data.rowsPerPage); &#125; &#125;); 处理总页数totalPages （4）调用分页插件 例如点击查询按钮（注意：查询按钮需要设施type=&quot;button&quot;） $(&quot;#searchBtn&quot;).click(function()&#123; pageList(1 ,$(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;rowsPerPage&#x27;)); &#125;); 5.全选input[name=xz]—&gt;表示name=xz的input输入框 12345678910111213141516171819//为全选的复选框绑定事件，触发全选操作$(&quot;#qx&quot;).click(function () &#123; $(&quot;input[name=xz]&quot;).prop(&quot;checked&quot;,this.checked); &#125;) //以下这种做法是不行的 /*$(&quot;input[name=xz]&quot;).click(function () &#123; alert(123); &#125;)*/ //因为动态生成的元素，是不能够以普通绑定事件的形式来进行操作的 /* 动态生成的元素，我们要以on方法的形式来触发事件 语法： $(需要绑定元素的有效的外层元素).on(绑定事件的方式,需要绑定的元素的jquery对象,回调函数) */ $(&quot;#activityBody&quot;).on(&quot;click&quot;,$(&quot;input[name=xz]&quot;),function () &#123; $(&quot;#qx&quot;).prop(&quot;checked&quot;,$(&quot;input[name=xz]&quot;).length==$(&quot;input[name=xz]:checked&quot;).length); &#125;) 6.隐藏域123456789101112131415$(&quot;#searchBtn&quot;).click(function () &#123; /* 点击查询按钮的时候，我们应该将搜索框中的信息保存起来,保存到隐藏域中 */ $(&quot;#hidden-name&quot;).val($.trim($(&quot;#search-name&quot;).val())); $(&quot;#hidden-owner&quot;).val($.trim($(&quot;#search-owner&quot;).val())); $(&quot;#hidden-startDate&quot;).val($.trim($(&quot;#search-startDate&quot;).val())); $(&quot;#hidden-endDate&quot;).val($.trim($(&quot;#search-endDate&quot;).val())); pageList(1,2); &#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function pageList(pageNo,pageSize) &#123; //将全选的复选框的√干掉 $(&quot;#qx&quot;).prop(&quot;checked&quot;,false); //查询前，将隐藏域中保存的信息取出来，重新赋予到搜索框中 $(&quot;#search-name&quot;).val($.trim($(&quot;#hidden-name&quot;).val())); $(&quot;#search-owner&quot;).val($.trim($(&quot;#hidden-owner&quot;).val())); $(&quot;#search-startDate&quot;).val($.trim($(&quot;#hidden-startDate&quot;).val())); $(&quot;#search-endDate&quot;).val($.trim($(&quot;#hidden-endDate&quot;).val())); $.ajax(&#123; url : &quot;workbench/activity/pageList.do&quot;, data : &#123; &quot;pageNo&quot; : pageNo, &quot;pageSize&quot; : pageSize, &quot;name&quot; : $.trim($(&quot;#search-name&quot;).val()), &quot;owner&quot; : $.trim($(&quot;#search-owner&quot;).val()), &quot;startDate&quot; : $.trim($(&quot;#search-startDate&quot;).val()), &quot;endDate&quot; : $.trim($(&quot;#search-endDate&quot;).val()) &#125;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function (data) &#123; /* data 我们需要的：市场活动信息列表 [&#123;市场活动1&#125;,&#123;2&#125;,&#123;3&#125;] List&lt;Activity&gt; aList 一会分页插件需要的：查询出来的总记录数 &#123;&quot;total&quot;:100&#125; int total &#123;&quot;total&quot;:100,&quot;dataList&quot;:[&#123;市场活动1&#125;,&#123;2&#125;,&#123;3&#125;]&#125; */ var html = &quot;&quot;; //每一个n就是每一个市场活动对象 $.each(data.dataList,function (i,n) &#123; html += &#x27;&lt;tr class=&quot;active&quot;&gt;&#x27;; html += &#x27;&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;xz&quot; value=&quot;&#x27;+n.id+&#x27;&quot;/&gt;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&lt;a style=&quot;text-decoration: none; cursor: pointer;&quot; onclick=&quot;window.location.href=\\&#x27;workbench/activity/detail.do?id=&#x27;+n.id+&#x27;\\&#x27;;&quot;&gt;&#x27;+n.name+&#x27;&lt;/a&gt;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.owner+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.startDate+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.endDate+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;/tr&gt;&#x27;; &#125;) $(&quot;#activityBody&quot;).html(html); //计算总页数 var totalPages = data.total%pageSize==0?data.total/pageSize:parseInt(data.total/pageSize)+1; //数据处理完毕后，结合分页查询，对前端展现分页信息 $(&quot;#activityPage&quot;).bs_pagination(&#123; currentPage: pageNo, // 页码 rowsPerPage: pageSize, // 每页显示的记录条数 maxRowsPerPage: 20, // 每页最多显示的记录条数 totalPages: totalPages, // 总页数 totalRows: data.total, // 总记录条数 visiblePageLinks: 3, // 显示几个卡片 showGoToPage: true, showRowsPerPage: true, showRowsInfo: true, showRowsDefaultInfo: true, //该回调函数时在，点击分页组件的时候触发的 onChangePage : function(event, data)&#123; pageList(data.currentPage , data.rowsPerPage); &#125; &#125;); &#125; &#125;) &#125; 7.textarea1234（1）一定是要以标签对的形式来呈现,正常状态下标签对要紧紧的挨着（2）textarea虽然是以标签对的形式来呈现的，但是它也是属于表单元素范畴 我们所有的对于textarea的取值和赋值操作，应该统一使用val()方法（而不是html()方法） 8.更新后，停留分页1234567891011121314151617181920212223242526272829303132333435363738394041实现分页查询市场活动： 前端处理： 1、动态展现列表数据 2、使用pagination分页插件 （1）导入pagination插件相关css和js &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;jquery/bs_pagination/jquery.bs_pagination.min.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/bs_pagination/jquery.bs_pagination.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/bs_pagination/en.js&quot;&gt;&lt;/script&gt; （2）在列表下面导入分页组件div（将原有默认分页div去掉） &lt;div id=&quot;activityPage&quot;&gt;&lt;/div&gt; （3）在pageList.do处理ajax返回值后，加入分页组件 $(&quot;#activityPage&quot;).bs_pagination(&#123; currentPage: pageNo, // 页码 rowsPerPage: pageSize, // 每页显示的记录条数 maxRowsPerPage: 20, // 每页最多显示的记录条数 totalPages: totalPages, // 总页数 totalRows: data.total, // 总记录条数 visiblePageLinks: 3, // 显示几个卡片 showGoToPage: true, showRowsPerPage: true, showRowsInfo: true, showRowsDefaultInfo: true, onChangePage : function(event, data)&#123; pageList(data.currentPage , data.rowsPerPage); &#125; &#125;); 处理总页数totalPages （4）调用分页插件 例如点击查询按钮（注意：查询按钮需要设施type=&quot;button&quot;） $(&quot;#searchBtn&quot;).click(function()&#123; pageList(1 ,$(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;rowsPerPage&#x27;)); &#125;); （5）js中对于totalPages的处理 vartotalPages = data.total%pageSize==0 ? data.total/pageSize :parseInt(data.total/pageSize)+1; （6）ajax对于时间戳的加入 cache : false 做完添加操作后，应该回到第一页，维持每页展现的记录数 修改操作后，应该维持在当前页，维持每页展现的记录数 删除后,回到第一页,维持每页展现的记录数 1234关键代码 pageList($(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;currentPage&#x27;) ,$(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;rowsPerPage&#x27;)); 例子: 1234567891011121314151617181920/* $(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;currentPage&#x27;): 操作后停留在当前页 $(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;rowsPerPage&#x27;) 操作后维持已经设置好的每页展现的记录数 这两个参数不需要我们进行任何的修改操作直接使用即可 */ //做完添加操作后，应该回到第一页，维持每页展现的记录数 pageList(1,$(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;rowsPerPage&#x27;));/* 修改操作后，应该维持在当前页，维持每页展现的记录数 */ pageList($(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;currentPage&#x27;) ,$(&quot;#activityPage&quot;).bs_pagination(&#x27;getOption&#x27;, &#x27;rowsPerPage&#x27;)); 9.foreach中动态拼接注意:两个单引号转义后,还需要两个单引号,即必须套在单引号中拼接 123html += &#x27;&lt;a class=&quot;myHref&quot; href=&quot;javascript:void(0);&quot; onclick=&quot;editRemark(\\&#x27;&#x27;+n.id+&#x27;\\&#x27;)&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-edit&quot; style=&quot;font-size: 20px; color: #FF0000;&quot;&gt;&lt;/span&gt;&lt;/a&gt;&#x27;; 10.模态窗口的自动刷新 为关联市场活动模态窗口中的 搜索框 绑定事件，通过触发回车键，查询并展现所需市场活动列表 展现完列表后，记得将模态窗口默认的回车行为禁用掉 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//为关联市场活动模态窗口中的 搜索框 绑定事件，通过触发回车键，查询并展现所需市场活动列表$(&quot;#aname&quot;).keydown(function (event) &#123; //如果是回车键 if(event.keyCode==13)&#123; //alert(&quot;查询并展现市场活动列表&quot;); $.ajax(&#123; url : &quot;workbench/clue/getActivityListByNameAndNotByClueId.do&quot;, data : &#123; &quot;aname&quot; : $.trim($(&quot;#aname&quot;).val()), &quot;clueId&quot; : &quot;$&#123;c.id&#125;&quot; &#125;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function (data) &#123; /* data [&#123;市场活动1&#125;,&#123;2&#125;,&#123;3&#125;] */ var html = &quot;&quot;; $.each(data,function (i,n) &#123; html += &#x27;&lt;tr&gt;&#x27;; html += &#x27;&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;xz&quot; value=&quot;&#x27;+n.id+&#x27;&quot;/&gt;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.name+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.startDate+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.endDate+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;td&gt;&#x27;+n.owner+&#x27;&lt;/td&gt;&#x27;; html += &#x27;&lt;/tr&gt;&#x27;; &#125;) $(&quot;#activitySearchBody&quot;).html(html); &#125; &#125;) //展现完列表后，记得将模态窗口默认的回车行为禁用掉 return false; &#125; &#125;) 11.多个id追加123456789101112131415161718192021222324252627//为关联按钮绑定事件，执行关联表的添加操作 $(&quot;#bundBtn&quot;).click(function () &#123; var $xz = $(&quot;input[name=xz]:checked&quot;); if($xz.length==0)&#123; alert(&quot;请选择需要关联的市场活动&quot;); //1条或者多条 &#125;else&#123; //workbench/clue/bund.do?cid=xxx&amp;aid=xxx&amp;aid=xxx&amp;aid=xxx var param = &quot;cid=$&#123;c.id&#125;&amp;&quot;; for(var i=0;i&lt;$xz.length;i++)&#123; param += &quot;aid=&quot;+$($xz[i]).val(); if(i&lt;$xz.length-1)&#123; param += &quot;&amp;&quot;; &#125; &#125;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}